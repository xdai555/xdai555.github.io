<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用 netmiko 的 is_alive() 方法实现 ssh 保活机制</title>
    <url>/posts/ad63b5a0.html</url>
    <content><![CDATA[<p>在使用 Netmiko 的过程中，出于某些原因（SSH 新建连接慢、VTY 数量限制等），需要把 Netmiko 已经连接到设备上的 SSH 会话保持住，防止超时。</p>
<p>网络设备的超时时间是按照最后一次接收到命令的时间开始算的（以华三设备为例），所以一般发送一个回车、空字符等等都可以实现保活。</p>
<p>Netmiko 本身提供了一个 <code>is_alive()</code> 方法来对会话进行验证，底层实现是通过发送 <code>null</code> 来做的。</p>
<p>简单记录一下验证过程：</p>
<span id="more"></span>

<p>网络设备配置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">line vty 0 63</span><br><span class="line"> ...</span><br><span class="line"> idle-timeout 0 10</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler <span class="keyword">as</span> ch</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">host = &#123;</span><br><span class="line">    <span class="string">&#x27;device_type&#x27;</span>: <span class="string">&#x27;hp_comware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;NetDevops@01&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn = ch(**host)</span><br><span class="line"><span class="comment"># 设备配置 10s 超时，每隔 3s 发送 is_alive()，15s 后仍然可以执行命令</span></span><br><span class="line"><span class="comment"># 说明 is_alive() 这个方法发送的空字符可以保活</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(conn.is_alive())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">result = conn.send_command(<span class="string">&quot;dis arp&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 打印正常</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment">#   Type: S-Static   D-Dynamic   O-Openflow   R-Rule   M-Multiport  I-Invalid</span></span><br><span class="line"><span class="comment"># IP address       MAC address    SVLAN/VSI Interface/Link ID        Aging Type  </span></span><br><span class="line"><span class="comment"># 192.168.56.1     0a00-2700-0032 --        XGE1/0/49                16    D   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设备配置 10s 超时，sleep 11s 后，执行命令提示超时</span></span><br><span class="line">time.sleep(<span class="number">11</span>)</span><br><span class="line">result = conn.send_command(<span class="string">&quot;dis arp&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line"><span class="comment">#     raise socket.error(&quot;Socket is closed&quot;)</span></span><br><span class="line"><span class="comment"># OSError: Socket is closed</span></span><br></pre></td></tr></table></figure>

<p>不同的设备实现机制可能会不一样，需要根据自己实际的情况进行验证。</p>
<hr>
<p>Netmiko 的源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_alive</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a boolean flag with the state of the connection.&quot;&quot;&quot;</span></span><br><span class="line">    null = <span class="built_in">chr</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> self.remote_conn <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        log.error(<span class="string">&quot;Connection is not initialised, is_alive returns False&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> self.protocol == <span class="string">&quot;telnet&quot;</span>:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># SSH</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># Try sending ASCII null byte to maintain the connection alive</span></span><br><span class="line">            log.debug(<span class="string">&quot;Sending the NULL byte&quot;</span>)</span><br><span class="line">            <span class="comment"># 向 channel 发送一个空字符串，如果能正常发送成功，则说明会话还在</span></span><br><span class="line">            <span class="comment"># 网络设备的超时时间是按照最后一次接收到命令的时间开始算的</span></span><br><span class="line">            <span class="comment"># 所以每次进行 is_alive() 的判断，都会刷新 vty 的超时时间</span></span><br><span class="line">            self.write_channel(null)</span><br><span class="line">            <span class="keyword">return</span> self.remote_conn.transport.is_active()</span><br><span class="line">        <span class="keyword">except</span> (socket.error, EOFError):</span><br><span class="line">            log.error(<span class="string">&quot;Unable to send&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># If unable to send, we can tell for sure that the connection is unusable</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>netmiko</tag>
      </tags>
  </entry>
  <entry>
    <title>OSPF 最佳实践</title>
    <url>/posts/fd4d8189.html</url>
    <content><![CDATA[<h2 id="Router-ID"><a href="#Router-ID" class="headerlink" title="Router ID"></a>Router ID</h2><ul>
<li>使用 router-id 命令为指定进程手动指定 router-id。</li>
<li>如果 router-id 需要路由可达，配置具有相同 IP 地址的 loopback 接口，并将其宣告在 OSPF 进程下。</li>
<li>在本区域的地址空间中选择一个地址作为 router-id 及 loopback 接口，便于路由发布；或者全网使用单独的网段来配置 router-id</li>
<li>如果其他协议或者功能等需要使用 loopback 接口，尽量使用新的地址</li>
</ul>
<h2 id="Process-ID"><a href="#Process-ID" class="headerlink" title="Process ID"></a>Process ID</h2><p>OSPF process id 是本地有效的，用来区分不同的 OSPF 进程，但是仍然建议在单进程的情况下全网配置保持一致，这样有利于自动化配置。</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>邻居路由器两端接口的验证模式必须一致，如果设置了密钥，需要保证密钥一致，认证分为接口认证和区域认证两种。</p>
<span id="more"></span>

<p>参考配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 区域认证</span></span><br><span class="line"><span class="string">ospf</span> <span class="number">1</span> <span class="string">router-id</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="string">area</span> <span class="number">0</span></span><br><span class="line">  <span class="string">authentication-mode</span> <span class="string">md5</span> <span class="number">1</span> <span class="string">plain</span> <span class="string">area0-auth</span></span><br><span class="line"><span class="comment"># 接口认证</span></span><br><span class="line"><span class="string">interface</span> <span class="string">GigabitEthernet1/0/1</span></span><br><span class="line">  <span class="string">ospf</span> <span class="string">authentication-mode</span> <span class="string">md5</span> <span class="number">1</span> <span class="string">plain</span> <span class="string">interface-auth</span></span><br></pre></td></tr></table></figure>

<p>建议为每个邻居设置不同的验证口令。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><p>如果要使 OSPF 路由信息不被某一网络中的路由器获得，可以禁止接口收发 OSPF 报文，然后再按需启用。</p>
<p>参考配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ospf 1 router-id 1.1.1.1</span><br><span class="line">  silent-interface all</span><br><span class="line">  undo silent-interface GigabitEthernet1/0/1</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在广播网络中（如以太网）中只有两个邻居，并且不会添加其他邻居，建议将这两个邻居的接口配置为 P2P 网络类型。</p>
<p>参考配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">interface</span> <span class="string">GigabitEthernet1/0/1</span></span><br><span class="line">  <span class="string">ospf</span> <span class="string">network-type</span> <span class="string">p2p</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在广播网络中（如以太网）中有多个邻居，建议通过优先级指定 DR 和 BDR。</p>
<p>参考配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">interface</span> <span class="string">GigabitEthernet1/0/1</span></span><br><span class="line">  <span class="string">ospf</span> <span class="string">dr-priority</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>宣告路由时，建议宣告精确的网络，如互联接口地址使用 30 位掩码。</p>
</li>
<li><p>调整 OSPF 开销计算参考带宽为当前网络环境中的最高带宽，而不是使用默认的 100Mbps（10^8）且保证全网一致。</p>
<p>参考配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认单位为 Mbits/s</span><br><span class="line">ospf 1 router-id 1.1.1.1</span><br><span class="line">  bandwidth-reference 100000</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h2><ul>
<li><p>骨干区域使用高性能的设备。</p>
</li>
<li><p>骨干区域使用冗余的物理链路进行连接以防止骨干区域不连续（建立多个骨干区域邻居关系）。</p>
</li>
<li><p>如果无法保证骨干区域物理链路冗余，可以使用虚连接（最好不要使用）。</p>
</li>
<li><p>在有冗余链路的情况下，建议在骨干区域中宣告 loopback 接口，防止骨干路由器断开时，ABR 的状态发生变化从而造成流量路径的变化。</p>
</li>
<li><p>合理规划特殊区域（Stub、Totally Stub、NSSA、Totally NSSA）以减少路由条目。</p>
</li>
</ul>
<h2 id="路由引入"><a href="#路由引入" class="headerlink" title="路由引入"></a>路由引入</h2><p>路由引入也称为路由重分发。</p>
<ul>
<li>避免在多个节点相互进行路由引入；如果出现这种情况，使用前缀列表和标签的方式控制路由，以避免将相同的路由条目发回源域</li>
<li>使用路由策略引入路由，即使是静态路由、直连路由</li>
</ul>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合路由，也称为汇总路由，路由汇总等。</p>
<ul>
<li><p>建议手动设置聚合路由的开销值，以防止开销值因区域内的网络变化而改变。</p>
</li>
<li><p>配置区域间路由聚合</p>
<p>OSPF 区域间路由聚合是指 ABR 将具有相同前缀的路由信息聚合，只发布一条路由到其它区域，这样可以减少路由信息，减小路由表的规模，提高路由器的运算速度。</p>
<p>参考配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ospf</span> <span class="number">1</span> <span class="string">router-id</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="string">area</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># 宣告本区域网段</span></span><br><span class="line">  <span class="string">network</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.255</span></span><br><span class="line">  <span class="string">network</span> <span class="number">10.1</span><span class="number">.2</span><span class="number">.0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.255</span></span><br><span class="line">  <span class="comment"># 聚合本区域路由</span></span><br><span class="line">  <span class="string">abr-summary</span> <span class="number">10.1</span><span class="number">.0</span><span class="number">.0</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置外部路由聚合</p>
<p>ASBR 引入外部路由后，每一条路由都会放在单独的一条 Type-5 LSA 中向外宣告，在 ASBR 上配置路由聚合后，将对聚合地址范围内的 Type-5 LSA 进行聚合；如果 ASBR 在 NSSA 区域里面，将对聚合地址范围内的 Type-7 LSA 进行聚合。</p>
<p>参考配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 外部路由</span></span><br><span class="line"><span class="string">ip</span> <span class="string">route-static</span> <span class="number">100.64</span><span class="number">.1</span><span class="number">.0</span> <span class="number">24</span> <span class="number">12.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"><span class="string">ip</span> <span class="string">route-static</span> <span class="number">100.64</span><span class="number">.2</span><span class="number">.0</span> <span class="number">24</span> <span class="number">13.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"><span class="string">ospf</span> <span class="number">1</span> <span class="string">router-id</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="comment"># 引入外部路由</span></span><br><span class="line">  <span class="string">import-route</span> <span class="string">static</span></span><br><span class="line">  <span class="comment"># 对外部路由进行聚合</span></span><br><span class="line">  <span class="string">asbr-summary</span> <span class="number">100.64</span><span class="number">.0</span><span class="number">.0</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>建议为 OSPF 区域划分多个 ABR 以实现冗余，但应该保证数量合理（2~4）以限制域内汇总 LSA 的数量。</p>
</li>
<li><p>如果一个区域内部有多个 ABR，应该该区域中的所有 ABR 上配置<strong>相同掩码长度</strong>的聚合路由。</p>
</li>
<li><p>为聚合的地址段配置指向 NULL0 的黑洞路由，以避免在某些情况下出现路由环路。</p>
<p>参考配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route-static 100.64.0.0 16 null 0</span><br><span class="line">ip route-static 10.1.0.0 16 null 0</span><br></pre></td></tr></table></figure>

<p>注：在一些新的设备上面，会默认产生引入聚合 NULL0 路由和区域间聚合 NULL0 路由，且 NULL0 路由优先级为 255，如下：</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/image-20220410193127230.png" alt="image-20220410193127230"></p>
</li>
</ul>
<h2 id="快速收敛"><a href="#快速收敛" class="headerlink" title="快速收敛"></a>快速收敛</h2><ul>
<li><p>调整接口物理类型为 P2P</p>
</li>
<li><p>调整 Hello&#x2F;Dead 时间为 1s &#x2F; 4s</p>
</li>
<li><p>调整 OSPF 路由计算时间间隔（网络变化不频繁的情况下调小，否则会占用大量系统资源）</p>
<p>参考配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ospf</span> <span class="number">1</span> <span class="string">router-id</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="comment"># 单位为毫秒，默认为最大为 5 秒，最小为 50 ms，惩罚值为 200ms</span></span><br><span class="line">  <span class="string">spf-schedule-interval</span> <span class="number">50</span> <span class="number">50</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启增量最短路径优先算法，对OSPF中最短路径树的增量计算，默认开启</p>
<p>参考配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ospf</span> <span class="number">1</span> <span class="string">router-id</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="string">ispf</span> <span class="string">enable</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置与 BFD 联动，下层链路出现故障时 BFD 能够快速感知并通告给 OSPF 协议</p>
<p>参考配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface GigabitEthernet1/0/1</span><br><span class="line">  ospf bfd enable</span><br><span class="line">  bfd min-transmit-interval 500</span><br><span class="line">  bfd min-receive-interval 500</span><br><span class="line">  bfd detect-multiplier 6</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>ospf</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 端口转发配置</title>
    <url>/posts/f161c36b.html</url>
    <content><![CDATA[<p><strong>SSH开启端口转发需要修改 &#x2F;etc&#x2F;ssh&#x2F;sshd_config配置文件，将 GatewayPorts修改为yes</strong></p>
<p>参数解释：</p>
<p>-f 后台执行ssh指令<br>-C 允许压缩数据<br>-N 不执行远程指令<br>-R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口<br>-L 本地端口转发<br>-D 动态端口转发</p>
<p>简版：本地端口转发（相当于正向代理），本地监听16379端口，将16379端口的流量都转发给6379端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -fCNL *:16379:localhost:6379 localhost</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="SSH做反向隧道-远程端口转发-实例"><a href="#SSH做反向隧道-远程端口转发-实例" class="headerlink" title="SSH做反向隧道(远程端口转发)实例"></a>SSH做反向隧道(远程端口转发)实例</h3><p><img data-src="http://oss.xdai.vip/md-note/imgs/image-20220214213238533.png" alt="image-20220214213238533"></p>
<ol>
<li>server的配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将Server的22号端口的流量都转发给跳板机2的5555端口</span><br><span class="line">ssh -fCNR  跳板机2:5555:localhost:22  root@跳板机2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>跳板机2的配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -fCNR 跳板机1:5555:localhost:8888 root@跳板机1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>跳板机1的配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 正向代理</span><br><span class="line"># 本地监听的1234端口的流量都转发给本地的8888端口</span><br><span class="line">ssh -fCNL  *:1234:localhost:8888 localhost</span><br></pre></td></tr></table></figure>

<p>PC1上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -p 1234 root@跳板机1</span><br></pre></td></tr></table></figure>
<p>最终连接到了server的22端口上</p>
<p><strong>缺点：这种ssh反向链接会因为超时而关闭，如果关闭了那从外网连通内网的通道就无法维持。</strong></p>
<p>解决方法：使用 autossh来连接。<br>反向代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autossh -M 9999 ssh -fCNR  跳板机1:5555:localhost:22  localhost</span><br></pre></td></tr></table></figure>
<p>-M 参数，用来监听ssh的状态，如果端口之后，从9999端口发送信息，进而进行重新连接。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>代理</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>netbox 在 Ubuntu20 系统上的安装记录</title>
    <url>/posts/6909405a.html</url>
    <content><![CDATA[<h2 id="NetBox-安装"><a href="#NetBox-安装" class="headerlink" title="NetBox 安装"></a>NetBox 安装</h2><p>系统环境：Ubuntu20.04 LTS</p>
<span id="more"></span>

<h3 id="安装-PGSQL"><a href="#安装-PGSQL" class="headerlink" title="安装 PGSQL"></a>安装 PGSQL</h3><ol>
<li>安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y postgresql</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看版本信息：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdai@xdai-vm:~$ psql -V</span><br><span class="line">psql (PostgreSQL) 12.9 (Ubuntu 12.9-0ubuntu0.20.04.1)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动数据库并设置为开机自启</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start postgresql</span><br><span class="line">sudo systemctl enable postgresql</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 进入数据库</span><br><span class="line">sudo <span class="operator">-</span>u postgres psql</span><br><span class="line"># 建库授权</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE netbox;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> netbox <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;VIP@xdai.vip&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE netbox <span class="keyword">TO</span> netbox;</span><br><span class="line"># 退出</span><br><span class="line">\q</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>验证数据库状态</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xdai@xdai-vm:~$  psql --username netbox --password --host localhost netbox</span><br><span class="line">Password: $&#123;这里输入上一步的密码&#125;</span><br><span class="line">psql (12.9 (Ubuntu 12.9-0ubuntu0.20.04.1))</span><br><span class="line">SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">netbox=&gt; \conninfo</span><br><span class="line">You are connected to database &quot;netbox&quot; as user &quot;netbox&quot; on host &quot;localhost&quot; (address &quot;127.0.0.1&quot;) at port &quot;5432&quot;.</span><br><span class="line">SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)</span><br><span class="line">netbox=&gt; \q</span><br><span class="line">xdai@xdai-vm:~$ </span><br></pre></td></tr></table></figure>

<p>可以看到数据库已经可以连接，信息为：<code>host &quot;localhost&quot; (address &quot;127.0.0.1&quot;) at port &quot;5432&quot;</code></p>
<h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><ol>
<li>安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y redis-server</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看版本信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdai@xdai-vm:~$ redis-server -v</span><br><span class="line">Redis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.2.1 bits=64 build=636cde3b5c7a3923</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证服务状态</li>
</ol>
<p>使用 <code>redis-cli ping</code> 来验证，返回 <code>PONG</code> 表示正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xdai@xdai-vm:~$ redis-cli ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<h3 id="安装-Netbox"><a href="#安装-Netbox" class="headerlink" title="安装 Netbox"></a>安装 Netbox</h3><h4 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h4><p>NetBox v3.0 开始最低支持 Python3.7，从 NetBox v3.2 开始将最低支持 Python3.8。</p>
<p>最新的 Ubuntu20.04 默认的 Python 版本为 3.8.10，但是仍缺少一些相关的依赖包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">安装 Python 相关依赖包</span></span><br><span class="line">sudo apt install -y python3 python3-pip python3-venv python3-dev build-essential libxml2-dev libxslt1-dev libffi-dev libpq-dev libssl-dev zlib1g-dev</span><br></pre></td></tr></table></figure>

<h4 id="下载-NetBox"><a href="#下载-NetBox" class="headerlink" title="下载 NetBox"></a>下载 NetBox</h4><p>可以通过 wget 或者 git 来下载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /opt/netbox/</span><br><span class="line">cd /opt/netbox/</span><br><span class="line">sudo git clone -b master --depth 1 https://github.com/netbox-community/netbox.git .</span><br><span class="line"></span><br><span class="line">Cloning into &#x27;.&#x27;...</span><br><span class="line">remote: Enumerating objects: 1173, done.</span><br><span class="line">remote: Counting objects: 100% (1173/1173), done.</span><br><span class="line">remote: Compressing objects: 100% (1097/1097), done.</span><br><span class="line">remote: Total 1173 (delta 210), reused 427 (delta 49), pack-reused 0</span><br><span class="line">Receiving objects: 100% (1173/1173), 4.31 MiB | 1.90 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (210/210), done.</span><br><span class="line">xdai@xdai-vm:/opt/netbox$ </span><br></pre></td></tr></table></figure>

<h4 id="为-NetBox-创建系统用户"><a href="#为-NetBox-创建系统用户" class="headerlink" title="为 NetBox 创建系统用户"></a>为 NetBox 创建系统用户</h4><p>创建系统用户的目的是为了将 WSGI 和 HTTP 服务配置为在这个帐户下运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建系统用户</span><br><span class="line">xdai@xdai-vm:/opt/netbox$ sudo adduser --system --group netbox</span><br><span class="line">sudo chown --recursive netbox /opt/netbox/netbox/media/Adding system user `netbox&#x27; (UID 115) ...</span><br><span class="line">Adding new group `netbox&#x27; (GID 120) ...</span><br><span class="line">Adding new user `netbox&#x27; (UID 115) with group `netbox&#x27; ...</span><br><span class="line">Creating home directory `/home/netbox&#x27; ...</span><br><span class="line"># 将 /opt/netbox/netbox/media/ 目录设置成 netbox 用户权限，这个文件夹下是前端页面</span><br><span class="line">xdai@xdai-vm:/opt/netbox$ sudo chown --recursive netbox /opt/netbox/netbox/media/</span><br><span class="line">xdai@xdai-vm:/opt/netbox$ </span><br></pre></td></tr></table></figure>

<h4 id="修改-NetBox-配置文件"><a href="#修改-NetBox-配置文件" class="headerlink" title="修改 NetBox 配置文件"></a>修改 NetBox 配置文件</h4><p>复制一份默认的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/netbox/netbox/netbox/</span><br><span class="line">sudo cp configuration.example.py configuration.py</span><br></pre></td></tr></table></figure>

<p>先生成一个密钥，用来维护 HTTP 用户会话状态，配置文件里面要用到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xdai@xdai-vm:/opt/netbox/netbox/netbox$ python3 ../generate_secret_key.py </span><br><span class="line">lKCyYG-q5qW0&amp;3zK=*U9%Ga@yOzZOwEIz9JhrlIIdd*CXE0b#z</span><br></pre></td></tr></table></figure>

<p>第一次使用的话，最小话的配置文件需要下面几个参数就可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xdai@xdai-vm:/opt/netbox/netbox/netbox$ sudo vim  configuration.py</span><br></pre></td></tr></table></figure>

<ol>
<li>第 11 行：允许谁可以访问前端页面</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ALLOWED_HOSTS</span> = [<span class="string">&#x27;*&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第 15~22 行：数据库，修改用户名和密码为之前设置的信息</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">DATABASE</span> = &#123; </span><br><span class="line">    &#x27;NAME&#x27;: &#x27;netbox&#x27;,</span><br><span class="line">    &#x27;USER&#x27;: &#x27;netbox&#x27;, <span class="comment"># 修改用户名</span></span><br><span class="line">    &#x27;PASSWORD&#x27;: &#x27;VIP@xdai.vip&#x27;,  <span class="comment"># 修改密码</span></span><br><span class="line">    &#x27;HOST&#x27;: &#x27;localhost&#x27;,</span><br><span class="line">    &#x27;PORT&#x27;: &#x27;&#x27;,</span><br><span class="line">    &#x27;CONN_MAX_AGE&#x27;: 300,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>redis 使用默认配置即可</p>
</li>
<li><p>第 60 行：SECRET_KEY</p>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">SECRET_KEY</span> = <span class="string">&#x27;lKCyYG-q5qW0&amp;3zK=*U9%Ga@yOzZOwEIz9JhrlIIdd*CXE0b#z&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>（可选配置）第 203 行：修改时区，默认是 UTC，需要改为中国标准时间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TIME_ZONE = &#x27;Asia/Shanghai&#x27;</span><br></pre></td></tr></table></figure>

<p>修改完配置文件之后，保存退出。</p>
<h4 id="安装其他可选的组件"><a href="#安装其他可选的组件" class="headerlink" title="安装其他可选的组件"></a>安装其他可选的组件</h4><p>NetBox 还支持一些可选的软件包。如果需要，第一次安装的时候这些包必须在 NetBox 根目录的 local_requirements.txt 中写上，这样 NetBox 会自动进行安装；或者也可以后期按需手动安装。</p>
<p>官方提供了两个组件：</p>
<ul>
<li>napalm 用于从网络设备获取实时数据</li>
<li>django-storages 用于连接远程文件存储（默认是使用本地存储）</li>
</ul>
<p>这里我只需要 napalm 来对接华三的网络设备，所以需要安装两个包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo &#x27;napalm&#x27; &gt;&gt; /opt/netbox/local_requirements.txt&quot;</span><br><span class="line">sudo sh -c &quot;echo &#x27;napalm-h3c-comware&#x27; &gt;&gt; /opt/netbox/local_requirements.txt&quot;</span><br></pre></td></tr></table></figure>

<h4 id="运行升级脚本"><a href="#运行升级脚本" class="headerlink" title="运行升级脚本"></a>运行升级脚本</h4><p>运行自带的 <code>upgrade.sh</code> 来完成以下操作：</p>
<ul>
<li><p>创建 Python 虚拟环境 </p>
</li>
<li><p>安装所有必需的 Python 包（根目录下 requirements.txt 和 local_requirements.txt 包含的软件）</p>
</li>
<li><p>运行 Django 的数据库迁移</p>
</li>
<li><p>在本地生成离线文档</p>
</li>
<li><p>在磁盘上聚合静态资源文件</p>
</li>
</ul>
<p>默认 pip 安装会很慢，参考<a href="https://blog.csdn.net/q965844841qq/article/details/105547362">pip 下载加速</a>来设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /opt/netbox/upgrade.sh</span><br></pre></td></tr></table></figure>

<p>安装完成之后会有如下提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Upgrade complete! Don&#x27;t forget to restart the NetBox services:</span><br><span class="line">  &gt; sudo systemctl restart netbox netbox-rq</span><br></pre></td></tr></table></figure>

<p>如果是升级 NetBox，需要重启一下服务，因为本次是新安装，所以不用关注，继续往下进行。</p>
<h4 id="创建-django-管理员用户"><a href="#创建-django-管理员用户" class="headerlink" title="创建 django 管理员用户"></a>创建 django 管理员用户</h4><p>NetBox 没有默认用户，所以需要创建一个超级用户（管理帐户）才能登录 NetBox。</p>
<p>进入到升级脚本创建的 Python 虚拟环境，之后命令行前面都会有个 <code>(venv)</code> 的提示符，表示当前在虚拟环境中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /opt/netbox/venv/bin/activate</span><br></pre></td></tr></table></figure>

<p>创建用户，邮箱可以留空不填。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(venv) xdai@xdai-vm:/opt/netbox/netbox/netbox$ cd /opt/netbox/netbox</span><br><span class="line">(venv) xdai@xdai-vm:/opt/netbox/netbox$ python3 manage.py createsuperuser</span><br><span class="line">Username (leave blank to use &#x27;xdai&#x27;): admin</span><br><span class="line">Email address:       </span><br><span class="line">Password: </span><br><span class="line">Password (again): </span><br><span class="line">Superuser created successfully.</span><br><span class="line">(venv) xdai@xdai-vm:/opt/netbox/netbox$ </span><br></pre></td></tr></table></figure>

<h4 id="设置自动清理任务"><a href="#设置自动清理任务" class="headerlink" title="设置自动清理任务"></a>设置自动清理任务</h4><p>NetBox 包含了 <code>housekeeping</code> 管理命令用来处理一些定期清理任务，例如清除旧会话和过期的更改记录。</p>
<p>尽管可以手动运行此命令来进行清理操作，不过还是建议使用系统的 cron 守护程序或类似其他的定时任务来运行清理任务。</p>
<p>使用以下命令来为脚本创建一个 cron 任务，<strong>注意脚本的路径，如果 NetBox 安装在其他路径，需要使用正确的绝对路径</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /opt/netbox/contrib/netbox-housekeeping.sh /etc/cron.daily/netbox-housekeeping</span><br></pre></td></tr></table></figure>

<h4 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h4><p>到这里 NetBox 已经安装的差不多了，可以使用 django 的命令来测试运行一下，没有问题后再使用 WSGI 来启动服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 manage.py runserver 0.0.0.0:8000 --insecure</span><br></pre></td></tr></table></figure>

<p>然后使用浏览器访问这个服务器的 <code>8000</code> 端口测试一下！</p>
<p>如果服务已经正常启动，但是无法访问的话，请自行检查系统的防火墙或者 iptables 设置，放行 8000 端口。</p>
<p>可以正常登录~</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/image-20220209215651236.png" alt="image-20220209215651236"></p>
<p>一般开发的时候使用这种方式来测试服务的运行情况，实际部署时，需要结合 WSGI 来运行服务，必要时还需要配置 nginx 来使用。</p>
<p>先 crtl + C 停止服务，进行下一步操作。</p>
<h4 id="使用-Gunicorn-运行-Django-服务"><a href="#使用-Gunicorn-运行-Django-服务" class="headerlink" title="使用 Gunicorn 运行 Django 服务"></a>使用 Gunicorn 运行 Django 服务</h4><p> NetBox 作为 HTTP 服务器后面的 WSGI 应用程序运行。 NetBox 默认使用的是 gunicorn，<strong>但是它不能处理静态文件，还要结合 nginx 才能正常使用</strong>，而 uwsgi 支持静态文件的映射。这里先使用官方提供的 gunicorn 来启动服务。</p>
<p>复制一份默认的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp /opt/netbox/contrib/gunicorn.py /opt/netbox/gunicorn.py</span><br></pre></td></tr></table></figure>

<p>使用默认的配置文件即可，如果修改配置的话，后面 nginx 的配置需要同步修改。</p>
<h4 id="启动-NetBox-服务"><a href="#启动-NetBox-服务" class="headerlink" title="启动 NetBox 服务"></a>启动 NetBox 服务</h4><p>NetBox 默认为我们写好了 systemd 的服务文件，复制到系统目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp -v /opt/netbox/contrib/*.service /etc/systemd/system/</span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p><strong>这里还要注意：如果 NetBox 安装在其他路径，需要在 service 文件中将几个服务修改为你安装的绝对路径</strong>，或者也可以使用软连接，将你的安装路径链接到<code>/opt/netbox/</code> 目录下，参考以下命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s Your/NetBox/Root/Path /opt/netbox</span><br></pre></td></tr></table></figure>

<p>复制完 service 文件之后，启动服务并设置为开机自启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start netbox netbox-rq</span><br><span class="line">sudo systemctl enable netbox netbox-rq</span><br></pre></td></tr></table></figure>

<p>查看服务状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status netbox.service</span><br></pre></td></tr></table></figure>

<h4 id="使用-nginx-来处理静态文件"><a href="#使用-nginx-来处理静态文件" class="headerlink" title="使用 nginx 来处理静态文件"></a>使用 nginx 来处理静态文件</h4><p>上一步已经启动了 web 服务，但是访问时会出现 <code>Static Media Failure</code> 的错误信息，就是因为 gunicorn 不能处理静态文件的映射，需要借助其他方式来实现（uwsgi 支持）。</p>
<p>安装 nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y nginx</span><br></pre></td></tr></table></figure>

<p>编写配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp /opt/netbox/contrib/nginx.conf /etc/nginx/sites-available/netbox</span><br><span class="line"># 使用软连接覆盖默认配置</span><br><span class="line">sudo rm /etc/nginx/sites-enabled/default</span><br><span class="line">sudo ln -s /etc/nginx/sites-available/netbox /etc/nginx/sites-enabled/netbox</span><br></pre></td></tr></table></figure>

<p>不想使用 https 的话，可以修改 NetBox 提供的默认 nginx 配置文件：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sudo vim /etc/nginx/sites-available/netbox</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 监听 80 端口</span></span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">80</span> ipv6only=<span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">25m</span>;</span><br><span class="line">    <span class="comment"># 这里做了 静态文件的映射</span></span><br><span class="line">    <span class="section">location</span> /static/ &#123;</span><br><span class="line">        <span class="attribute">alias</span> /opt/netbox/netbox/static/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 将 80 端口的访问请求转发到 gunicorn 的服务上</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8001;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Host <span class="variable">$http_host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启 nginx 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>

<p>使用 80 端口来访问：</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/image-20220209224251052.png" alt="image-20220209224251052"></p>
<p>至此，NetBox 搭建完成！</p>
<h3 id="使用-uwsgi-来启动-NetBox-服务"><a href="#使用-uwsgi-来启动-NetBox-服务" class="headerlink" title="使用 uwsgi 来启动 NetBox 服务"></a>使用 uwsgi 来启动 NetBox 服务</h3><p>NetBox 默认使用 gunicorn 作为 WSGI 来提供服务，<strong>但是它不能处理静态文件，还要结合 nginx 才能正常使用</strong>，而 uwsgi 支持静态文件的映射。这里给出使用方法。</p>
<h4 id="安装-uwsgi"><a href="#安装-uwsgi" class="headerlink" title="安装 uwsgi"></a>安装 uwsgi</h4><p>进入到升级脚本创建的 Python 虚拟环境，之后命令行前面都会有个 <code>(venv)</code> 的提示符，表示当前在虚拟环境中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /opt/netbox/venv/bin/activate</span><br><span class="line">sudo /opt/netbox/venv/bin/pip3 install uwsgi</span><br></pre></td></tr></table></figure>

<h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>仅供参考，勿用于生产。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sudo vim /opt/netbox/uwsgi.ini</span><br><span class="line">[uwsgi]</span><br><span class="line"># 程序根目录，对于 django 就是 manage.py 所在目录</span><br><span class="line">chdir=/opt/netbox/netbox</span><br><span class="line"># python虚拟环境目录</span><br><span class="line">home=/opt/netbox/venv</span><br><span class="line"># 模块文件名，加载一个 WSGI 模块</span><br><span class="line">module=netbox.wsgi:application</span><br><span class="line"># 启用主进程</span><br><span class="line">master=true</span><br><span class="line"># 进程数</span><br><span class="line">process=4</span><br><span class="line"># 绑定地址</span><br><span class="line">http=0.0.0.0:8080</span><br><span class="line"># 启动uwsgi的用户名和用户组</span><br><span class="line">uid=netbox</span><br><span class="line">gid=netbox</span><br><span class="line"># sock文件路径</span><br><span class="line">socket=/tmp/netbox.sock</span><br><span class="line"># pid文件目路径</span><br><span class="line">pidfile=/tmp/netbox.pid</span><br><span class="line"># log文件路径</span><br><span class="line">daemonize=/tmp/netbox.log</span><br><span class="line"># 当服务停止的时候自动移除 socket 和 pid 文件</span><br><span class="line">vacuum=true</span><br><span class="line"># 启用线程</span><br><span class="line">enable-threads=true</span><br><span class="line"># 设置缓冲</span><br><span class="line">post-buffering=4096</span><br><span class="line"># 静态文件映射</span><br><span class="line">static-map=/static=/opt/netbox/netbox/static</span><br></pre></td></tr></table></figure>

<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /opt/netbox/venv/bin/uwsgi --ini /opt/netbox/uwsgi.ini</span><br></pre></td></tr></table></figure>

<p>然后就可以通过 8080 端口来访问服务，而且不会报无法找到静态文件的错误。</p>
<p>但是生产环境中还是建议使用专门的 webserver 例如 nginx、apache 来和 WSGI 进行对接。</p>
<p><a href="https://www.zhihu.com/question/30560394">使用了Gunicorn或者uWSGI,为什么还需要Nginx？</a></p>
<h4 id="编辑-service-文件"><a href="#编辑-service-文件" class="headerlink" title="编辑 service 文件"></a>编辑 service 文件</h4><p>如果想要使用 systemd 来启动 uwsgi 服务，需要编辑一个 service 文件，可以参考<a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/Systemd.html">官方文档</a>。</p>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>netbox</tag>
      </tags>
  </entry>
  <entry>
    <title>netbox 使用问题记录</title>
    <url>/posts/101f7898.html</url>
    <content><![CDATA[<h3 id="Netbox-CSV-导出中文乱码"><a href="#Netbox-CSV-导出中文乱码" class="headerlink" title="Netbox CSV 导出中文乱码"></a>Netbox CSV 导出中文乱码</h3><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改文件：<code>./netbox/netbox/netbox/views/generic.py</code></p>
<p>修改内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 在 import 语句后面添加一个新的类，重写父类 `TableExport`</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TableExport2</span>(<span class="title class_ inherited__">TableExport</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">response</span>(<span class="params">self, filename=<span class="literal">None</span></span>):</span><br><span class="line">        response = HttpResponse(content_type=<span class="string">&quot;text/csv; charset=utf-8-sig&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            response[<span class="string">&quot;Content-Disposition&quot;</span>] = <span class="string">&#x27;attachment; filename=&quot;&#123;&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(filename)</span><br><span class="line">        response.write(self.export())</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 修改 export_table 方法（大约在文件 200 行左右）让其使用重写的类来实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectListView</span>(ObjectPermissionRequiredMixin, View):</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">export_table</span>(<span class="params">self, table, columns=<span class="literal">None</span></span>):</span><br><span class="line">        ...</span><br><span class="line">        exporter = TableExport2(</span><br><span class="line">            export_format=TableExport.CSV,</span><br><span class="line">            table=table,</span><br><span class="line">            exclude_columns=exclude_columns</span><br><span class="line">        )</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>修改文件后，重启 netbox 服务。如果是容器部署，重启 <code>netbox-docker_netbox_1</code> 容器（暴露端口的那个容器）。</p>
<h4 id="解决过程记录"><a href="#解决过程记录" class="headerlink" title="解决过程记录"></a>解决过程记录</h4><span id="more"></span>

<p>Django 导出 csv 文件乱码，一般是编码格式的问题，可以参考：<a href="https://blog.csdn.net/q965844841qq/article/details/119065251">解决 Django 导出 csv 乱码问题</a>，根据这篇文章，思路就是只需要修改 <code>HttpResponse</code> 的 <code>charset</code> 就行了。</p>
<p>在 url.py 中搜索 export 相关字样，发现没有相关路由。</p>
<p>在从 export 的 html 中可以看到，它是直接把 export 传给了后端。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-item&quot;</span> <span class="attr">href</span>=<span class="string">&quot;?&#123;% if url_params %&#125;&#123;&#123; url_params.urlencode &#125;&#125;&amp;&#123;% endif %&#125;export&quot;</span>&gt;</span>All </span><br></pre></td></tr></table></figure>

<p>后端处理的时候肯定是需要解析这个字段的，在 views.py 中搜索，发现定义了 export 的按钮，是继承自 <code>generic.ObjectListView</code> 的，所以这个方法应该是定义在 <code>generic.ObjectListView</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ConsolePortListView(generic.ObjectListView):</span><br><span class="line">    queryset = ConsolePort.objects.all()</span><br><span class="line">    filterset = filtersets.ConsolePortFilterSet</span><br><span class="line">    filterset_form = forms.ConsolePortFilterForm</span><br><span class="line">    table = tables.ConsolePortTable</span><br><span class="line">    action_buttons = (&#x27;import&#x27;, &#x27;export&#x27;)</span><br></pre></td></tr></table></figure>

<p>在 generic 中找到如下方法，证明前端 export 传过来的参数是由 <code>export_table</code> 来处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   ...</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;export&#x27;</span> <span class="keyword">in</span> request.GET:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Export the current table view</span></span><br><span class="line">        <span class="keyword">if</span> request.GET[<span class="string">&#x27;export&#x27;</span>] == <span class="string">&#x27;table&#x27;</span>:</span><br><span class="line">            table = self.get_table(request, permissions)</span><br><span class="line">            columns = [name <span class="keyword">for</span> name, _ <span class="keyword">in</span> table.selected_columns]</span><br><span class="line">            <span class="keyword">return</span> self.export_table(table, columns)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">export_table</span>(<span class="params">self, table, columns=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Export all table data in CSV format.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param table: The Table instance to export</span></span><br><span class="line"><span class="string">    :param columns: A list of specific columns to include. If not specified, all columns will be exported.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    exclude_columns = &#123;<span class="string">&#x27;pk&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> columns:</span><br><span class="line">        all_columns = [col_name <span class="keyword">for</span> col_name, _ <span class="keyword">in</span> table.selected_columns + table.available_columns]</span><br><span class="line">        exclude_columns.update(&#123;</span><br><span class="line">            col <span class="keyword">for</span> col <span class="keyword">in</span> all_columns <span class="keyword">if</span> col <span class="keyword">not</span> <span class="keyword">in</span> columns</span><br><span class="line">        &#125;)</span><br><span class="line">    exporter = TableExport(</span><br><span class="line">        export_format=TableExport.CSV,</span><br><span class="line">        table=table,</span><br><span class="line">        exclude_columns=exclude_columns</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> exporter.response(</span><br><span class="line">        filename=<span class="string">f&#x27;netbox_<span class="subst">&#123;self.queryset.model._meta.verbose_name_plural&#125;</span>.csv&#x27;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>



<p>可以看到这个方法返回了一个 <code>response</code> 对象，修改这个对象的 charset：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def export_table(self, table, columns=None):</span><br><span class="line">    ...</span><br><span class="line">    response = exporter.response(</span><br><span class="line">        filename=f&#x27;netbox_&#123;self.queryset.model._meta.verbose_name_plural&#125;.csv&#x27;</span><br><span class="line">    )</span><br><span class="line">    response.charset = &quot;utf-8-sig&quot;</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<p>修改之后，发现前端页面中，确实增加了 charset 且值正确，但是导出的文件仍为乱码。</p>
<p>分析 <code>exporter.response</code> 这个对象——来自于 <code>django-tables2</code> 插件，初始化 <code>TableExport</code> 时里面使用了 <code>export_format=TableExport.CSV</code>，这里指定了 csv 格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exporter = TableExport(</span><br><span class="line">    export_format=TableExport.CSV,</span><br><span class="line">    table=table,</span><br><span class="line">    exclude_columns=exclude_columns</span><br><span class="line">)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>之后调用了这个类的 <code>response</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">response</span>(<span class="params">self, filename=<span class="literal">None</span></span>):</span><br><span class="line">    response = HttpResponse(content_type=self.content_type())</span><br><span class="line">    <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response[<span class="string">&quot;Content-Disposition&quot;</span>] = <span class="string">&#x27;attachment; filename=&quot;&#123;&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(filename)</span><br><span class="line"></span><br><span class="line">    response.write(self.export())</span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>通过分析这个类，发现这里 self.content_type() 调用的是传入的 self.format，即 <code>export_format=TableExport.CSV</code> 值为 ‘csv’。<br>由于这个值会被 <code>tablib</code> 这个库调用（类中的 self.export()方法调用），所以不能重写这个字段来实现。</p>
<p><code>response</code> 方法也不支持传参，所以这里的 csv 编码格式是写死的，即：<code>&quot;text/csv; charset=utf-8&quot;</code></p>
<p>而且 <code>response.write(self.export())</code> 写入对象时已经是 utf-8 了，写入完成之后再修改编码也没有任何意义。</p>
<p>最后思考的结果是：在 netbox 的 <code>generic.py</code> 中重写 <code>def response(self, filename=None):</code> 方法，固定其编码为 <code>utf-8-sig</code>。</p>
<p>因为 netbox 的导出<strong>只使用了 csv 格式</strong>，所以把编码格式固定不会对 netbox 运行造成影响，只是修改了导出的格式。</p>
<p>最终解决方法见上方。</p>
<h3 id="Netbox-时区不对"><a href="#Netbox-时区不对" class="headerlink" title="Netbox 时区不对"></a>Netbox 时区不对</h3><p>修改文件： <code>./netbox-docker/configuration/extra.py</code></p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/cfb24c60cdf2fa4a2edca8df1f59bbe.png"></p>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>netbox</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 docker 安装部署 Zabbix5.0 并进行优化</title>
    <url>/posts/b9dcfcd4.html</url>
    <content><![CDATA[<h2 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h2><p><img data-src="http://oss.xdai.vip/md-note/imgs/zabbix_deploy.svg" alt="zabbix_deploy"></p>
<p>网络环境不宜说太多：四朵独立的云，中间通过防火墙隔离，需要搭建一套监控系统对全网的网络设备进行监控，通过 Zabbix Server + Proxy 分布式部署方式来实现。</p>
<h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>截止目前，Zabbix 已经发布了 6.0 pre-release，稳定版也已经来到了 5.4。</p>
<p>在生产环境部署时，为稳定起见，建议使用 <strong>Long-term support</strong> (<strong>LTS</strong>) 版本。</p>
<p>本次部署选用的是 <a href="https://www.zabbix.com/cn/rn/rn5.0.19">Zabbix 5.0 LTS</a> 版本。</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/image-20211229090438953.png" alt="版本及软件依赖"></p>
<span id="more"></span>

<p>存储空间要求：</p>
<ul>
<li>历史数据：(监控项&#x2F;刷新周期) * days * 24 * 3600 * 单条数据大小(约为50B)</li>
<li>趋势数据：(监控项&#x2F;3600) * days * 24 * 3600 * 单条大小(约128B)</li>
<li>事件数据：每秒事件数 * days * 24 * 3600 * 单条大小(约130B)</li>
</ul>
<p><a href="https://www.zabbix.com/documentation/5.0/zh/manual/installation/requirements">硬件性能</a>：</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Platform</th>
<th align="left">CPU&#x2F;Memory</th>
<th align="left">Database</th>
<th align="left">Monitored hosts</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>Small</em></td>
<td align="left">CentOS</td>
<td align="left">Virtual Appliance</td>
<td align="left">MySQL InnoDB</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left"><em>Medium</em></td>
<td align="left">CentOS</td>
<td align="left">2 CPU cores&#x2F;2GB</td>
<td align="left">MySQL InnoDB</td>
<td align="left">500</td>
</tr>
<tr>
<td align="left"><em>Large</em></td>
<td align="left">RedHat Enterprise Linux</td>
<td align="left">4 CPU cores&#x2F;8GB</td>
<td align="left">RAID10 MySQL InnoDB or PostgreSQL</td>
<td align="left">&gt;1000</td>
</tr>
<tr>
<td align="left"><em>Very large</em></td>
<td align="left">RedHat Enterprise Linux</td>
<td align="left">8 CPU cores&#x2F;16GB</td>
<td align="left">Fast RAID10 MySQL InnoDB or PostgreSQL</td>
<td align="left">&gt;10000</td>
</tr>
</tbody></table>
<p>Zabbix 硬件性能取决于监控项（主动）的数量和更新间隔，数量越多需要的性能就越高。</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ol>
<li><p>安装 Docker，可参考阿里云镜像站：<a href="https://developer.aliyun.com/mirror/docker-ce">https://developer.aliyun.com/mirror/docker-ce</a>。</p>
</li>
<li><p>Docker 镜像加速（拉取镜像时默认从 Docker hub 进行拉取，国内网络速度较慢，可更换为国内源提高访问速度）：</p>
</li>
</ol>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p> 使用 <code>docker info</code> 命令查看国内镜像配置是否生效：</p>
<img data-src="http://oss.xdai.vip/md-note/imgs/image-20211228232224039.png" alt="image-20211228232224039" style="zoom:67%;" />

<p>本文使用的 Docker 版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --version</span><br><span class="line">Docker version 20.10.12, build e91ed57</span><br></pre></td></tr></table></figure>



<h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p>根据 Zabbix 架构图，需要拉取如下几个镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull zabbix/zabbix-web-nginx-mysql:5.0-centos-latest</span><br><span class="line">docker pull zabbix/zabbix-server-mysql:5.0-centos-latest</span><br><span class="line">docker pull zabbix/zabbix-proxy-mysql:5.0-centos-latest</span><br><span class="line">docker pull zabbix/zabbix-snmptraps:5.0-centos-latest</span><br><span class="line">docker pull zabbix/zabbix-agent:5.0-centos-latest</span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<p>镜像拉取完成后，可以通过 <code>docker images</code> 查看镜像列表。</p>
<img data-src="http://oss.xdai.vip/md-note/imgs/image-20211228232758646.png" alt="image-20211228232758646" style="zoom:67%;" />



<h2 id="运行-Demo"><a href="#运行-Demo" class="headerlink" title="运行 Demo"></a>运行 Demo</h2><p>通过 Docker 搭建一个最小化版本的 Zabbix，如果想体验基本功能，安装 MySQL、Server、Web、Agent 即可，本例中也添加了 Proxy，运行如下命令，即可快速搭建完成一个 Zabbix 监控平台。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">运行本地数据库</span></span><br><span class="line">docker run --name zbx5-mysql -d \</span><br><span class="line">    --network=host \</span><br><span class="line">    -e MYSQL_DATABASE=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=&quot;root&quot; \</span><br><span class="line">    --restart unless-stopped mysql:5.7 \</span><br><span class="line">    --character-set-server=utf8 --collation-server=utf8_bin \</span><br><span class="line">    --default-authentication-plugin=mysql_native_password</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动 server 后端</span></span><br><span class="line">docker run --name zbx5-server-mysql -d \</span><br><span class="line">    -e DB_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e MYSQL_DATABASE=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=&quot;root&quot; \</span><br><span class="line">    --network=host \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">	zabbix/zabbix-server-mysql:5.0-centos-latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动 proxy，由于默认 Server 和 Proxy 端口都为 10051，避免冲突，这里使用 11111</span></span><br><span class="line">docker run --name zbx5-proxy-mysql -d \</span><br><span class="line">    -e DB_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e ZBX_LISTENPORT=11111 \</span><br><span class="line">    -e ZBX_HOSTNAME=&quot;zabbix-proxy-test1&quot; \</span><br><span class="line">    -e ZBX_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">	-e MYSQL_ROOT_PASSWORD=&quot;root&quot; \</span><br><span class="line">    --network=host \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">	zabbix/zabbix-proxy-mysql:5.0-centos-latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动前端页面，默认端口是 8080</span></span><br><span class="line">docker run --name zbx5-web-nginx-mysql -d \</span><br><span class="line">    -e ZBX_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e DB_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e MYSQL_DATABASE=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=&quot;root&quot; \</span><br><span class="line">    --network=host \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">	zabbix/zabbix-web-nginx-mysql:5.0-centos-latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动 Agent</span></span><br><span class="line">docker run --name zbx5-agent -d \</span><br><span class="line">    -e ZBX_HOSTNAME=&quot;local-agent&quot; \</span><br><span class="line">    -e ZBX_SERVER_HOST=&quot;127.0.0.1&quot;  \</span><br><span class="line">    --network=host \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    zabbix/zabbix-agent:5.0-centos-latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动完成后，通过 <code>docker ps</code> 查看所有容器已经正在运行，之后通过访问 <code>http://ip:8080</code> 即可访问！</p>
<p>默认用户名&#x2F;密码是：<code>Admin/zabbix</code></p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/image-20211229203922391.png" alt="image-20211229203922391"></p>
<h2 id="生产环境部署"><a href="#生产环境部署" class="headerlink" title="生产环境部署"></a>生产环境部署</h2><h3 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h3><p>默认情况下，容器的网卡都是经过 NAT 的，为了保证相关服务可以正常被外部访问，容器都使用主机模式的网络（<code>--network=host</code>），即端口连接、端口监听都使用物理机的地址。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>如果已经有现成的数据库，则不用使用本地数据库，直接配置指定远程数据库即可。</p>
<p>Zabbix 支持 MySQL、PostgreSQL 等，使用不同后端数据库，需要选择对应的 Zabbix 容器镜像。</p>
<p>以下为本地使用容器搭建 MySQL 示例（&#x3D;&#x3D;对上文 Demo 的解释&#x3D;&#x3D;）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zbx5-mysql -td \</span><br><span class="line">    --network=host \</span><br><span class="line">    -e MYSQL_DATABASE=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=&quot;root&quot; \</span><br><span class="line">    --restart unless-stopped mysql:5.7 \</span><br><span class="line">    --character-set-server=utf8 --collation-server=utf8_bin \</span><br><span class="line">    --default-authentication-plugin=mysql_native_password</span><br></pre></td></tr></table></figure>

<p>运行之后，一个本地数据库就搭建完成了，之后可以在 Linux 中使用 <code>docker exec -it zbx5-mysql mysql -proot</code> 来连接到本地数据库，其中 <code>MYSQL_DATABASE</code> 为新建的数据库，<code>MYSQL_ROOT_PASSWORD</code> 为数据库超级管理员 root 的密码<strong>（生产环境中请使用符合密码策略的强密码）</strong>。</p>
<img data-src="http://oss.xdai.vip/md-note/imgs/image-20211229002522793.png" alt="image-20211229002522793" style="zoom: 67%;" />




<h3 id="目录梳理"><a href="#目录梳理" class="headerlink" title="目录梳理"></a>目录梳理</h3><p>由于 Docker 不能完成数据持久化（删除容器后即丢失），并且多个容器之间存在共享目录或者文件的情况（例如：snmptraps 写 log，Server 读 log），所以需要把配置文件、数据文件等放在本地，并使用 volume 映射到 Docker 中读取。</p>
<p>Docker 挂载本地目录时，使用 <code>-v $hostDir:$containerDir</code> 参数。</p>
<p>每个容器镜像都给出了允许挂载的目录卷，可查阅 Docker Hub 上对应的镜像主页说明。<a href="https://hub.docker.com/u/zabbix">Zabbix docker 镜像主页</a>，<a href="https://hub.docker.com/_/mysql">MySQL docker 镜像主页</a>。</p>
<p>本次部署选择将所有组件需要的目录统一放到 <code>/opt/zabbix-volumes/</code> 下，分为：</p>
<ul>
<li>snmp：存放 snmp 相关的配置文件（snmptraps 需要）</li>
<li>zabbix-data：Zabbix Server&#x2F;Proxy 数据文件，如自定义脚本、模块、mib文件等</li>
<li>zabbix_proxy.conf.d：自定义 proxy 配置文件</li>
<li>zabbix_server.conf.d：自定义 server 配置文件</li>
</ul>
<p>以上目录可以直接从已有的 demo 环境中获取到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/zabbix-volumes/ &amp;&amp; cd /opt/zabbix-volumes/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">server 和 proxy 目录基本一致</span></span><br><span class="line">docker cp zbx5-server-mysql:/var/lib/zabbix/ ./zabbix-data/</span><br><span class="line">docker cp zbx5-snmptraps:/etc/snmp .</span><br><span class="line"><span class="meta"># </span><span class="language-bash">snmptrap 处理脚本（默认）</span></span><br><span class="line">docker cp zbx5-snmptraps:/usr/sbin/zabbix_trap_handler.sh ./snmp</span><br><span class="line">mkdir -p zabbix-data/alertscripts</span><br><span class="line">mkdir -p zabbix-data/externalscripts</span><br><span class="line">mkdir -p zabbix-data/export</span><br></pre></td></tr></table></figure>

<p>最后目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> # </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── snmp</span><br><span class="line">│   ├── snmpd.conf</span><br><span class="line">│   ├── snmptrapd.conf</span><br><span class="line">│   └── zabbix_trap_handler.sh</span><br><span class="line">├── zabbix-data</span><br><span class="line">│   ├── alertscripts</span><br><span class="line">│   ├── enc</span><br><span class="line">│   ├── export</span><br><span class="line">│   ├── externalscripts</span><br><span class="line">│   ├── mibs</span><br><span class="line">│   ├── modules</span><br><span class="line">│   ├── snmptraps</span><br><span class="line">│   ├── ssh_keys</span><br><span class="line">│   └── ssl</span><br><span class="line">│       ├── certs</span><br><span class="line">│       ├── keys</span><br><span class="line">│       └── ssl_ca</span><br><span class="line">├── zabbix_proxy.conf.d</span><br><span class="line">└── zabbix_server.conf.d</span><br><span class="line"></span><br><span class="line">16 directories, 3 files</span><br></pre></td></tr></table></figure>

<h3 id="参数-x2F-环境变量"><a href="#参数-x2F-环境变量" class="headerlink" title="参数&#x2F;环境变量"></a>参数&#x2F;环境变量</h3><p>在容器内服务运行的时候如果需要传递参数，可以使用 <code>-e</code> 选项来指定。如指定数据库的用户名：<code>docker run ... -e MYSQL_USER=&quot;zabbix&quot; ...</code>。</p>
<p>看容器支持的每个参数及其含义，可查阅 Docker Hub 上对应的镜像主页说明。<a href="https://hub.docker.com/u/zabbix">Zabbix docker 镜像主页</a>，<a href="https://hub.docker.com/_/mysql">MySQL docker 镜像主页</a>。</p>
<p>每个 Docker 镜像都支持若干自定义参数，如果不传参的话，使用的就是是默认参数，官方镜像支持配置文件中的全部参数。</p>
<p>使用 <code>-e</code> 传参后， docker 启动时会逐个进行写入，见下文图中 <code>** Updating &#39;/etc/zabbix/zabbix_server.conf&#39; parameter....</code>，最终会生成一份完整的配置文件。</p>
<p><strong>这样的话会有一个问题</strong>：官方的镜像支持了上百个参数，如果要对运行中的 Zabbix 容器进行参数调整，使用 <code>-e</code> 指定参数启动容器后，要想调整只能把容器删除后再重新启动新的容器，可维护性不高（个人理解，如有更好的思路进行交流~）。</p>
<p>通过查看配置文件，可以使用 <code>Include</code> 参数将其他文件或目录包含在 Server&#x2F;Proxy&#x2F;Agent 的配置中，实现自定义加载配置文件；这样只需要以最小化配置启动容器，自定义配置通过单独的文件加载，之后热加载或者重启容器即可使新的配置文件生效，也便于维护。</p>
<p>官方镜像中并未提供 <code>Include</code> 参数的配置及更新，所以需要在官方镜像基础上重新打包，使其支持 <code>Include</code> 参数。</p>
<h4 id="自定义-Zabbix-Server-镜像"><a href="#自定义-Zabbix-Server-镜像" class="headerlink" title="自定义 Zabbix Server 镜像"></a>自定义 Zabbix Server 镜像</h4><p>最小化运行 Zabbix Server 端，运行时需要指定数据库的地址（必选参数），以保证数据可以正常存取。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zbx5-server-mysql -t \</span><br><span class="line">    -e DB_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e MYSQL_DATABASE=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=&quot;root&quot; \</span><br><span class="line">    -e ZBX_ENABLE_SNMP_TRAPS=true \</span><br><span class="line">    --network=host \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    -d zabbix/zabbix-server-mysql:5.0-centos-latest</span><br></pre></td></tr></table></figure>

<p>运行完成之后，通过 <code>docker logs $&#123;docker_id&#125;</code> 可以看到运行日志，首先进行了数据库的初始化，之后写入配置文件，最后启动 Server 端。</p>
<p>如果是已有数据库已有数据表，则不会再次进行初始化。</p>
<img data-src="http://oss.xdai.vip/md-note/imgs/image-20211229015713693.png" alt="image-20211229015713693" style="zoom: 67%;" />

<p>运行成功后，将原始容器的启动脚本拷贝出来进行修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir docker-build/zbx_server -p</span><br><span class="line">docker cp zbx5-server-mysql:/usr/bin/docker-entrypoint.sh ./docker-build/zbx_server</span><br><span class="line">cd docker-build/zbx_server</span><br></pre></td></tr></table></figure>

<p>编辑原始启动文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim docker-entrypoint.sh</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">移动到 440 行左右，这里的配置就是调用函数更新配置，在这里添加需要的 `Include` 参数</span></span><br><span class="line">...</span><br><span class="line">    update_config_var $ZBX_CONFIG &quot;Include&quot; &quot;$&#123;ZBX_INCLUDE&#125;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img data-src="http://oss.xdai.vip/md-note/imgs/image-20211229112406476.png" alt="image-20211229112406476"></p>
<p>编辑 Dockerfile，制作新的镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> zabbix/zabbix-server-mysql:<span class="number">5.0</span>-centos-latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-entrypoint.sh /usr/bin/docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure>

<p><img data-src="http://oss.xdai.vip/md-note/imgs/image-20211229112709803.png" alt="image-20211229112709803"></p>
<p>重新打包镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">使用当前目录的 Dockerfile 创建镜像，新镜像标签为 xdai/zabbix-server-mysql:v1</span></span><br><span class="line">docker build -t xdai/zabbix-server-mysql:v1 .</span><br></pre></td></tr></table></figure>

<p><img data-src="http://oss.xdai.vip/md-note/imgs/image-20211229113707531.png" alt="image-20211229113707531"></p>
<p>之后使用 <code>v1</code> 这个版本的镜像启动时，就可以支持 <code>Include</code> 参数了。</p>
<h4 id="自定义-Zabbix-Proxy-镜像"><a href="#自定义-Zabbix-Proxy-镜像" class="headerlink" title="自定义 Zabbix Proxy 镜像"></a>自定义 Zabbix Proxy 镜像</h4><p>原理同上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动 Proxy 容器，因为测试环境 Proxy 和 Server 在同一台机器上启动，端口无法重用，所以指定监听端口为 11111</span></span><br><span class="line">docker run --name zbx5-proxy-mysql -t \</span><br><span class="line">    -e DB_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e ZBX_LISTENPORT=11111 \</span><br><span class="line">    -e ZBX_HOSTNAME=&quot;zabbix-proxy-test1&quot; \</span><br><span class="line">    -e ZBX_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">	-e MYSQL_ROOT_PASSWORD=&quot;root&quot; \</span><br><span class="line">    --network=host \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    -d zabbix/zabbix-proxy-mysql:5.0-centos-latest</span><br></pre></td></tr></table></figure>

<p>运行成功后，将原始容器的启动脚本拷贝出来进行修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir docker-build/zbx_proxy -p</span><br><span class="line">docker cp zbx5-proxy-mysql:/usr/bin/docker-entrypoint.sh ./docker-build/zbx_proxy</span><br><span class="line">cd docker-build/zbx_proxy</span><br></pre></td></tr></table></figure>

<p>编辑原始启动文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim docker-entrypoint.sh</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">移动到 440 行左右，这里的配置就是调用函数更新配置，在这里添加需要的 `Include` 参数</span></span><br><span class="line">...</span><br><span class="line">    update_config_var $ZBX_CONFIG &quot;Include&quot; &quot;$&#123;ZBX_INCLUDE&#125;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>编辑 Dockerfile，制作新的镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> zabbix/zabbix-proxy-mysql:<span class="number">5.0</span>-centos-latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-entrypoint.sh /usr/bin/docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure>

<p>重新打包镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">使用当前目录的 Dockerfile 创建镜像，新镜像标签为 xdai/zabbix-proxy-mysql:v1</span></span><br><span class="line">docker build -t xdai/zabbix-proxy-mysql:v1 .</span><br></pre></td></tr></table></figure>

<h4 id="自定义-Agent-镜像"><a href="#自定义-Agent-镜像" class="headerlink" title="自定义 Agent 镜像"></a>自定义 Agent 镜像</h4><p>同上，略略略~</p>
<h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><p>!!! 如果在同一台设备上，部署前需要删除之前的 demo 环境，以免冲突。</p>
<p>以下内容均已在生产环境验证稳定运行，目前通过 Zabbix SNMP 监控网络设备（总计 400+ 带内网络设备，总计监控项 25w+）及 Agent 监控少量 Linux 服务器。</p>
<p>自定义配置均为实践踩坑所得优化参数。</p>
<h4 id="后端数据库"><a href="#后端数据库" class="headerlink" title="后端数据库"></a>后端数据库</h4><p>同上文数据库一节，Server 采用 RDS 的方式远程连接，本例中使用本地数据库；Proxy 由于是临时数据存储，故使用本地数据库。</p>
<p>如果在 Server&#x2F;Proxy 的自定义配置文件中调整了参数，更多的进程意味着需要更多的数据库连接，所以默认的连接数不够多，可能会造成容器异常退出，所以需要调整本地数据库的默认连接数。</p>
<p>连接数异常报错信息（通过 docker logs zbx-server-mysql查看）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ...</span><br><span class="line"> 385:20211229:152438.049 [Z3001] connection to database &#x27;zabbix&#x27; failed: [1040] Too many connections</span><br><span class="line">   385:20211229:152438.049 Cannot connect to the database. Exiting...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>修改连接数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 登录数据库</span><br><span class="line">docker exec -it zbx5-mysql mysql -uroot -proot</span><br><span class="line"># 查看最大连接数</span><br><span class="line">mysql&gt; show variables like &quot;%max_connections%&quot;;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections | 151   |</span><br><span class="line">+-----------------+-------+</span><br><span class="line"># 查看服务器响应的最大连接数</span><br><span class="line">mysql&gt; show global status like &#x27;Max_used_connections&#x27;;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Max_used_connections | 152   |</span><br><span class="line">+----------------------+-------+</span><br><span class="line"># 修改最大连接数（重启容器后会失效！）</span><br><span class="line">mysql&gt; set global max_connections = 1000;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>如果想要数据库的配置持久化，需要修改 MySQL 配置文件信息，自行百度~</p>
<h4 id="Server-后端"><a href="#Server-后端" class="headerlink" title="Server 后端"></a>Server 后端</h4><p>Server 端的自定义配置文件如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim zabbix_server.conf.d/custom.conf</span></span><br><span class="line"><span class="attr">StartPollers</span>=<span class="number">200</span></span><br><span class="line"><span class="attr">StartPreprocessors</span>=<span class="number">50</span></span><br><span class="line"><span class="attr">StartPollersUnreachable</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">StartTrappers</span>=<span class="number">50</span></span><br><span class="line"><span class="attr">StartPingers</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">StartLLDProcessors</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">StartDiscoverers</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">StartAlerters</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">CacheSize</span>=<span class="number">1024</span>M</span><br><span class="line"><span class="attr">HistoryCacheSize</span>=<span class="number">512</span>M</span><br><span class="line"><span class="attr">HistoryIndexCacheSize</span>=<span class="number">512</span>M</span><br><span class="line"><span class="attr">TrendCacheSize</span>=<span class="number">512</span>M</span><br><span class="line"><span class="attr">ValueCacheSize</span>=<span class="number">512</span>M</span><br><span class="line"><span class="attr">StartProxyPollers</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">Timeout</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">ProxyConfigFrequency</span>=<span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>将配置文件放在自定义配置目录下，挂载对应的数据卷，启动容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zabbix-server -d \</span><br><span class="line">    -e DB_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e MYSQL_DATABASE=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">    -e ZBX_ENABLE_SNMP_TRAPS=true \</span><br><span class="line">    -e ZBX_INCLUDE=&quot;/etc/zabbix/zabbix_server.conf.d/*.conf&quot; \</span><br><span class="line">    --network=host \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix_server.conf.d:/etc/zabbix/zabbix_server.conf.d \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix-data:/var/lib/zabbix \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix-data:/usr/lib/zabbix \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix-data/export:/var/lib/zabbix/export \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix-data/snmptraps:/var/lib/zabbix/snmptraps \</span><br><span class="line">	-v /etc/localtime:/etc/localtime \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    xdai/zabbix-server-mysql:v1</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>--restart unless-stopped</code>：除非手动 stop 容器，否则容器退出后会不断尝试拉起</li>
<li><code>-v /etc/localtime:/etc/localtime</code>：保持和本机时区同步</li>
<li><code>-e ZBX_ENABLE_SNMP_TRAPS=true</code>：开启后，从 snmptraps.log 读取 trap 信息</li>
</ul>
<h4 id="Web-前端"><a href="#Web-前端" class="headerlink" title="Web 前端"></a>Web 前端</h4><p>Zabbix 前端通过 PHP 来实现，默认只提供了通过参数的方式修改配置，如果需要自定义配置文件，可以参考上文重新制作镜像。</p>
<p>启动前端容器，如果数据库和 Server 端不在同一台服务器上，注意修改对应参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zabbix-web -d \</span><br><span class="line">    -e ZBX_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e DB_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e MYSQL_DATABASE=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">    -e PHP_TZ=&quot;Asia/Shanghai&quot; \</span><br><span class="line">    --network=host \</span><br><span class="line">	-v /etc/localtime:/etc/localtime \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    zabbix/zabbix-web-nginx-mysql:5.0-centos-latest</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>-e PHP_TZ=&quot;Asia/Shanghai</code>：设置时区为上海。</li>
</ul>
<p>默认端口为 8080，前端容器正常启动后，即可进行访问。</p>
<h5 id="内存占用过高的问题"><a href="#内存占用过高的问题" class="headerlink" title="内存占用过高的问题"></a>内存占用过高的问题</h5><p>运行一段时间之后，发现服务器内存被占满，通过查看进程，发现是 php-fpm 相关进程有多个，平均每个占用了 1G，在容器内修改配置文件控制一下进程数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># php 内存占用过高</span><br><span class="line"># /etc/php-fpm.d/zabbix.conf</span><br><span class="line">pm = dynamic</span><br><span class="line">pm. start_servers = 5</span><br><span class="line">pm.min_spare_servers = 5</span><br><span class="line">pm.max_spare_servers = 8</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm = dynamic 如何控制子进程，选项有static和dynamic    </span><br><span class="line">pm.max_children：静态方式下开启的php-fpm进程数量    </span><br><span class="line">pm.max_requests：php-fpm子进程能处理的最大请求数    </span><br><span class="line">pm.start_servers：动态方式下的起始php-fpm进程数量</span><br><span class="line">pm.min_spare_servers：动态方式下的最小php-fpm进程数</span><br><span class="line">pm.max_spare_servers：动态方式下的最大php-fpm进程数量</span><br></pre></td></tr></table></figure>

<h5 id="切换中文后，图形上面显示乱码的问题"><a href="#切换中文后，图形上面显示乱码的问题" class="headerlink" title="切换中文后，图形上面显示乱码的问题"></a>切换中文后，图形上面显示乱码的问题</h5><p>默认的字体没有汉语字符集，直接替换字体即可（也可以直接自定义镜像）。</p>
<p>首先下载一个字体，这里使用的是<a href="https://sourceforge.net/projects/wqy/files/wqy-microhei/0.2.0-beta/">文泉驿微米黑字体</a>，下载之后覆盖容器内的字体即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /tmp/wqy-microhei.tto zabbix-web:/usr/share/zabbix/assets/fonts/DejaVuSans.ttf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小米新发布的字体也不错，支持十种字重，下载地址：<a href="https://web.vip.miui.com/page/info/mio/mio/detail?postId=33935854">MiSans</a>。</p>
</blockquote>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>关于 Proxy 的信息可直接查看官网，有非常详尽的说明：<a href="https://www.zabbix.com/documentation/5.0/en/manual/distributed_monitoring/proxies">Proxy 概述</a>，以下为摘抄：</p>
<ul>
<li><p>主动模式：主动模式下的 Zabbix proxy 会主动连接到 Zabbix server 并请求配置数据。前端添加时不需要指定端口，只需要 Proxy 配置的名字和 Server 端添加的名字一致即可（用于判断哪个 Proxy 连上来了）。</p>
</li>
<li><p>被动模式：需要 Server 端主动连到 Proxy 上，所以添加时需要提供端口信息，配置文件从本地读取。</p>
</li>
<li><p>Zabbix proxy 到 Zabbix server 只需要一条 tcp 连接，仅在防火墙上配置一条规则即可。</p>
</li>
<li><p>Proxy 收集的所有数据在传输到服务器<strong>之前</strong>都存储在本地。这样就不会因与服务器的任何临时通信问题而丢失任何数据。当它把对应的数据发送给 Zabbix server 以后，<strong>本地临时存储的数据就会清除</strong>。</p>
</li>
<li><p>代理配置文件中的 ProxyLocalBuffer 和 ProxyOfflineBuffer 参数控制数据在本地保留的时间。</p>
</li>
<li><p>基于上述，<strong>Proxy 的数据库和 Server 的数据库一定要分开，否则会造成数据错乱或丢失。</strong></p>
</li>
</ul>
<blockquote>
<p>由于我们生产环境中网络因素（<del>不可抗力</del>），仅能使用 proxy 被动模式来部署。</p>
</blockquote>
<p>Proxy 端的自定义配置文件如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim zabbix_proxy.conf.d/custom.conf</span></span><br><span class="line"><span class="attr">EnableRemoteCommands</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">ProxyOfflineBuffer</span>=<span class="number">240</span></span><br><span class="line"><span class="attr">StartPollers</span>=<span class="number">50</span></span><br><span class="line"><span class="attr">StartDiscoverers</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">StartPreprocessors</span>=<span class="number">20</span></span><br><span class="line"><span class="attr">StartPollersUnreachable</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">StartPingers</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">CacheSize</span>=<span class="number">1024</span>M</span><br><span class="line"><span class="attr">HistoryCacheSize</span>=<span class="number">512</span>M</span><br><span class="line"><span class="attr">HistoryIndexCacheSize</span>=<span class="number">512</span>M</span><br><span class="line"><span class="attr">Timeout</span>=<span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>将配置文件放在自定义配置目录下，挂载对应的数据卷，启动容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zabbix-proxy -d \</span><br><span class="line">    -e DB_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e ZBX_LISTENPORT=11111 \</span><br><span class="line">    -e ZBX_PROXYMODE=1 \</span><br><span class="line">    -e ZBX_HOSTNAME=&quot;zabbix-proxy-test&quot; \</span><br><span class="line">    -e ZBX_SERVER_HOST=&quot;127.0.0.1&quot; \</span><br><span class="line">    -e MYSQL_USER=&quot;zabbix&quot; \</span><br><span class="line">    -e MYSQL_PASSWORD=&quot;zabbix&quot; \</span><br><span class="line">    -e ZBX_ENABLE_SNMP_TRAPS=true \</span><br><span class="line">    -e ZBX_INCLUDE=&quot;/etc/zabbix/zabbix_proxy.conf.d/*.conf&quot; \</span><br><span class="line">    --network=host \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix_proxy.conf.d:/etc/zabbix/zabbix_proxy.conf.d \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix-data:/var/lib/zabbix \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix-data/snmptraps:/var/lib/zabbix/snmptraps \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    xdai/zabbix-proxy-mysql:v1</span><br></pre></td></tr></table></figure>

<p>Proxy 启动后，可以在前端 Web 上进行添加测试一下。</p>
<p>被动模式，端口 11111。</p>
<img data-src="http://oss.xdai.vip/md-note/imgs/image-20211230005830309.png" alt="image-20211230005830309" style="zoom: 67%;" />

<p>添加成功后，上次在线时间（Last seen）会一直重置为 0，表示 Proxy 可被正常检测到。</p>
<img data-src="http://oss.xdai.vip/md-note/imgs/image-20211230010013164.png" alt="image-20211230010013164" style="zoom:67%;" />



<h4 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h4><p>Zabbix Server 端启动后，会默认监控本机的 10050 端口（zabbix_agent 端口）来对本机进行监控，如果没有运行 agent，系统会提示该主机离线。</p>
<img data-src="http://oss.xdai.vip/md-note/imgs/image-20211230010402200.png" alt="image-20211230010402200" style="zoom:67%;" />

<p>启动 Agent 容器，本机监控一般不需要额外的参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zabbix-agent -d \</span><br><span class="line">    -e ZBX_HOSTNAME=&quot;local-agent&quot; \</span><br><span class="line">    -e ZBX_SERVER_HOST=&quot;127.0.0.1&quot;  \</span><br><span class="line">    --network=host \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    zabbix/zabbix-agent:5.0-centos-latest</span><br></pre></td></tr></table></figure>

<p>Agent 端启动后，Web 上可以看到本机状态恢复正常。</p>
<img data-src="http://oss.xdai.vip/md-note/imgs/image-20211230010908510.png" alt="image-20211230010908510" style="zoom:67%;" />

<h4 id="SNMPTraps"><a href="#SNMPTraps" class="headerlink" title="SNMPTraps"></a>SNMPTraps</h4><p>如果使用的 SNMPv3 版本，需要把每台网络设备的信息都录入进去，主要是 engine-id 不同；SNMPv2版本只需要写上只读只写的团体字即可。</p>
<p>SNMPTrap 的配置文件如下，配置文件的编写参考 <a href="http://www.net-snmp.org/wiki/index.php/TUT:Configuring_snmptrapd_to_receive_SNMPv3_notifications">net-snmp</a>：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">snmpTrapdAddr udp:1162</span><br><span class="line"><span class="comment"># Start</span></span><br><span class="line"><span class="comment"># createUser -e ENGINEID myuser SHA &quot;my authentication pass&quot; AES &quot;my encryption pass&quot;</span></span><br><span class="line">createUser -e 800063A2805E9B20F2010000000001 snmpv3user MD5 snmpv3pw</span><br><span class="line"><span class="comment"># End</span></span><br><span class="line">authUser log,execute snmpv3user</span><br><span class="line">disableAuthorization no</span><br></pre></td></tr></table></figure>

<p>获取 snmp engine-id 的两种方法：</p>
<ul>
<li>登录交换机查看配置</li>
<li>使用 snmpwalk 命令查询 OID：<code>snmpwalk -v 3 -u snmpv3user -a md5 -A snmpv3pw -l authNoPriv $&#123;网络设备地址&#125; 1.3.6.1.6.3.10.2.1.1.0</code></li>
</ul>
<p>如果设备较多，可以使用 for 循环批量获取，以下脚本供参考：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line">CONF_TMPL = <span class="string">&quot;createUser -e %s snmpv3user MD5 snmpv3pw\n&quot;</span></span><br><span class="line">OID = <span class="string">&quot;1.3.6.1.6.3.10.2.1.1.0&quot;</span></span><br><span class="line"><span class="comment"># 读取设备 IP 列表文件，获取 IP 列表信息</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&quot;ip_list&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ip_list = f.readlines()</span><br><span class="line"><span class="comment"># 打开配置文件句柄</span></span><br><span class="line">snmptrap_conf_file = <span class="built_in">open</span>(<span class="string">&quot;snmptraped.conf&quot;</span>, <span class="string">&quot;w+&quot;</span>)</span><br><span class="line"><span class="comment"># 循环获取 engine_id 并写入配置文件</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> ip_list:</span><br><span class="line">    cmd = <span class="string">&quot;snmpwalk -v 3 -u snmpv3user -a md5 -A snmpv3pw -l authNoPriv %s %s&quot;</span> %(ip.strip(), OID)</span><br><span class="line">    engine_id = commands.getoutput(cmd).split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    snmptrap_conf_file.write(CONF_TMPL % (engine_id))</span><br><span class="line"><span class="comment"># 关闭配置文件句柄</span></span><br><span class="line">snmptrap_conf_file.close()</span><br></pre></td></tr></table></figure>



<p>启动 SNMPTraps 容器，这里需要注意：snmptraps 容器需要和 server&#x2F;proxy 容器共享同一个 snmptraps 目录，并且需要使用 root 用户启动（<code>--privileged=true</code>）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name snmptraps -d \</span><br><span class="line">    -v /opt/zabbix-volumes/snmp:/etc/snmp \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix-data:/var/lib/zabbix \</span><br><span class="line">    -v /opt/zabbix-volumes/zabbix-data/snmptraps:/var/lib/zabbix/snmptraps \</span><br><span class="line">    --network=host \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    -v /etc/localtime:/etc/localtime \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    zabbix/zabbix-snmptraps:5.0-centos-latest</span><br></pre></td></tr></table></figure>



<h4 id="网络设备配置"><a href="#网络设备配置" class="headerlink" title="网络设备配置"></a>网络设备配置</h4><p>以 H3C 交换机配置 SNMMPv3 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># snmp 配置</span><br><span class="line">snmp-agent</span><br><span class="line">snmp-agent sys-info version v3</span><br><span class="line">snmp-agent group v3 snmpv3group authentication read-view iso-ivew write-view iso-view notify-view iso-view</span><br><span class="line">snmp-agent mib-view included iso-view iso</span><br><span class="line">snmp-agent usm-user v3 snmpv3user snmpv3group simple authentication-mode md5 snmpv3pw</span><br><span class="line"># trap 配置</span><br><span class="line">snmp-agent trap enable</span><br><span class="line">snmp-agent trap periodical-interval 0</span><br><span class="line">snmp-agent trap source LoopBack1</span><br><span class="line"># x.x.x.x 为 zabbix server/proxy 地址，运行 snmptraps 容器的服务器</span><br><span class="line">snmp-agent target-host trap address udp-domain x.x.x.x params securityname snmpuv3user v3 authentication</span><br><span class="line">undo snmp-agent trap enable syslog</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，Zabbbix 就平台搭建完成了。</p>
<p>本文是对生产环境部署 Zabbix 平台的事后记录，目前已经稳定运行约一年。由于内网环境无法联网，部署时的记录无法导出，有一些细节改动由于时间关系已经淡忘。。。</p>
<p>关于使用，可参考官方文档，后面有时间也会做一些使用的分享。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#====================================</span><br><span class="line"># docker 安装</span><br><span class="line">需要完善的事项：docker卷存储（配置文件、日志等的路径）</span><br><span class="line"></span><br><span class="line"># 接收snmptrap</span><br><span class="line"># 默认配置文件/etc/snmp/snmptrapd.conf</span><br><span class="line">snmpTrapdAddr udp:1162</span><br><span class="line">createUser -e 800063A2805E9B20F2010000000001 snmpv3user MD5 snmpv3pw</span><br><span class="line">authUser log,execute snmpv3user</span><br><span class="line">disableAuthorization no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run --name zbx5-snmptraps \</span><br><span class="line">    -v /home/x/zabbix-conf/snmp:/etc/snmp \</span><br><span class="line">    --network=host \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    --privileged=true \</span><br><span class="line">    -d zabbix/zabbix-snmptraps:5.0-centos-latest</span><br><span class="line">---</span><br><span class="line">/var/lib/zabbix/snmptraps</span><br><span class="line">The volume contains log file snmptraps.log named with received SNMP traps.</span><br><span class="line">---</span><br><span class="line">/var/lib/zabbix/mibs</span><br><span class="line">The volume allows to add new MIB files. It does not support subdirectories, all MIBs must be placed to /var/lib/zabbix/mibs.</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/var/lib/zabbix/snmptraps 存放接收到的trap</span><br><span class="line">/var/lib/zabbix/mibs 进行mib扩展及解析，配置文件添加 &#x27;mibs +ALL&#x27;，并在mibs文件夹中放入所有mib文件</span><br><span class="line"># 解析oid</span><br><span class="line">snmptranslate -On HH3C-ARP-ENTRY-MIB::hh3cARPEntry</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"># 出现大量 hh3cPeriodicalTrap</span><br><span class="line">undo snmp-agent trap log</span><br><span class="line">--</span><br><span class="line">trap 升级为告警，自定义正则表达式</span><br><span class="line">#TODO: 正则匹配指定字段的值来进行出发告警</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. </span><br><span class="line">Security name：&#123;$SNMP_SECNAME&#125;</span><br><span class="line">Authentication passphrase：&#123;$SNMP_AUTH&#125;</span><br><span class="line">Privacy passphrase：&#123;$SNMP_PRIV&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP PUT 和 POST 的区别</title>
    <url>/posts/86bb7394.html</url>
    <content><![CDATA[<p>PUT 和POST 是 HTTP 的两个方法(Method)，都可以用来向 HTTP 服务器提交数据。似乎用哪个都可以，但其实两者还是有本质的区别的。</p>
<p>网上关于两者区别的文章比较多，但有相当一部分绝对是误导人。所以这次特意查看了 RFC7231，来澄清二者的区别。</p>
<p>首先直接摘出 RFC7231 中的的部分关键原文：</p>
<p>The fundamental difference between the POST and PUT methods is   highlighted by the different intent for the enclosed representation.   The target resource in a POST request is intended to handle the   enclosed representation according to the resource’s own semantics,   whereas the enclosed representation in a PUT request is defined as   replacing the state of the target resource.  Hence, the intent of PUT   is idempotent and visible to intermediaries, even though the exact   effect is only known by the origin server.</p>
<p>Proper interpretation of a PUT request presumes that the user agent   knows which target resource is desired.  A service that selects a   proper URI on behalf of the client, after receiving a state-changing   request, SHOULD be implemented using the POST method rather than PUT.</p>
<p>上面这两段描述的关键词就是“idempotent”（幂等），理解了这个词就理解了二者的本质区别。下面就围绕这个词从以下几个角度分析 <code>PUT</code> 和 <code>POST</code> 的区别。</p>
<span id="more"></span>

<ol>
<li>使用 <code>PUT</code> 时，必须明确知道要操作的对象，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT /customer/doc/1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的PUT请求明确是对编号为1的文档进行操作，这里编号为1的文档就是要操作的对象。如果该文档不存在，就创建该文档；如果文档已经存在，就直接整个替换文档内容。</p>
<ol start="2">
<li>有人可能会质疑，上面的例子用 <code>POST</code> 也可以实现。没错，如果用将上例中的PUT接口改成POST接口，就是这样：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /customer/doc/</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里有一个重要的不同，这里 <code>POST</code> 请求并不知道要操作的对象，它只是向 HTTP 服务器提交一篇新文档，由 HTTP 服务器为该文档产生一个编号。这就是上面从 RFC7231 中摘出的第二段文字所描述的含义。</p>
<ol start="3">
<li>有人可能会继续质问：用 <code>POST</code> 也可以用来修改目标资源对象阿。说得还是没错。还是沿用上面的例子，稍作如下改动：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /customer/doc/1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;description&quot;: &quot;I am a student&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里的含义是给编号为 1 的文档增加一个属性“description”。注意这里有两个不同：</p>
<ul>
<li><p>这里编号为1的文档必须是已经存在的文档，否则必须使用 <code>PUT</code>；</p>
</li>
<li><p>这里是对目标对象的部分修改。只是增加了一个新属性“description”，之前的属性“name”不受影响。</p>
</li>
</ul>
<p>４、最后简要总结一下，使用 <code>PUT</code> 时，必须明确知道要操作的对象，如果对象不存在，创建对象；如果对象存在，则全部替换目标对象。<br>   同样POST既可以创建对象，也可以修改对象。但用 <code>POST</code> 创建对象时，之前并不知道要操作的对象，由 HTTP 服务器为新创建的对象生成一个唯一的 URI；使用 <code>POST</code> 修改已存在的对象时，一般只是修改目标对象的部分内容。</p>
<p>经过了以上４条的分析之后，对 <code>PUT</code> 和 <code>POST</code> 的区别应该很清楚了吧？再强调一遍，<code>PUT</code> 是“idempotent”（幂等），意味着相同的 <code>PUT</code> 请求不管执行多少次，结果都是一样的。但 <code>POST</code> 则不是。就类似于 <code>x=1</code> 这条语句是幂等的，因为无论执行多少次，变量 x 的值都是１；但 <code>x++</code> 就不是幂等的，因为每执行一次，变量 x 的值都不一样。</p>
<p>当然，这里讲的都是规范，都是最佳实践（best practise）。如果你在实际开发中，不按这个来，没有人能管得了你；但是当你的REST API要开放给别人使用时，就会和大家所接受的“普世价值”违背，很可能就会发生各种问题。</p>
<blockquote>
<p>原文：<a href="https://cloud.tencent.com/developer/news/39873">https://cloud.tencent.com/developer/news/39873</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Develop</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu apt 报错 Certificate verification failed: The certificate is NOT trusted</title>
    <url>/posts/1dfab79.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用 Windows 系统安装了 Ubuntu 20.04 wsl1.0 子系统之后，照例进行软件更新，修改为清华源之后，执行 <code>apt update</code> 命令报错:</p>
<p><code>Certificate verification failed: The certificate is NOT trusted. The certificate chain uses expired certificate. Could not handshake: Error in the certificate verification</code></p>
<span id="more"></span>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>确认配置文件里面使用的是<code>https</code>源（<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/%EF%BC%89%EF%BC%9A">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/）：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>通过 <code>date</code> 命令，查看时间与当前时间一致，排除时间造成的证书问题。</p>
<p>通过 <code>apt install ca-certificates --reinstall</code> 无法更新安装包。</p>
<p>手动下载 <code>ca-certificates</code> deb 文件重新安装最新版。文件来自：<a href="https://pkgs.org/download/ca-certificates">https://pkgs.org/download/ca-certificates</a></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>URL</th>
</tr>
</thead>
<tbody><tr>
<td>Mirror</td>
<td>archive.ubuntu.com</td>
</tr>
<tr>
<td>Binary Package</td>
<td><a href="http://archive.ubuntu.com/ubuntu/pool/main/c/ca-certificates/ca-certificates_20210119~20.04.2_all.deb">http://archive.ubuntu.com/ubuntu/pool/main/c/ca-certificates/ca-certificates_20210119~20.04.2_all.deb</a></td>
</tr>
<tr>
<td>Source Package</td>
<td>ca-certificates</td>
</tr>
</tbody></table>
<p>在终端执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">wget http://archive.ubuntu.com/ubuntu/pool/main/c/ca-certificates/ca-certificates_20210119~20.04.2_all.deb</span><br><span class="line">dpkg -i ./ca-certificates_20210119~20.04.2_all.deb</span><br></pre></td></tr></table></figure>

<p>更新最新的包之后，再执行 <code>apt update</code> ，成功完成更新。</p>
<blockquote>
<p>来源参考：<a href="https://forum.ubuntu.com.cn/viewtopic.php?t=490174#p3217236">https://forum.ubuntu.com.cn/viewtopic.php?t=490174#p3217236</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title>使用多线程操作 paramiko 执行命令</title>
    <url>/posts/9a4bdb5a.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司内网设备版本有些问题，会出现队列丢包现象，由于设备较多，写个脚本定期收集会方便一点，不过内网只有 paramiko，所以简单造了一个轮子，实现多线程并发登录设备执行命令并对结果进行解析。</p>
<p>用这个脚本可以在网络设备上执行任何命令，实现各种功能，而且多线程并发很 Nice！</p>
<pre><code>本次用到的命令及输出示例如下：
# [H3C]dis qos queue-statistics interface outbound | in &quot;^ Drop&quot;
#  Dropped: 0 packets, 0 bytes
</code></pre>
<p>这个命令用来收集当前设备上所有接口的所有队列的转发信息累计值（bytes 和 packages）。</p>
<span id="more"></span>

<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>代码比较简单，主要还是 paramiko 的 SSH 基本用法，这里说一下大概思路：</p>
<ol>
<li>把所有设备信息写到一个文本文档里面，简单起见，用的是 txt，把登录信息构建成字典</li>
<li>写一个类，具有两个功能：初始化 SSH 连接、执行命令</li>
<li>对本次需求指定的命令及输出结果进行解析，并将结果存入文件</li>
<li>加入多线程执行，提高效率</li>
<li>添加 Linux 的 crontab，每小时收集一次信息 （在服务器上做的配置）</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码地址：<a href="https://github.com/xdai555/learn-python/blob/master/gists/config_backup/gather_info.py">在线查看代码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_device_list</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从文本文件读取设备列表，返回由字典组成的列表。</span></span><br><span class="line"><span class="string">    文本内容格式为：ip，用户名，密码，别名，例如：</span></span><br><span class="line"><span class="string">    1.1.1.1 admin admin sw1</span></span><br><span class="line"><span class="string">    1.1.1.2 admin admin sw2</span></span><br><span class="line"><span class="string">    ......</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        filename ([str]): 文件名称</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        device_list = []</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            ip, username, password, name = line.strip().split()</span><br><span class="line">            device_list.append(</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;ip&quot;</span>: ip,</span><br><span class="line">                    <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">                    <span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: name,</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">return</span> device_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkDevice</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip=<span class="string">&quot;&quot;</span>, username=<span class="string">&quot;&quot;</span>, password=<span class="string">&quot;&#x27;&quot;</span>, name=<span class="string">&quot;&quot;</span>, port=<span class="number">22</span>,</span>):</span><br><span class="line">        self.conn = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> ip:</span><br><span class="line">            self.ip = ip.strip()</span><br><span class="line">        <span class="keyword">elif</span> name:</span><br><span class="line">            self.name = name.strip()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;需要设备连接地址（ip 或 别名）&quot;</span>)</span><br><span class="line">        self.port = <span class="built_in">int</span>(port)</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self._open_ssh()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_open_ssh</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化 SSH 连接，调起一个模拟终端，会话结束前可以一直执行命令。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Raises:</span></span><br><span class="line"><span class="string">            e: 抛出 paramiko 连接失败的任何异常</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ssh_connect_params = &#123;</span><br><span class="line">            <span class="string">&quot;hostname&quot;</span>: self.ip,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: self.port,</span><br><span class="line">            <span class="string">&quot;username&quot;</span>: self.username,</span><br><span class="line">            <span class="string">&quot;password&quot;</span>: self.password,</span><br><span class="line">            <span class="string">&quot;look_for_keys&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&quot;allow_agent&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&quot;timeout&quot;</span>: <span class="number">5</span>,   <span class="comment"># TCP 连接超时时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        conn = paramiko.SSHClient()</span><br><span class="line">        conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn.connect(**ssh_connect_params)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> e</span><br><span class="line">        self.conn = conn.invoke_shell(term=<span class="string">&quot;vt100&quot;</span>, width=<span class="number">500</span>, height=<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exec_cmd</span>(<span class="params">self, cmd, recv_time=<span class="number">3</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;登录设备，执行命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            cmd ([type]): 命令字符串</span></span><br><span class="line"><span class="string">            recv_time (int, optional): 读取回显信息的超时时间. Defaults to 3.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Raises:</span></span><br><span class="line"><span class="string">            EOFError: 没有任何信息输出，说明连接失败。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            output: </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cmd = cmd.strip() + <span class="string">&quot;\n&quot;</span></span><br><span class="line">        self.conn.sendall(<span class="string">&quot;screen disable\n&quot;</span>)</span><br><span class="line">        self.conn.sendall(cmd)</span><br><span class="line">        time.sleep(<span class="built_in">int</span>(recv_time))</span><br><span class="line">        output = self.conn.recv(<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(output) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> EOFError(<span class="string">&quot;连接可能被关闭，没有任何信息输出&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> output.decode(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dev = &#123;</span><br><span class="line">    <span class="string">&quot;ip&quot;</span>:<span class="string">&quot;192.168.56.21&quot;</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>:<span class="string">&quot;netdevops&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>:<span class="string">&quot;Admin@h3c.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;sw1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># sw1 = NetworkDevice(**dev)</span></span><br><span class="line"><span class="comment"># ret = sw1.exec_cmd(&quot;dis version&quot;)</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_interface_drop</span>(<span class="params">output</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把设备的输出队列丢包信息解析成累加值</span></span><br><span class="line"><span class="string">    命令及输出示例如下：</span></span><br><span class="line"><span class="string">    # [H3C]dis qos queue-statistics interface outbound | in &quot;^ Drop&quot;</span></span><br><span class="line"><span class="string">    #  Dropped: 0 packets, 0 bytes</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ptn = re.<span class="built_in">compile</span>(<span class="string">r&quot;\s(\S+):\s+(\d+)\s+(\S+),\s+(\d+)\s+(\S+)&quot;</span>)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ptn.findall(output):</span><br><span class="line">        count += <span class="built_in">int</span>(i[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">cmd, **conn_parms</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;登录单台设备，执行指定命令，解析丢包统计</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sw = NetworkDevice(**conn_parms)</span><br><span class="line">    output = sw.exec_cmd(cmd)</span><br><span class="line">    drop_count = parse_interface_drop(output)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;%s %s %s&quot;</span>%(</span><br><span class="line">        conn_parms.get(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">        conn_parms.get(<span class="string">&quot;ip&quot;</span>),</span><br><span class="line">        drop_count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmd = r&#x27;dis qos queue-statistics interface outbound | in &quot;^ Drop&quot;&#x27;</span></span><br><span class="line"><span class="comment"># ret = run(cmd,**dev)</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取设备列表，使用多线程登录设备获取信息并返回</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">10</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        futures = []</span><br><span class="line">        cmd = <span class="string">r&#x27;dis qos queue-statistics interface outbound | in &quot;^ Drop&quot;&#x27;</span></span><br><span class="line">        dev_info = get_device_list(<span class="string">&quot;./iplist.txt&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> dev_info:</span><br><span class="line">            future = pool.submit(run, cmd, **d)</span><br><span class="line">            futures.append(future)</span><br><span class="line">        <span class="comment"># for f in futures:</span></span><br><span class="line">        <span class="comment">#     print(f.result())</span></span><br><span class="line">    <span class="comment"># 根据执行时间把结果写入文件，精确到小时</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./drops/%s.log&quot;</span>%time.strftime(<span class="string">&quot;%Y%m%d_%H&quot;</span>),<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">         <span class="keyword">for</span> line <span class="keyword">in</span> futures:</span><br><span class="line">            f.write(line.result() + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>paramiko</tag>
      </tags>
  </entry>
  <entry>
    <title>一张图了解 Nornir 基础概念及用法</title>
    <url>/posts/ee91bfce.html</url>
    <content><![CDATA[<p>Nornir 是一个非常好用的网络自动化的框架，最近我输出了一份 **<a href="https://nornir-docs-cn.readthedocs.io/en/latest/">Nornir 中文手册</a>**，欢迎大家阅读指正。</p>
<p><img data-src="https://img-blog.csdnimg.cn/img_convert/fb65f102c822d915308d9040e2ec9d41.png" alt="Nornir"></p>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>nornir</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化输出NETCONF回显内容</title>
    <url>/posts/f57ab1ee.html</url>
    <content><![CDATA[<p>在 《Python 使用 NETCONF 管理配置 H3C 网络设备》中，简单介绍了 Python 使用 NETCONF 操作网络设备。</p>
<p>对于配置类的操作，即 <code>edit-config</code>，NETCONF 的回显内容一般情况下为 <code>ok</code> 或者具体的报错信息；对于查询类的操作，即 <code>get</code> <code>get-config</code> 等，回显内容为 XML 格式，可读性较差，此时需要对查询到的内容进行格式化。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于 XML 格式的数据，可以直接使用 XML 模块来进行解析，由于查询信息时，已经传入了一个 XML，那么进行解析时，可以根据这个 XML 来进行操作，使用 lxml 模块来进行实际操作。</p>
<p>针对网络设备的回显信息，先解析为 lxml 支持的格式如 <code>Element</code> ，再使用 lxml 中 find 相关的方法，并添加上命名空间和具体的查询元素，查找到最终想要的信息。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="查询接口列表"><a href="#查询接口列表" class="headerlink" title="查询接口列表"></a>查询接口列表</h3><h4 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h4><p>首先构建查询接口信息的 XML。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">get_all_iface = &quot;&quot;&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">top</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.h3c.com/netconf/data:1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Ifmgr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Interfaces</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Name</span>&gt;</span><span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">InetAddressIPV4</span>&gt;</span><span class="tag">&lt;/<span class="name">InetAddressIPV4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Interfaces</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Ifmgr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">top</span>&gt;</span></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>然后将 XML 内容下发到设备上，获取信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ncclient <span class="keyword">import</span> manager</span><br><span class="line"></span><br><span class="line">host = &#123;</span><br><span class="line">    <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;port&#x27;</span>: <span class="number">830</span>,</span><br><span class="line">    <span class="string">&#x27;device_params&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;h3c&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于 ssh 协议，连接设备时会先保存对端的 key，并从本机查找并验证，使用以下两个 False 的参数来跳过检查</span></span><br><span class="line">conn = manager.connect(**host, hostkey_verify=<span class="literal">False</span>, look_for_keys=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 获取设备所有接口的名称、IP地址、状态</span></span><br><span class="line">ret = conn.get((<span class="string">&#x27;subtree&#x27;</span>, top))</span><br><span class="line"><span class="built_in">print</span>(ret,<span class="built_in">type</span>(ret),<span class="built_in">dir</span>(ret))</span><br></pre></td></tr></table></figure>

<p>获取到的信息如下，主要看回显信息的类型和支持的方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">rpc-reply</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span> <span class="attr">message-id</span>=<span class="string">&quot;urn:uuid:e667b24e-14c9-4126-9581-7b25b7835b45&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">data</span>&gt;</span><span class="tag">&lt;<span class="name">top</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.h3c.com/netconf/data:1.0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Ifmgr</span>&gt;</span><span class="tag">&lt;<span class="name">Interfaces</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet0/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;<span class="name">InetAddressIPV4</span>&gt;</span>192.168.56.20<span class="tag">&lt;/<span class="name">InetAddressIPV4</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>2<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet0/1<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>3<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet0/2<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>4<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Serial1/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>5<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Serial2/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>6<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Serial3/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>7<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Serial4/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>8<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet5/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>9<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet5/1<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>10<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet6/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>11<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet6/1<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>129<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>NULL0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>130<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>InLoopBack0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;<span class="name">InetAddressIPV4</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">InetAddressIPV4</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>131<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Register-Tunnel0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;/<span class="name">Interfaces</span>&gt;</span><span class="tag">&lt;/<span class="name">Ifmgr</span>&gt;</span><span class="tag">&lt;/<span class="name">top</span>&gt;</span><span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">rpc-reply</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> &#x27;<span class="attr">ncclient.operations.retrieve.GetReply</span>&#x27;&gt;</span></span><br><span class="line">[&#x27;ERROR_CLS&#x27;, &#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;_data&#x27;, &#x27;_errors&#x27;, &#x27;_huge_tree&#x27;, &#x27;_parsed&#x27;, &#x27;_parsing_hook&#x27;, &#x27;_raw&#x27;, &#x27;_root&#x27;, &#x27;data&#x27;, &#x27;data_ele&#x27;, &#x27;data_xml&#x27;, &#x27;error&#x27;, &#x27;errors&#x27;, &#x27;ok&#x27;, &#x27;parse&#x27;, &#x27;xml&#x27;]</span><br></pre></td></tr></table></figure>

<p>从上面的内容可以看到，通过 ncclient 模块执行 get 操作后，返回值是一个 <code>GetReply</code> 的类，它支持 <code>[‘data&#39;, &#39;data_ele&#39;, &#39;data_xml&#39;, &#39;error&#39;, &#39;errors&#39;, &#39;ok&#39;, &#39;parse&#39;, &#39;xml&#39;]</code>方法。</p>
<p>可以使用 <code>data</code> 或者 <code>data_ele</code> ，这两个方法最终的结果是相同的，都是返回 <code>Element</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="built_in">print</span>(ret.data,<span class="built_in">type</span>(ret.data))</span><br><span class="line"><span class="built_in">print</span>(ret.data==ret.data_ele)</span><br></pre></td></tr></table></figure>

<p>返回结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Element</span> &#123;<span class="attr">urn:ietf:params:xml:ns:netconf:base:1.0</span>&#125;<span class="attr">data</span> <span class="attr">at</span> <span class="attr">0x7fc9c8ab2180</span>&gt;</span> <span class="tag">&lt;<span class="name">class</span> &#x27;<span class="attr">lxml.etree._Element</span>&#x27;&gt;</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h4 id="内容拆解"><a href="#内容拆解" class="headerlink" title="内容拆解"></a>内容拆解</h4><p>网络设备接口有很多，因此使用 <code>Element</code> 的 findall() 方法，并加上命名空间和想要查找的元素。</p>
<p>上文查询信息的 XML 中，接口是以 <code>&lt;Interface&gt;...&lt;/Interface&gt;</code> 来进行筛选的，返回值也是如此，所以以该元素作为查找值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(ret.data.findall(<span class="string">&#x27;.//&#123;http://www.h3c.com/netconf/data:1.0&#125;Interface&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>回显信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5400</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5480</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5380</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5580</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5600</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5680</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5700</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5780</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5800</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5880</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5900</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5980</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5a00</span>&gt;, &lt;Element &#123;http://www.h3c.com/netconf/data:<span class="number">1.0</span>&#125;Interface at <span class="number">0x7f681f2e5a80</span>&gt;]</span><br></pre></td></tr></table></figure>

<p>回显信息为列表格式，且每个接口又有自己独立的 <code>Element</code>，又需要进行二次解析。</p>
<p>二次解析时，如果使用 findall 方法，只能按照每个接口的属性返回相应的列表；如接口的状态为一个列表，接口的名称为一个列表，接口的 IP 地址又是另一个列表；这时会有一个问题，<font color=red>使用 NETCONF 查询信息时，如果接口没有该属性，返回的 XML 内容中就不会有这个元素</font>，上文的返回值中便是一个例子：如果接口下没有 IP 地址如 GigabitEthernet0&#x2F;2，返回的 XML 中就没有 <code>InetAddressIPV4</code> 这个元素， 如果使用 for 循环将每个接口的每个属性都放到单独的列表里面，接口信息将无法对应。</p>
<p>针对这种情况，可以有四种办法（第一种是当时的头脑风暴，现在仅作记录）：</p>
<ol>
<li>针对单个接口的每个元素进行 find，并将单个接口的信息放入一个字典中；</li>
<li>使用 <code>Element</code> 的 getchildren() 方法，通过获取 tag 和 text，直接将接口信息转换为字典；</li>
<li>针对单个接口只使用 find 查找想要的信息，并将单个接口的信息放入一个字典中；</li>
<li>不重复造轮子，使用现成的模块 lxmltodict。</li>
</ol>
<h5 id="获取所有信息并格式化为字典"><a href="#获取所有信息并格式化为字典" class="headerlink" title="获取所有信息并格式化为字典"></a>获取所有信息并格式化为字典</h5><p>采用上面说的第二种的方法来获取每个接口的所有信息，最终效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">H3C_DATA = <span class="string">&quot;http://www.h3c.com/netconf/data:1.0&quot;</span></span><br><span class="line">H3C_DATA_C = <span class="string">&#x27;&#123;&#x27;</span> + H3C_DATA_1_0 + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 findall 封装成一个函数，便于复用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_all_in_data</span>(<span class="params">elem, value</span>):</span><br><span class="line">    <span class="keyword">return</span> _findall(elem, c, value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_findall</span>(<span class="params">elem, ns, value</span>):</span><br><span class="line">    <span class="keyword">return</span> elem.findall(<span class="string">&#x27;.//&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(ns, value))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elem_to_dict_all</span>(<span class="params">elem, ns</span>):</span><br><span class="line">    to_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> elem.getchildren():</span><br><span class="line">        to_dict[e.tag.replace(ns,<span class="string">&#x27;&#x27;</span>)] = e.text</span><br><span class="line">    <span class="keyword">return</span> to_dict</span><br><span class="line"></span><br><span class="line"><span class="comment"># ret 为上面直接从设备上获取到的返回值</span></span><br><span class="line"><span class="comment"># 根据上面的返回值，先获取到包含所有接口信息元素的列表，即上一个代码框中的回显信息</span></span><br><span class="line">ifaces = find_all_in_data(ret.data,<span class="string">&#x27;Interface&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用 Element 的 getchildren() 方法将所有的内容获取为字典，并将所有结果放入到一个列表里面</span></span><br><span class="line">result = [elem_to_dict_all(iface, H3C_DATA_C) <span class="keyword">for</span> iface <span class="keyword">in</span> ifaces]</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;GigabitEthernet0/0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;InetAddressIPV4&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;GigabitEthernet0/1&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;GigabitEthernet0/2&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Serial1/0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Serial2/0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Serial3/0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Serial4/0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;GigabitEthernet5/0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;GigabitEthernet5/1&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;GigabitEthernet6/0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;GigabitEthernet6/1&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;129&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;NULL0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, </span><br><span class="line"> &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;130&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;InLoopBack0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;InetAddressIPV4&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>&#125;, &#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;131&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Register-Tunnel0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>可以看到已经以字典方式获取到了所有接口的信息，之后再进行处理时，就更加容易了。</p>
<p>关于 getchildren() 方法，我们获取到的单个接口信息转换为字符串，就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">ifaces = find_all_in_data(ret.data,<span class="string">&#x27;Interface&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(etree.tostring(ifaces[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># 得到结果如下：</span></span><br><span class="line"><span class="string">b&#x27;&lt;Interface xmlns=&quot;http://www.h3c.com/netconf/data:1.0&quot;&gt;&lt;IfIndex&gt;1&lt;/IfIndex&gt;&lt;Name&gt;GigabitEthernet0/0&lt;/Name&gt;&lt;AdminStatus&gt;1&lt;/AdminStatus&gt;&lt;InetAddressIPV4&gt;192.168.56.20&lt;/InetAddressIPV4&gt;&lt;/Interface&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从 XML 基础知识的角度来说明上面的结果： <code>&lt;Interface&gt;</code> 是一个根元素，<code>&lt;IfIndex&gt;</code> <code>&lt;Name&gt;</code> 等四项内容是根的子元素，<code>xmlns</code> 是根的属性，转换到 lxml 中，可以用 tag，text 两个属性来获取到具体的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ifaces[<span class="number">0</span>]:</span><br><span class="line">    <span class="built_in">print</span>(i.tag, i.text)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#123;http://www.h3c.com/netconf/data:1.0&#125;IfIndex 1</span><br><span class="line">&#123;http://www.h3c.com/netconf/data:1.0&#125;Name GigabitEthernet0/0</span><br><span class="line">&#123;http://www.h3c.com/netconf/data:1.0&#125;AdminStatus 1</span><br><span class="line">&#123;http://www.h3c.com/netconf/data:1.0&#125;InetAddressIPV4 192.168.56.20</span><br></pre></td></tr></table></figure>

<p>已经是我们想要得到的数据了！之后用字符串替换掉命名空间，写入字典，就得到了下面这个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">elem_to_dict_all</span>(<span class="params">elem, ns</span>):</span><br><span class="line">    to_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> elem.getchildren():</span><br><span class="line">        to_dict[e.tag.replace(ns,<span class="string">&#x27;&#x27;</span>)] = e.text</span><br><span class="line">    <span class="keyword">return</span> to_dict</span><br></pre></td></tr></table></figure>

<p>经过上面的步骤，已经得到了接口信息，是一个字典形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;GigabitEthernet0/0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;InetAddressIPV4&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步应该算成功了， XML 内容转换为了清晰可读的字典。</p>
<h5 id="获取指定信息并格式化为字典（优化显示）"><a href="#获取指定信息并格式化为字典（优化显示）" class="headerlink" title="获取指定信息并格式化为字典（优化显示）"></a>获取指定信息并格式化为字典（优化显示）</h5><p>首先，要想获取指定信息，前提是要有一个获取信息的列表，这里我采用的类型是字典而不是列表，为的是替换原始的 key，增加可读性，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">H3C_DATA = <span class="string">&quot;http://www.h3c.com/netconf/data:1.0&quot;</span></span><br><span class="line">H3C_DATA_C = <span class="string">&#x27;&#123;&#x27;</span> + H3C_DATA_1_0 + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">iface_key_map = &#123;</span><br><span class="line">    <span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;Name&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MTU&#x27;</span>: <span class="string">&#x27;ActualMTU&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;IP 地址&#x27;</span>: <span class="string">&#x27;InetAddressIPV4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;掩码&#x27;</span>: <span class="string">&#x27;InetAddressIPV4Mask&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;配置状态&#x27;</span>：<span class="string">&#x27;AdminStatus&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">elem_to_dict</span>(<span class="params">elem, ns, key_map</span>):</span><br><span class="line">    to_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> key_map.items():</span><br><span class="line">        <span class="comment"># 传递的 elem 是具体接口的信息，属性不会重复，所以这里使用 find 方法</span></span><br><span class="line">        field = elem.find(<span class="string">&#x27;.//&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(ns, v))</span><br><span class="line">        <span class="keyword">if</span> field <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            text = field.text</span><br><span class="line">            to_dict[k] = text</span><br><span class="line">    <span class="keyword">return</span> to_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_elem_to_dict</span>(<span class="params">elem, key_map</span>):</span><br><span class="line">    <span class="keyword">return</span> elem_to_dict(elem, H3C_DATA_C, key_map)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ret 为上面直接从设备上获取到的返回值</span></span><br><span class="line">ifaces = find_all_in_data(ret.data,<span class="string">&#x27;Interface&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取字典里面指定的信息</span></span><br><span class="line">result = [data_elem_to_dict(iface,iface_key_map) <span class="keyword">for</span> iface <span class="keyword">in</span> ifaces]</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&#x27;IP 地址&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>, <span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;GigabitEthernet0/0&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;GigabitEthernet0/1&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;GigabitEthernet0/2&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;Serial1/0&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;Serial2/0&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;Serial3/0&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;Serial4/0&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;GigabitEthernet5/0&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;GigabitEthernet5/1&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;GigabitEthernet6/0&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;GigabitEthernet6/1&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;NULL0&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;IP 地址&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;InLoopBack0&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;接口名称&#x27;</span>: <span class="string">&#x27;Register-Tunnel0&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>通过这种方式，不但得到了字典形式的接口信息，而且对 key 进行可可读性处理。</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>上面内容拆解中，说明了两种方法来实现对设备接口信息的格式化处理，这两种方式有各自应用场景。</p>
<p>个人观点：使用 XML 获取接口信息时，可以直接获取接口的所有状态。</p>
<ol>
<li>如果是交给程序调用，可以使用 getchildren() 的方法，获取到接口的所有信息并格式化为字典，之后交由其他模块来处理；</li>
<li>如果是呈现到使用者，例如前端或者 CLI 展示，可以使用获取指定信息的方法，提高返回值的可读性。</li>
</ol>
<h3 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h3><p>有现成的模块可以直接将 xml 格式转换为字典，就是 <code>xmltodict</code> 模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install xmltodict</span><br></pre></td></tr></table></figure>

<p>这个模块使用了 OrderedDict 类来实现，也解决了上面提到的字典无序导致的无法进行值对应的问题。</p>
<blockquote>
<p>Python 中的字典是无序的，因为它是按照 HASH 来存储的，不过 Python 中有个模块 collections，里面自带了一个子类 OrderedDict，实现了对字典对象中元素的排序。</p>
</blockquote>
<p>使用方法也很简单，直接传入 XML 内容即可进行解析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xmltodict</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># ret 为上面直接从设备上获取到的返回值</span></span><br><span class="line">ifaces = find_all_in_data(ret.data,<span class="string">&#x27;Interface&#x27;</span>)</span><br><span class="line">result = xmltodict.parse(etree.tostring(ifaces[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(result[<span class="string">&#x27;Interface&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OrderedDict([(<span class="string">&#x27;Interface&#x27;</span>, OrderedDict([(<span class="string">&#x27;@xmlns&#x27;</span>, <span class="string">&#x27;http://www.h3c.com/netconf/data:1.0&#x27;</span>), (<span class="string">&#x27;IfIndex&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), (<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;GigabitEthernet0/0&#x27;</span>), (<span class="string">&#x27;AdminStatus&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), (<span class="string">&#x27;InetAddressIPV4&#x27;</span>, <span class="string">&#x27;192.168.56.20&#x27;</span>)]))])</span><br><span class="line">&#123;<span class="string">&#x27;@xmlns&#x27;</span>: <span class="string">&#x27;http://www.h3c.com/netconf/data:1.0&#x27;</span>, <span class="string">&#x27;IfIndex&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;GigabitEthernet0/0&#x27;</span>, <span class="string">&#x27;AdminStatus&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;InetAddressIPV4&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>使用 xmltodict 可以一步到位，直接将结果转换为字典！可以将 xmltodict 进行二次封装，进行可读处理等。</p>
<p>现成的轮子还是很方便 T_T ~</p>
<p>不过不论哪种方法提取数据，适合自己的才是最好的，手写简单的轮子可以更理解的更深入一点 (* ￣︿￣)。</p>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>netconf</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 使用 NETCONF 管理配置 H3C 网络设备</title>
    <url>/posts/3e542090.html</url>
    <content><![CDATA[<p>之前简单介绍了 Python 针对 XML 文件的操作方式，XML 的诸多特性使得它非常适合程序之间的数据传输，NETCONF 就是采用 XML 来进行工作。</p>
<h2 id="NETCONF-简单介绍"><a href="#NETCONF-简单介绍" class="headerlink" title="NETCONF 简单介绍"></a>NETCONF 简单介绍</h2><p>NETCONF（Network Configuration Protocol，网络配置协议）是一种基于 XML 的网络管理协议，它提供了一种可编程的、对网络设备进行配置和管理的方法。</p>
<p>NETCONF 报文使用 XML 格式，具有强大的过滤能力，而且每一个数据项都有一个固定的元素名称和位置，所以具有很强的兼容性，不同厂家不同设备可以通过 XML 得到相同的结果，便于混合不同厂商不同设备的为冷热软件开发。</p>
<h3 id="NETCONF-协议结构"><a href="#NETCONF-协议结构" class="headerlink" title="NETCONF 协议结构"></a>NETCONF 协议结构</h3><p>NETCONF 采用分层结构，分别为：</p>
<ul>
<li>Content 内容层</li>
<li>Operations 操作层</li>
<li>RPC（Remote Procedure Call）远程调用层</li>
<li>Transport Protocol 通信协议层</li>
</ul>
<span id="more"></span>

<p>XML 分层与 NETCONF 协议分层模型对应关系</p>
<table>
<thead>
<tr>
<th>NETCONF 分层</th>
<th>XML 分层</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Content<br />内容层</td>
<td>具体的配置数据、状态数据等信息</td>
<td>被管理对象的信息，包括配置、状态等，如：<br /><code>&lt;Ifmgr&gt;&lt;Interfaces&gt;&lt;Interface&gt;&lt;Name&gt;G0/0&lt;/Name&gt;&lt;/Interface&gt;&lt;/Interfaces&gt;&lt;/Ifmgr&gt;</code><br />这个 XML 就是一个简单的内容层，它表示了一个接口的名称信息：G0&#x2F;0。</td>
</tr>
<tr>
<td>Operations<br />操作层</td>
<td><code>&lt;get&gt;</code>，<code>&lt;get-config&gt;</code>，<code>&lt;edit-config&gt;</code></td>
<td>RPC 中的基本的原语操作集，NETCONF 对其进行扩展，全面定义了对被管理设备的各种基础操作，如<code>get</code>，<code>get-config</code>，<code>get-bulk</code>，<code>edit-config</code>等。</td>
</tr>
<tr>
<td>RPC <br />远程调用层</td>
<td><code>&lt;rpc&gt;</code>，<code>rpc-reply</code></td>
<td>为 RPC 模块的编码提供了简单的、传输协议无关的机制，在 XML 中使用<code>&lt;rpc&gt;</code>，<code>rpc-reply</code>对上层的请求和响应数据进行封装。</td>
</tr>
<tr>
<td>Transport Protocol<br />通信协议层</td>
<td>设备登录方式，支持 Console、SSH、HTTP、TLS、Telnet 等</td>
<td>为 NETCONF 提供面向连接的、可靠的、顺序的数据链路。</td>
</tr>
</tbody></table>
<p>可参考下图：<br><img data-src="https://img-blog.csdnimg.cn/20210422215225791.png"></p>
<h3 id="NETCONF-报文结构"><a href="#NETCONF-报文结构" class="headerlink" title="NETCONF 报文结构"></a>NETCONF 报文结构</h3><p>NETCONF 命令必须符合 XML 语言的基本格式。NETCONF 报文格式遵循 <a href="https://tools.ietf.org/html/rfc4741">RFC 4741</a>&#x2F;<a href="https://tools.ietf.org/html/rfc6241">RFC 6241</a>。</p>
<h4 id="请求报文格式"><a href="#请求报文格式" class="headerlink" title="请求报文格式"></a>请求报文格式</h4><p>对于 H3C 网络设备，请求报文分为两部分：协议定义部分、H3C 自有部分，格式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">rpc</span> <span class="attr">message-id</span> =<span class="string">&quot;101&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">operation</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">rpc</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>协议定义部分：</p>
<ul>
<li>encoding 表示使用的 XML 编码格式，默认使用 UTF-8。</li>
<li>message-id 表示消息 ID。客户端使用单调递增的整数来表示消息 ID。服务器端在应答中会使用相同的消息 ID 以表示应答对应的请求。</li>
<li>协议定义部分的命名空间必须为 <code>urn:ietf:params:xml:ns:netconf:base:1.0</code>。</li>
</ul>
<p>H3C 自有部分：<br>对于 get 系列操作，filter 元素下的内容为 H3C 自有部分；对于 edit-config 系<br>列操作，config 元素下的内容为 H3C 自有部分。<br>H3C 自有部分需要使用H3C命名空间，H3C 命名空间又分为 base、config、data、action<br>命名空间。</p>
<ul>
<li>Base 命名空间：<code>http://www.h3c.com/netconf/base:1.0</code></li>
<li>Config 命名空间：<code>http://www.h3c.com/netconf/config:1.0</code></li>
<li>Data 命名空间：<code>http://www.h3c.com/netconf/data:1.0</code></li>
<li>Action 命名空间：<code>http://www.h3c.com/netconf/action:1.0</code></li>
</ul>
<p>具体使用哪个命名空间与操作类型和内容有关。</p>
<p>以为接口配置一个 IP 地址的消息为例，请求报文结构可以用下图来说明：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2021042221511225.png" alt="xml-layer"></p>
<h4 id="报文回复格式"><a href="#报文回复格式" class="headerlink" title="报文回复格式"></a>报文回复格式</h4><p>报文回复格式统一使用协议定义的  <code>&lt;rpc-reply&gt;</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">rpc-reply</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span> <span class="attr">message-id</span>=<span class="string">&quot;101&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">ok</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">rpc-reply</span>&gt;</span> </span><br></pre></td></tr></table></figure>


<h3 id="NETCONF-配置数据库"><a href="#NETCONF-配置数据库" class="headerlink" title="NETCONF 配置数据库"></a>NETCONF 配置数据库</h3><p>NETCONF 有三个配置数据库，用来对设备的配置进行管理。</p>
<ul>
<li><code>&lt;running/&gt;</code>：存储正在运行的配置，等价于 <code>show run / display cur</code>，所有设备都具有该数据库。</li>
<li><code>&lt;startup/&gt;</code>：存储下次启动时生效的配置，等价于<code>show startup / display saved</code>。</li>
<li><code>&lt;candidate/&gt;</code>：存储没有生效的候选配置，等价于一些设备需要<code>commit</code>来使配置生效，并不是所有设备都支持。</li>
</ul>
<h3 id="NETCONF-支持的操作"><a href="#NETCONF-支持的操作" class="headerlink" title="NETCONF 支持的操作"></a>NETCONF 支持的操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;get-config&gt;</code></td>
<td>用来从<code>&lt;running/&gt;</code>、<code>&lt;candidate/&gt;</code>和<code>&lt;startup/&gt;</code>数据库中获取全部或部分配置数据。</td>
</tr>
<tr>
<td><code>&lt;get&gt;</code></td>
<td>用来从<code>&lt;running/&gt;</code>数据库中获取全部或部分运行配置数据或设备的状态数据。</td>
</tr>
<tr>
<td><code>&lt;edit-config&gt;</code></td>
<td>用来对<code>&lt;running/&gt;</code>或<code>&lt;candidate/&gt;</code>数据库新增、修改、删除配置数据。</td>
</tr>
<tr>
<td><code>&lt;copy-config&gt;</code></td>
<td>用源数据库替换目标数据库。如果目标数据库没有创建，则直接创建数据库，然后进行拷贝。</td>
</tr>
<tr>
<td><code>&lt;delete-config&gt;</code></td>
<td>用来删除一个数据库，但不能删除<code>&lt;running/&gt;</code>数据库。</td>
</tr>
<tr>
<td><code>&lt;lock&gt;</code></td>
<td>用来锁定一个数据库，独占数据库的修改权限，防止多用户并行操作设备产生冲突。</td>
</tr>
<tr>
<td><code>&lt;unlock&gt;</code></td>
<td>用来取消用户自己之前执行的<code>&lt;lock&gt;</code>操作，但不能取消其他用户的<code>&lt;lock&gt;</code>操作。</td>
</tr>
<tr>
<td><code>&lt;close-session&gt;</code></td>
<td>用来正常关闭NETCONF会话。</td>
</tr>
<tr>
<td><code>&lt;kill-session&gt;</code></td>
<td>用来强制关闭NETCONF会话，只有管理员用户才有权限执行<code>&lt;kill-session&gt;</code>操作。</td>
</tr>
</tbody></table>
<h2 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h2><h3 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h3><h4 id="网络环境"><a href="#网络环境" class="headerlink" title="网络环境"></a>网络环境</h4><p>使用 HCL 模拟器，打开一台设备，连接到本地网络<br><img data-src="https://img-blog.csdnimg.cn/20210422215617862.png"></p>
<h4 id="设备配置"><a href="#设备配置" class="headerlink" title="设备配置"></a>设备配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0</span><br><span class="line"> port link-mode route</span><br><span class="line"> ip address 192.168.56.20 255.255.255.0</span><br><span class="line">#</span><br><span class="line">local-user netdevops</span><br><span class="line"> password simple netdevops</span><br><span class="line"> authorization-attribute user-role network-admin</span><br><span class="line"> service-type ssh</span><br><span class="line"> #</span><br><span class="line"> ssh server enable</span><br><span class="line"> netconf ssh server enable</span><br><span class="line"> #</span><br><span class="line"> user-interface vty 0 63</span><br><span class="line"> authentication-mode scheme</span><br><span class="line"> #</span><br></pre></td></tr></table></figure>
<h4 id="代码环境"><a href="#代码环境" class="headerlink" title="代码环境"></a>代码环境</h4><ul>
<li>Python 3.8</li>
<li>ncclient 0.6.7</li>
</ul>
<p>本次实验使用 ncclient 模块来操作网络设备，可以使用 <code>pip install ncclient</code> 来进行安装，可以先把 pip 下载源修改为国内的，否则下载速度会很慢，参考 <a href="https://blog.csdn.net/q965844841qq/article/details/105547362">pip 设置国内源</a>。</p>
<h3 id="使用-NETCONF-获取设备接口信息"><a href="#使用-NETCONF-获取设备接口信息" class="headerlink" title="使用 NETCONF 获取设备接口信息"></a>使用 NETCONF 获取设备接口信息</h3><h4 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 lxml 相关模块，用于构建 xml</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> lxml.builder <span class="keyword">import</span> ElementMaker</span><br><span class="line"><span class="comment"># 导入 ncclient 相关模块，用于使用 NETCONF 协议连接设备</span></span><br><span class="line"><span class="keyword">from</span> ncclient <span class="keyword">import</span> manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据网络环境，构建包含设备信息的字典</span></span><br><span class="line">host = &#123;</span><br><span class="line">    <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;port&#x27;</span>: <span class="number">830</span>,</span><br><span class="line">    <span class="string">&#x27;device_params&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;h3c&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构建-XML"><a href="#构建-XML" class="headerlink" title="构建 XML"></a>构建 XML</h4><p>XML 信息可以使用纯文本格式手写，也可以使用 lxml 工具来构建，构建方式可以参考<a href="https://blog.csdn.net/q965844841qq/article/details/114714690">上一篇文章</a> 。</p>
<p>上文请求报文格式中说明了，对于 get 操作，需要加入 H3C 自有部分的命名空间。<br>获取设备信息需要使用 data 命名空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建 xml 请求文件，以下 xml 用于获取设备上所有的接口名称</span></span><br><span class="line">get_all_iface = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;top xmlns=&quot;http://www.h3c.com/netconf/data:1.0&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;Ifmgr&gt;</span></span><br><span class="line"><span class="string">&lt;Interfaces&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;</span></span><br><span class="line"><span class="string">&lt;Name&gt;&lt;/Name&gt;</span></span><br><span class="line"><span class="string">&lt;InetAddressIPV4&gt;&lt;/InetAddressIPV4&gt;</span></span><br><span class="line"><span class="string">&lt;AdminStatus&gt;&lt;/AdminStatus&gt;</span></span><br><span class="line"><span class="string">&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;/Interfaces&gt;</span></span><br><span class="line"><span class="string">&lt;/Ifmgr&gt;</span></span><br><span class="line"><span class="string">&lt;/top&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 可以使用 lxml 相关模块构建获取接口信息需要的 xml</span></span><br><span class="line"><span class="comment"># 以下 xml 用于获取设备上所有的接口名称</span></span><br><span class="line">H3C_DATA_1_0 = <span class="string">&quot;http://www.h3c.com/netconf/data:1.0&quot;</span></span><br><span class="line">H3C_DATA_1_0_C = <span class="string">&#x27;&#123;&#x27;</span> + H3C_DATA_1_0 + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">E = ElementMaker(namespace=H3C_DATA_1_0, nsmap=&#123;<span class="literal">None</span>: H3C_DATA_1_0&#125;)</span><br><span class="line">top = E.top(</span><br><span class="line">    E.Ifmgr(</span><br><span class="line">        E.Interfaces(</span><br><span class="line">            E.Interface(</span><br><span class="line">                E.Name(),</span><br><span class="line">                E.InetAddressIPV4(),</span><br><span class="line">                E.AdminStatus()</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<p>不论哪种方式构建，最终的内容都是一样的</p>
<h4 id="连接设备，执行-XML"><a href="#连接设备，执行-XML" class="headerlink" title="连接设备，执行 XML"></a>连接设备，执行 XML</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于 ssh 协议，连接设备时会先保存对端的 key，并从本机查找并验证，使用以下两个 False 的参数来跳过检查</span></span><br><span class="line">conn = manager.connect(**host, hostkey_verify=<span class="literal">False</span>, look_for_keys=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 获取设备所有接口的名称、IP地址、状态</span></span><br><span class="line">ret = conn.get((<span class="string">&#x27;subtree&#x27;</span>, top))</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure>
<p>上面代码中使用了 ncclient 封装的 get 操作，我们只需要传入 Content 层的 XML 信息即可，实际上传递给网络设备完整的一个请求报文包含了协议定义的部分，这部分属于 Operation 层，具体的原始 XML 是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rpc</span> <span class="attr">message-id</span>=<span class="string">&quot;ncclient 自动生成的 id&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">get</span>&gt;</span>                         <span class="comment">&lt;!--- Operation 层，使用 get 操作 ---&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">type</span>=<span class="string">&quot;subtree&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">top</span>&gt;</span>&quot;构建的 xml 内容&quot;<span class="tag">&lt;/<span class="name">top</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">get</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rpc</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述几段代码结合起来，执行结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">rpc-reply</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span> <span class="attr">message-id</span>=<span class="string">&quot;urn:uuid:c2124ac3-2c72-4046-a575-de8ea8d151a7&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span><span class="tag">&lt;<span class="name">top</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.h3c.com/netconf/data:1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Ifmgr</span>&gt;</span><span class="tag">&lt;<span class="name">Interfaces</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet0/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;<span class="name">InetAddressIPV4</span>&gt;</span>192.168.56.20<span class="tag">&lt;/<span class="name">InetAddressIPV4</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>2<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet0/1<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>3<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet0/2<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>4<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Serial1/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>5<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Serial2/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>6<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Serial3/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>7<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Serial4/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>8<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet5/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>9<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet5/1<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>10<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet6/0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>11<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>GigabitEthernet6/1<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>129<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>NULL0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>130<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>InLoopBack0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;<span class="name">InetAddressIPV4</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">InetAddressIPV4</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;<span class="name">Interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>131<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Register-Tunnel0<span class="tag">&lt;/<span class="name">Name</span>&gt;</span><span class="tag">&lt;<span class="name">AdminStatus</span>&gt;</span>1<span class="tag">&lt;/<span class="name">AdminStatus</span>&gt;</span><span class="tag">&lt;/<span class="name">Interface</span>&gt;</span><span class="tag">&lt;/<span class="name">Interfaces</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Ifmgr</span>&gt;</span><span class="tag">&lt;/<span class="name">top</span>&gt;</span><span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">rpc-reply</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，已经成功从设备中获取到了想要的接口信息，对于设备不存在的信息，返回值没有该标签；<br>之后对返回数据根据需要进行格式化即可，之后会介绍如何格式化该数据。</p>
<h3 id="使用-NETCONF-下发接口配置"><a href="#使用-NETCONF-下发接口配置" class="headerlink" title="使用 NETCONF 下发接口配置"></a>使用 NETCONF 下发接口配置</h3><h4 id="构建-XML-1"><a href="#构建-XML-1" class="headerlink" title="构建 XML"></a>构建 XML</h4><p>以给 G0&#x2F;1 接口配置 IP 地址为例，由于 NETCONF 只支持通过 IfIndex 来进行配置，如果实际使用中想要根据接口名称来进行配置，则需要对功能进行封装；<br>从上面的结果中可以看到 G0&#x2F;1 的接口索引值为 2，所以构建以下 XML：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下发配置需要有 config 元素，且命名空间固定，之后再加入 top 元素及具体的配置信息元素</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> ElementMaker, etree</span><br><span class="line"></span><br><span class="line">BASE_NS_1_0 = <span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span></span><br><span class="line">H3C_CONFIG_1_0 = <span class="string">&quot;http://www.h3c.com/netconf/config:1.0&quot;</span></span><br><span class="line">C = ElementMaker(namespace=BASE_NS_1_0, nsmap=&#123;<span class="literal">None</span>: BASE_NS_1_0&#125;)</span><br><span class="line">E = ElementMaker(namespace=H3C_CONFIG_1_0, nsmap=&#123;<span class="literal">None</span>: H3C_CONFIG_1_0&#125;)</span><br><span class="line"></span><br><span class="line">xml_ifcfg = C.config(</span><br><span class="line">    E.top(</span><br><span class="line">        E.Ifmgr(</span><br><span class="line">            E.Interfaces(</span><br><span class="line">                E.Interface(</span><br><span class="line">                    E.IfIndex(<span class="string">&quot;2&quot;</span>),</span><br><span class="line">                    E.Description(<span class="string">&quot;Configured by netconf&quot;</span>),</span><br><span class="line">                    E.InetAddressIPV4(<span class="string">&quot;1.1.1.1&quot;</span>),</span><br><span class="line">                    E.InetAddressIPV4Mask(<span class="string">&quot;24&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(etree.tostring(xml_ifcfg))</span><br></pre></td></tr></table></figure>

<p>实际生成的 XML 内容打印如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">top</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.h3c.com/netconf/config:1.0&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">IPV4ADDRESS</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Ipv4Addresses</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">Ipv4Address</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">IfIndex</span>&gt;</span>2<span class="tag">&lt;/<span class="name">IfIndex</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">Ipv4Address</span>&gt;</span>1.1.1.1<span class="tag">&lt;/<span class="name">Ipv4Address</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">Ipv4Mask</span>&gt;</span>255.255.255.0<span class="tag">&lt;/<span class="name">Ipv4Mask</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">Ipv4Address</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">Ipv4Addresses</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">IPV4ADDRESS</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">top</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span>&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="连接设备，执行-XML-1"><a href="#连接设备，执行-XML-1" class="headerlink" title="连接设备，执行 XML"></a>连接设备，执行 XML</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将接口配置下发到 running 配置库中</span></span><br><span class="line">conn = manager.connect(**host, hostkey_verify=<span class="literal">False</span>, look_for_keys=<span class="literal">False</span>)</span><br><span class="line">ret = conn.edit_config(target=<span class="string">&quot;running&quot;</span>, config=xml_ifcfg)</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure>

<p>返回值为 ok，说明配置下发成功，打印执行结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rpc-reply</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;</span> <span class="attr">message-id</span>=<span class="string">&quot;urn:uuid:67ad766a-83de-45ba-a575-95059a6cfce6&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ok</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rpc-reply</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>到设备上检查配置下发成功：<br><img data-src="https://img-blog.csdnimg.cn/2021042322422449.png" alt="ip配置"></p>
<h3 id="使用-NETCONF-下发-BGP-配置"><a href="#使用-NETCONF-下发-BGP-配置" class="headerlink" title="使用 NETCONF 下发 BGP 配置"></a>使用 NETCONF 下发 BGP 配置</h3><h4 id="构建-XML-2"><a href="#构建-XML-2" class="headerlink" title="构建 XML"></a>构建 XML</h4><p>为设备配置 ASNumber 为 62333，并宣告 G1&#x2F;0 的接口地址。<br>根据一般的 BGP 配置逻辑，应该：</p>
<ol>
<li>配置 ASN，即启动 BGP 进程</li>
<li>配置地址族，表明配置生效的范围，如单播 IPv4，带有 VPN Instance 的单播 IPv4 等，并配置相关属性，如本地优先级、等价路由数目等</li>
<li>配置宣告路由等</li>
</ol>
<p>对应的在 NETCONF 中下发配置时，操作逻辑也是一样的。<br>根据需要进行的配置构建以下 XML：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 asn</span></span><br><span class="line">xml_bgp_asn_cfg = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;config xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;top xmlns=&quot;http://www.h3c.com/netconf/config:1.0&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;BGP&gt;</span></span><br><span class="line"><span class="string"> &lt;Instances&gt;</span></span><br><span class="line"><span class="string"> &lt;Instance&gt;</span></span><br><span class="line"><span class="string"> &lt;Name&gt;&lt;/Name&gt;</span></span><br><span class="line"><span class="string"> &lt;ASNumber&gt;62333&lt;/ASNumber&gt;</span></span><br><span class="line"><span class="string"> &lt;/Instance&gt;</span></span><br><span class="line"><span class="string"> &lt;/Instances&gt;</span></span><br><span class="line"><span class="string">&lt;/BGP&gt;</span></span><br><span class="line"><span class="string">&lt;/top&gt;</span></span><br><span class="line"><span class="string">&lt;/config&gt;&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 配置单播 ipv4 地址族</span></span><br><span class="line">xml_bgp_familys_cfg=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;config xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;top xmlns=&quot;http://www.h3c.com/netconf/config:1.0&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;BGP&gt;</span></span><br><span class="line"><span class="string">&lt;Familys&gt;</span></span><br><span class="line"><span class="string">&lt;Family&gt;</span></span><br><span class="line"><span class="string">&lt;Name&gt;&lt;/Name&gt;</span></span><br><span class="line"><span class="string">&lt;VRF&gt;&lt;/VRF&gt;</span></span><br><span class="line"><span class="string">&lt;Type&gt;1&lt;/Type&gt;</span></span><br><span class="line"><span class="string">&lt;/Family&gt;</span></span><br><span class="line"><span class="string">&lt;/Familys&gt;</span></span><br><span class="line"><span class="string">&lt;/BGP&gt;</span></span><br><span class="line"><span class="string">&lt;/top&gt;</span></span><br><span class="line"><span class="string">&lt;/config&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 在单播 ipv4 地址族中宣告网段</span></span><br><span class="line">xml_bgp_net_cfg = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;config xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;top xmlns=&quot;http://www.h3c.com/netconf/config:1.0&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;BGP&gt;</span></span><br><span class="line"><span class="string"> &lt;Networks&gt;</span></span><br><span class="line"><span class="string"> &lt;Network&gt;</span></span><br><span class="line"><span class="string"> &lt;Name&gt;&lt;/Name&gt;</span></span><br><span class="line"><span class="string"> &lt;VRF&gt;&lt;/VRF&gt;</span></span><br><span class="line"><span class="string"> &lt;Family&gt;1&lt;/Family&gt;</span></span><br><span class="line"><span class="string"> &lt;IpAddress&gt;1.1.1.1&lt;/IpAddress&gt;</span></span><br><span class="line"><span class="string"> &lt;Mask&gt;24&lt;/Mask&gt;</span></span><br><span class="line"><span class="string"> &lt;/Network&gt;</span></span><br><span class="line"><span class="string"> &lt;/Networks&gt;</span></span><br><span class="line"><span class="string">&lt;/BGP&gt;</span></span><br><span class="line"><span class="string">&lt;/top&gt;</span></span><br><span class="line"><span class="string">&lt;/config&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="连接设备，执行-XML-2"><a href="#连接设备，执行-XML-2" class="headerlink" title="连接设备，执行 XML"></a>连接设备，执行 XML</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn = manager.connect(**host, hostkey_verify=<span class="literal">False</span>, look_for_keys=<span class="literal">False</span>)</span><br><span class="line">conn.edit_config(target=<span class="string">&quot;running&quot;</span>, config=xml_bgp_net_cfg)</span><br><span class="line">conn.edit_config(target=<span class="string">&quot;running&quot;</span>, config=xml_bgp_net_cfg)</span><br><span class="line">conn.edit_config(target=<span class="string">&quot;running&quot;</span>, config=xml_bgp_net_cfg)</span><br></pre></td></tr></table></figure>

<p>依次执行三项配置并返回成功后，可以在设备上看到相关的配置：<br><img data-src="https://img-blog.csdnimg.cn/20210423231825685.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章简单介绍了 NETCONF 协议，并结合上篇文章中关于 XML 的知识，进行了三个实际的操作案例。</p>
<p>乍一看，你可能会想：用 NETCONF 下发配置和我用命令行差不多啊，而且看起来好复杂啊，用命令行三下五除二就配置完成了。</p>
<p>NETCONF 的好处在于，如果将日常运维的操作封装为接口进行调用，并且以 WEB 的方式显示出来或者进行配置操作，会方便许多，而且可以做成标准化、流程化的操作进行变更，且返回的数据都是 XML 格式，可以很轻松的转换成 JSON，与其他平台进行联动，这些都是命令行操作不可控的（命令行的操作逻辑及返回数据处理不如 NETCONF 方便）。</p>
<h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>问：你怎么知道获取接口信息、配置 BGP 的 XML 怎么写？<br>答：参考官方的 NETCONF API 开发手册。华为的可以在官网直接找到，华三的可以<a href="https://download.csdn.net/download/q965844841qq/15849005">点击链接进行下载</a>（官方资料）~</p>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>netconf</tag>
      </tags>
  </entry>
  <entry>
    <title>Python lxml 模块操作 XML 的基本使用</title>
    <url>/posts/fe994980.html</url>
    <content><![CDATA[<p>XML 相关的知识可以在 <a href="https://www.w3school.com.cn/xml/index.asp">w3school</a> 上进行了解。<br>假设你已经对 XML 的基本概念有一些了解，本文介绍了 Python lxml 模块对 XML 的一些操作方法。</p>
<blockquote>
<p>lxml is the most feature-rich and easy-to-use library for processing XML and HTML in the Python language.</p>
</blockquote>
<p>文中所有代码块都是基于 <code>etree</code> 来操作的，代码同一行后的注释为运行结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="Element-类"><a href="#Element-类" class="headerlink" title="Element 类"></a>Element 类</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个元素（初始化类）</span></span><br><span class="line">root = etree.Element(<span class="string">&quot;ROOT&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(root.tag)     <span class="comment"># ROOT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 append() 方法添加子元素</span></span><br><span class="line">root.append(etree.Element(<span class="string">&quot;child1&quot;</span>))</span><br><span class="line"><span class="comment"># 使用 SubElement 方式添加子元素，需要将父元素传入</span></span><br><span class="line">child2 = etree.SubElement(root,<span class="string">&quot;child2&quot;</span>)</span><br><span class="line">child3 = etree.SubElement(root,<span class="string">&quot;child3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 tostring 方法查看创建的 xml，这里注意输出的是二进制</span></span><br><span class="line"><span class="built_in">print</span>(etree.tostring(root))     <span class="comment"># b&#x27;&lt;ROOT&gt;&lt;child1/&gt;&lt;child2/&gt;&lt;child3/&gt;&lt;/ROOT&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(root))               <span class="comment"># &lt;class &#x27;lxml.etree._Element&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Element-类可以作为列表来操作"><a href="#Element-类可以作为列表来操作" class="headerlink" title="Element 类可以作为列表来操作"></a>Element 类可以作为列表来操作</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上节代码块</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(root))    <span class="comment"># 3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> root:</span><br><span class="line">    <span class="built_in">print</span>(i.tag)    <span class="comment"># child1 child2 child3</span></span><br></pre></td></tr></table></figure>

<h2 id="Element-类可以使用字典来携带属性"><a href="#Element-类可以使用字典来携带属性" class="headerlink" title="Element 类可以使用字典来携带属性"></a>Element 类可以使用字典来携带属性</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上节代码块</span></span><br><span class="line">root = etree.Element(<span class="string">&quot;ROOT&quot;</span>,test1=<span class="string">&quot;18&quot;</span>,test2=<span class="string">&quot;test2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(etree.tostring(root))     <span class="comment"># b&#x27;&lt;ROOT test1=&quot;18&quot; test2=&quot;test2&quot;/&gt;&#x27;</span></span><br><span class="line"><span class="comment"># 获取属性的值</span></span><br><span class="line"><span class="built_in">print</span>(root.get(<span class="string">&quot;test1&quot;</span>))        <span class="comment"># 18</span></span><br><span class="line"><span class="comment"># 取所有属性、所有值，返回值都是列表</span></span><br><span class="line"><span class="built_in">print</span>(root.keys(),root.values())    <span class="comment"># [&#x27;test1&#x27;, &#x27;test2&#x27;] [&#x27;18&#x27;, &#x27;test2&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="给-Element-写入值"><a href="#给-Element-写入值" class="headerlink" title="给 Element 写入值"></a>给 Element 写入值</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接上节代码块</span></span><br><span class="line"><span class="comment"># 使用 .text 为元素写入值</span></span><br><span class="line">root.text = <span class="string">&quot;TEXT&quot;</span></span><br><span class="line"><span class="built_in">print</span>(root.text)                <span class="comment"># TEXT</span></span><br><span class="line"><span class="built_in">print</span>(etree.tostring(root))     <span class="comment"># b&#x27;&lt;ROOT test1=&quot;18&quot; test2=&quot;test2&quot;&gt;TEXT&lt;/ROOT&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Tree 迭代来添加元素并赋值</span></span><br><span class="line">root = etree.Element(<span class="string">&quot;root&quot;</span>)    </span><br><span class="line">etree.SubElement(root, <span class="string">&quot;child&quot;</span>).text = <span class="string">&quot;Child 1&quot;</span></span><br><span class="line">etree.SubElement(root, <span class="string">&quot;child&quot;</span>).text = <span class="string">&quot;Child 2&quot;</span></span><br><span class="line">etree.SubElement(root, <span class="string">&quot;another&quot;</span>).text = <span class="string">&quot;Child 3&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-XPATH-来查找值"><a href="#使用-XPATH-来查找值" class="headerlink" title="使用 XPATH 来查找值"></a>使用 XPATH 来查找值</h2><p><a href="https://www.w3school.com.cn/xpath/xpath_syntax.asp">w3school XPATH 语法</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(root.xpath(<span class="string">&quot;string()&quot;</span>))   <span class="comment"># Child 1Child 2Child 3</span></span><br><span class="line"><span class="built_in">print</span>(root.xpath(<span class="string">&quot;//text()&quot;</span>))   <span class="comment"># [&#x27;Child 1&#x27;, &#x27;Child 2&#x27;, &#x27;Child 3&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>把字符串转换为 Element 对象</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个定义了 H3C 接口信息的 xml 文本格式</span></span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;&lt;top&gt;</span></span><br><span class="line"><span class="string">&lt;Ifmgr&gt;</span></span><br><span class="line"><span class="string">&lt;Interfaces&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;</span></span><br><span class="line"><span class="string">&lt;Name&gt;&lt;/Name&gt;</span></span><br><span class="line"><span class="string">&lt;AdminStatus&gt;&lt;/AdminStatus&gt;</span></span><br><span class="line"><span class="string">&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;/Interfaces&gt;</span></span><br><span class="line"><span class="string">&lt;/Ifmgr&gt;</span></span><br><span class="line"><span class="string">&lt;/top&gt;&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 将其转换为 Element 对象</span></span><br><span class="line"><span class="comment"># 第一种方法</span></span><br><span class="line">data = etree.XML(xml)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))       <span class="comment"># &lt;class &#x27;lxml.etree._Element&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 第二种方法</span></span><br><span class="line">data = etree.fromstring(xml)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br></pre></td></tr></table></figure>

<h2 id="Namaspaces（命名空间）"><a href="#Namaspaces（命名空间）" class="headerlink" title="Namaspaces（命名空间）"></a>Namaspaces（命名空间）</h2><p>在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。<a href="https://www.w3school.com.cn/xml/xml_namespaces.asp">w3school 命名空间</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个 top 的 Element，它属于私有命名空间</span></span><br><span class="line">root = etree.Element(<span class="string">&quot;&#123;http://www.h3c.com/netconf/data:1.0&#125;top&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(etree.tostring(root))     <span class="comment"># b&#x27;&lt;ns0:top xmlns:ns0=&quot;http://www.h3c.com/netconf/data:1.0&quot;/&gt;&#x27;</span></span><br><span class="line"><span class="comment"># 为了保证属于同一个命名空间，每次添加子元素时，都要写上命名空间的前缀，否则就会不识别，但是这种方式很繁琐且低效</span></span><br><span class="line">Ifmgr = etree.SubElement(root, <span class="string">&quot;&#123;http://www.h3c.com/netconf/data:1.0&#125;Ifmgr&quot;</span>)</span><br><span class="line">Ifmgr.text = <span class="string">&quot;G0/0&quot;</span></span><br><span class="line"><span class="built_in">print</span>(etree.tostring(root))     <span class="comment"># b&#x27;&lt;ns0:top xmlns:ns0=&quot;http://www.h3c.com/netconf/data:1.0&quot;&gt;&lt;ns0:Ifmgr&gt;G0/0&lt;/ns0:Ifmgr&gt;&lt;/ns0:top&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Element 工厂函数定义默认的命名空间</span></span><br><span class="line">H3C_DATA_1_0 = <span class="string">&quot;http://www.h3c.com/netconf/data:1.0&quot;</span></span><br><span class="line">FULL_NS = <span class="string">&quot;&#123;%s&#125;&quot;</span> %H3C_DATA_1_0</span><br><span class="line"><span class="comment"># 定义了默认的命名空间后，子元素里面可以不显示前缀（None）</span></span><br><span class="line">root = etree.Element(FULL_NS + <span class="string">&quot;top&quot;</span>, nsmap=&#123;<span class="literal">None</span>:H3C_DATA_1_0&#125;)</span><br><span class="line">Ifmgr = etree.SubElement(root, <span class="string">&quot;Ifmgr&quot;</span>)</span><br><span class="line">Ifmgr.text = <span class="string">&quot;G0/0&quot;</span></span><br><span class="line"><span class="comment"># 这样定义后，显示结果就很清爽</span></span><br><span class="line"><span class="built_in">print</span>(etree.tostring(root))     <span class="comment"># b&#x27;&lt;top xmlns=&quot;http://www.h3c.com/netconf/data:1.0&quot;&gt;&lt;Ifmgr&gt;G0/0&lt;/Ifmgr&gt;&lt;/top&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-E-factory-替代-Element-和-SubElement-来快速生成-xml"><a href="#使用-E-factory-替代-Element-和-SubElement-来快速生成-xml" class="headerlink" title="使用 E-factory 替代 Element 和 SubElement 来快速生成 xml"></a>使用 E-factory 替代 Element 和 SubElement 来快速生成 xml</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.builder <span class="keyword">import</span> ElementMaker</span><br><span class="line"><span class="comment"># 设置默认命名空间</span></span><br><span class="line">E = ElementMaker(namespace=H3C_DATA_1_0,nsmap=&#123;<span class="literal">None</span>:H3C_DATA_1_0&#125;)</span><br><span class="line"><span class="comment"># 通过嵌套方式来快速生成 XML</span></span><br><span class="line">top = E.top(</span><br><span class="line">    E.Ifmgr(</span><br><span class="line">        E.Interfaces(</span><br><span class="line">            E.Interface()</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(etree.tostring(top))  <span class="comment"># b&#x27;&lt;top xmlns=&quot;http://www.h3c.com/netconf/data:1.0&quot;&gt;&lt;Ifmgr&gt;&lt;Interfaces&gt;&lt;Interface/&gt;&lt;/Interfaces&gt;&lt;/Ifmgr&gt;&lt;/top&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="ElementPath-查找元素"><a href="#ElementPath-查找元素" class="headerlink" title="ElementPath 查找元素"></a>ElementPath 查找元素</h2><p>提供四种查找方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find()      # 返回第一个匹配项，未找到则返回 None</span><br><span class="line">findtext()  # 返回第一个匹配项的 text</span><br><span class="line">findall()   # 返回所有匹配项列表</span><br><span class="line">iterfind()  # 返回所有匹配项的迭代器</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个精简过的使用 netconf 协议从网络设备上拉取的接口信息</span></span><br><span class="line">ret_no_ns = <span class="string">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;rpc-reply&gt;</span></span><br><span class="line"><span class="string">&lt;data&gt;</span></span><br><span class="line"><span class="string">&lt;top&gt;</span></span><br><span class="line"><span class="string">&lt;Ifmgr&gt;</span></span><br><span class="line"><span class="string">&lt;Interfaces&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;&lt;IfIndex&gt;1&lt;/IfIndex&gt;&lt;Name&gt;GigabitEthernet0/0&lt;/Name&gt;&lt;AdminStatus&gt;1&lt;/AdminStatus&gt;&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;&lt;IfIndex&gt;2&lt;/IfIndex&gt;&lt;Name&gt;GigabitEthernet0/1&lt;/Name&gt;&lt;AdminStatus&gt;1&lt;/AdminStatus&gt;&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;&lt;IfIndex&gt;129&lt;/IfIndex&gt;&lt;Name&gt;NULL0&lt;/Name&gt;&lt;AdminStatus&gt;1&lt;/AdminStatus&gt;&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;&lt;IfIndex&gt;130&lt;/IfIndex&gt;&lt;Name&gt;InLoopBack0&lt;/Name&gt;&lt;AdminStatus&gt;1&lt;/AdminStatus&gt;&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;/Interfaces&gt;&lt;/Ifmgr&gt;&lt;/top&gt;&lt;/data&gt;&lt;/rpc-reply&gt;&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 先将结果转化为 Element，注意转码</span></span><br><span class="line">ret = etree.XML(ret_no_ns.encode())</span><br><span class="line"><span class="comment"># 四种查找方法的基本使用方法</span></span><br><span class="line"><span class="comment"># 只能查找子元素</span></span><br><span class="line"><span class="built_in">print</span>(ret.find(<span class="string">&quot;data&quot;</span>))         <span class="comment"># &lt;Element data at 0x7efcee610680&gt;</span></span><br><span class="line"><span class="built_in">print</span>(ret.find(<span class="string">&quot;data&quot;</span>).tag)     <span class="comment"># data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在任意位置查找元素，并取 tag</span></span><br><span class="line"><span class="built_in">print</span>(ret.find(<span class="string">&quot;.//Name&quot;</span>).tag) <span class="comment"># Name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在任意位置查找元素并取 text，两种方法相同</span></span><br><span class="line"><span class="built_in">print</span>(ret.findtext(<span class="string">&quot;.//Name&quot;</span>))  <span class="comment"># GigabitEthernet0/0</span></span><br><span class="line"><span class="built_in">print</span>(ret.find(<span class="string">&quot;.//Name&quot;</span>).text) <span class="comment"># GigabitEthernet0/0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回所有匹配项，列表</span></span><br><span class="line"><span class="built_in">print</span>(ret.findall(<span class="string">&quot;.//Name&quot;</span>))   <span class="comment"># [&lt;Element Name at 0x7f6cd2d1c900&gt;,..., &lt;Element Name at 0x7f6cd2d1ca00&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回所有匹配项，迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ret.iterfind(<span class="string">&quot;../Name&quot;</span>)))    <span class="comment"># &lt;class &#x27;generator&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是实际返回内容，其中带有命名空间</span></span><br><span class="line">ret = <span class="string">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;rpc-reply xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot; message-id=&quot;urn:uuid:c94f3285-d747-4e19-abd3-efbe281e3133&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;data&gt;</span></span><br><span class="line"><span class="string">&lt;top xmlns=&quot;http://www.h3c.com/netconf/data:1.0&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;Ifmgr&gt;</span></span><br><span class="line"><span class="string">&lt;Interfaces&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;&lt;IfIndex&gt;1&lt;/IfIndex&gt;&lt;Name&gt;GigabitEthernet0/0&lt;/Name&gt;&lt;AdminStatus&gt;1&lt;/AdminStatus&gt;&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;&lt;IfIndex&gt;2&lt;/IfIndex&gt;&lt;Name&gt;GigabitEthernet0/1&lt;/Name&gt;&lt;AdminStatus&gt;1&lt;/AdminStatus&gt;&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;&lt;IfIndex&gt;129&lt;/IfIndex&gt;&lt;Name&gt;NULL0&lt;/Name&gt;&lt;AdminStatus&gt;1&lt;/AdminStatus&gt;&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;Interface&gt;&lt;IfIndex&gt;130&lt;/IfIndex&gt;&lt;Name&gt;InLoopBack0&lt;/Name&gt;&lt;AdminStatus&gt;1&lt;/AdminStatus&gt;&lt;/Interface&gt;</span></span><br><span class="line"><span class="string">&lt;/Interfaces&gt;&lt;/Ifmgr&gt;&lt;/top&gt;&lt;/data&gt;&lt;/rpc-reply&gt;&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 先转化为 Element</span></span><br><span class="line">ret = etree.fromstring(ret.encode())</span><br><span class="line"><span class="comment"># 查找命名空间下的所有 Name 元素，即设备的接口名称列表</span></span><br><span class="line">data = ret.findall(<span class="string">&#x27;.//&#123;http://www.h3c.com/netconf/data:1.0&#125;Name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取值</span></span><br><span class="line">IfList = [i.text <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line"><span class="comment"># 从 xml 文件中解析到了具体的接口信息</span></span><br><span class="line"><span class="built_in">print</span>(IfList)       <span class="comment"># [&#x27;GigabitEthernet0/0&#x27;, &#x27;GigabitEthernet0/1&#x27;, &#x27;NULL0&#x27;, &#x27;InLoopBack0&#x27;]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>netconf</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Netmiko进行交互式操作</title>
    <url>/posts/cf2c01e8.html</url>
    <content><![CDATA[<p>Netmiko 的 <code>send_command</code> 方法可以很方便的在网络设备上执行命令，如各种 show、发送一些基本配置等；但是如果是交互式的操作，例如拷贝文件、升级系统等需要人工确认的操作，貌似就有点不行了。</p>
<p>其实 <code>send_command</code> 方法提供了这个功能，从它的参数中可以看到，有一个<code>expect_string</code>参数，可以通过这个参数来进行交互式操作。</p>
<p>这个参数就是表面意思： <code>期望字符串</code>，实际使用中，这里需要传入一个<b><font color=red>正则表达式</font></b>，然后 Netmiko 会从返回的文本中搜索该字符串，找到之后即为执行结束，关闭连接。</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># send_command 方法支持的所有参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_command</span></span><br><span class="line">(self, command_string, expect_string=<span class="literal">None</span>, delay_factor=<span class="number">1</span>, max_loops=<span class="number">500</span>, auto_find_prompt=<span class="literal">True</span>, strip_prompt=<span class="literal">True</span>, strip_command=<span class="literal">True</span>, normalize=<span class="literal">True</span>, use_textfsm=<span class="literal">False</span>, textfsm_template=<span class="literal">None</span>, use_ttp=<span class="literal">False</span>, ttp_template=<span class="literal">None</span>, use_genie=<span class="literal">False</span>, cmd_verify=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="copy-文件"><a href="#copy-文件" class="headerlink" title="copy 文件"></a>copy 文件</h2><p>当我们从设备上进行拷贝文件时，设备会提示输入<code>Y/N</code> 进行确认：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20210204212114437.png"></p>
<p>此时如果使用  Netmiko，就需要让脚本来自己确认操作，来实验一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler <span class="keyword">as</span> ch</span><br><span class="line">host = &#123;</span><br><span class="line">    <span class="string">&#x27;device_type&#x27;</span>: <span class="string">&#x27;hp_comware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line">cmd = <span class="string">&#x27;copy http://192.168.56.1:9212/vlan.cfg flash:/&#x27;</span></span><br><span class="line">conn = ch(**host)</span><br><span class="line"><span class="comment"># 这里要注意使用原始字符串，并对正则表达式中的元字符进行转义</span></span><br><span class="line">output = send_command(cmd. expect_string=<span class="string">r&#x27;\[Y/N\]:&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果如下，可以看到 netmiko 检测到指定的字符后，就退出了执行。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20210204214226613.png"></p>
<p>执行到这里后，我们可以继续发送一个 <code>Y</code> 来进行操作，并对输出进行拼接。<br>这里需要注意一点：<br><font color=red>同一个SSH连接中，如果定义了<code>expect_string</code>，那么后续发送命令时，仍然检测该字符串。</font><br>所以，第二次发送命令<code>Y</code>时，就需要根据实际情况把检测字符串改回来，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">output = conn.send_command(cmd, expect_string=<span class="string">r&#x27;\[Y/N\]:&#x27;</span>)</span><br><span class="line">output += conn.send_command(<span class="string">&#x27;Y&#x27;</span>, expect_string=<span class="string">r&#x27;&gt;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2021020422092961.png"></p>
<p>设备上可以查看到这个文件：<br><img data-src="https://img-blog.csdnimg.cn/20210204220951868.png"></p>
<p>一个问题：<br>当传输文件到设备上时，可能会碰到文件名冲突的情况，设备检测到冲突文件后，还会再提示让输入<code>Y/N</code> 确认是否进行覆盖。</p>
<p>这时，可以先用 <code>dir</code>命令，根据返回文本判断是否存在文件，或者直接覆盖等。具体的就根据实际需求来了~</p>
<p>如果是从设备上传输文件到服务器（让设备主动上传配置文件到服务器上），如果存在文件名冲突，则会直接传输失败。（仅针对 H3C 设备）</p>
<h2 id="升级系统"><a href="#升级系统" class="headerlink" title="升级系统"></a>升级系统</h2><p>上文中介绍了如何使用 Netmiko copy 文件，当工作中进行批量升级系统时，就可以预先通过这种方式将系统升级文件传到设备上。</p>
<p>在之前文章中提到过：<code>send_command</code> 检测提示符的超时时间大约为 100 秒，而系统文件一般情况下都比较大，传送时间可能会超过 100 秒，进而导致传输中断。</p>
<p>遇到这种情况时，就可以使用<code>delay_factor</code>参数来增加等待的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">output = conn.send_command(cmd, expect_string=<span class="string">r&#x27;\[Y/N\]:&#x27;</span>)</span><br><span class="line">output += conn.send_command(<span class="string">&#x27;Y&#x27;</span>, expect_string=<span class="string">r&#x27;&gt;&#x27;</span>, delay_factor=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><code>delay_factor</code> 的取值 可根据具体的网络情况等因素进行设置，最好预留时间多一点，因为最终 netmiko 检测到预期的提示符后也会退出。</p>
<p>当把系统传输到设备后，可以继续使用 <code>expect_string</code> 进行后续的一系列交互操作，例如设置启动文件、重启设备等，具体细节就需要根据使用场景来进行完善。</p>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>netmiko</tag>
      </tags>
  </entry>
  <entry>
    <title>Netmiko 常用方法</title>
    <url>/posts/f1ca3608.html</url>
    <content><![CDATA[<p>之前文章中，介绍了 Netmiko 中 <code>send_command</code> 和 <code>send_config_set</code> 两个方法以及区别。<br>本篇内容来介绍一下 Netmiko 的常用方法以及应用场景。</p>
<h2 id="命令执行相关"><a href="#命令执行相关" class="headerlink" title="命令执行相关"></a>命令执行相关</h2><h3 id="def-send-command-timing"><a href="#def-send-command-timing" class="headerlink" title="def send_command_timing():"></a>def send_command_timing():</h3><p>基于时间延迟来执行命令。<br>如果通过这个方法登录到设备执行命令，不管命令有没有执行完成，Netmiko 都会在指定的时间内结束 SSH 连接，一般不推荐使用。</p>
<p>这里可以对比一下<code>send_command</code>，这个方法会检测设备的提示符，例如<code>&gt;</code>、<code>]</code>、<code>#</code> 等，它会一直等待接收数据，直到检测到提示符后再进行退出（也有一个默认的超时时间）。</p>
<p>我们可以通过<code>delay_factor</code>和<code>max_loops</code>来控制等待时间。</p>
<ul>
<li>send_command_timing：默认超时时间约为 15 秒，即登录设备 15 秒后关闭 SSH 连接</li>
<li>send_command：默认超时时间约为 100 秒，即 100 秒未检测到提示符就关闭 SSH 连接</li>
</ul>
<span id="more"></span>

<h3 id="def-send-config-from-file"><a href="#def-send-config-from-file" class="headerlink" title="def send_config_from_file():"></a>def send_config_from_file():</h3><p>读取一个配置文件，然后将配置文件发送到设备上。</p>
<p>这个方法的本质是和<code>send_config_set</code>是一样的，只不过程序帮我们读取了配置而不用再在脚本中输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体的实现方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_config_from_file</span>(<span class="params">self, config_file=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">    <span class="keyword">with</span> io.<span class="built_in">open</span>(config_file, <span class="string">&quot;rt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> cfg_file:</span><br><span class="line">    <span class="keyword">return</span> self.send_config_set(cfg_file, **kwargs)</span><br></pre></td></tr></table></figure>

<h2 id="操作模式相关"><a href="#操作模式相关" class="headerlink" title="操作模式相关"></a>操作模式相关</h2><p>Netmiko 中，模式相关的方法后端都是通过根据不同的设备发送相应的命令来实现；检查模式时是通过正则表达式匹配来实现。</p>
<h3 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h3><p>进入 <code>enable</code> 模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体实现方式，思科设备为例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enable</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    cmd=<span class="string">&quot;enable&quot;</span>,</span></span><br><span class="line"><span class="params">    pattern=<span class="string">&quot;ssword&quot;</span>,</span></span><br><span class="line"><span class="params">    enable_pattern=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    re_flags=re.IGNORECASE,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Enter enable mode.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().enable(</span><br><span class="line">        cmd=cmd, pattern=pattern, enable_pattern=enable_pattern, re_flags=re_flags</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h3 id="config-mode"><a href="#config-mode" class="headerlink" title="config_mode"></a>config_mode</h3><p>进入 <code>config</code> 模式。</p>
<h3 id="check-config-mode"><a href="#check-config-mode" class="headerlink" title="check_config_mode"></a>check_config_mode</h3><p>检查是否处于<code>config</code>模式，返回结果为 True &#x2F; False</p>
<h3 id="check-enable-mode"><a href="#check-enable-mode" class="headerlink" title="check_enable_mode"></a>check_enable_mode</h3><p>检查是否处于<code>enable</code>模式，返回结果为 True &#x2F; False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具体实现方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_enable_mode</span>(<span class="params">self, check_string=<span class="string">&quot;#&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Check if in enable mode. Return boolean.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().check_enable_mode(check_string=check_string)</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="def-is-alive"><a href="#def-is-alive" class="headerlink" title="def is_alive():"></a>def is_alive():</h3><p>通过向 SSH 隧道发送空字符串，来判定是否连接仍然正常，返回结果为 True &#x2F; False 。</p>
<h2 id="附录：Netmiko-中所有可以调用的方法"><a href="#附录：Netmiko-中所有可以调用的方法" class="headerlink" title="附录：Netmiko 中所有可以调用的方法"></a>附录：Netmiko 中所有可以调用的方法</h2><p>Netmiko 中所有的网络设备的类都是基于<code>BaseConnection</code>类来实现的，通过查看该类来浏览所有方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _ 开头的为私有方法，以下只查看外部可以直接使用的方法</span></span><br><span class="line"><span class="keyword">from</span> netmiko.base_connection <span class="keyword">import</span> BaseConnection</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(BaseConnection):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> i.startswith(<span class="string">&#x27;_&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check_config_mode</span><br><span class="line">check_enable_mode</span><br><span class="line">cleanup</span><br><span class="line">clear_buffer</span><br><span class="line">close_session_log</span><br><span class="line">commit</span><br><span class="line">config_mode</span><br><span class="line">disable_paging</span><br><span class="line">disconnect</span><br><span class="line">enable</span><br><span class="line">establish_connection</span><br><span class="line">exit_config_mode</span><br><span class="line">exit_enable_mode</span><br><span class="line">find_prompt</span><br><span class="line">is_alive</span><br><span class="line">normalize_cmd</span><br><span class="line">normalize_linefeeds</span><br><span class="line">open_session_log</span><br><span class="line">paramiko_cleanup</span><br><span class="line">read_channel</span><br><span class="line">read_until_pattern</span><br><span class="line">read_until_prompt</span><br><span class="line">read_until_prompt_or_pattern</span><br><span class="line">save_config</span><br><span class="line">select_delay_factor</span><br><span class="line">send_command</span><br><span class="line">send_command_expect</span><br><span class="line">send_command_timing</span><br><span class="line">send_config_from_file</span><br><span class="line">send_config_set</span><br><span class="line">serial_login</span><br><span class="line">session_preparation</span><br><span class="line">set_base_prompt</span><br><span class="line">set_terminal_width</span><br><span class="line">special_login_handler</span><br><span class="line">strip_ansi_escape_codes</span><br><span class="line">strip_backspaces</span><br><span class="line">strip_command</span><br><span class="line">strip_prompt</span><br><span class="line">telnet_login</span><br><span class="line">write_channel</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>netmiko</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 使用 Netmiko 连接 H3C 网络设备</title>
    <url>/posts/26e9de3c.html</url>
    <content><![CDATA[<h2 id="什么是-Netmiko"><a href="#什么是-Netmiko" class="headerlink" title="什么是 Netmiko"></a>什么是 Netmiko</h2><p>是一个基于 <code>paramiko</code> 二次封装的，可以通过 SSH 连接多种网络设备的库，从 3.0 版本以来，加入了对国内厂商的支持，是非常不错的网络自动化工具。</p>
<p>目前支持设备几乎覆盖了市面上大部分设备，包括锐捷、华三、华为、思科、f5 等等，具体的列表见后文。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先需要具备<code>Python3.6</code>以上版本的环境，使用<code>pip</code>可以直接安装。<br>国内下载速度很慢，可以参考<a href="/posts/8a28e619.html" title="Python 下载加速：pip pypi 使用国内源及永久配置 pip 源">Python 下载加速：pip pypi 使用国内源及永久配置 pip 源</a>进行配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install netmiko</span><br></pre></td></tr></table></figure>
<p>出现 <code>Successfully installed netmiko</code> 即为安装成功。</p>
<span id="more"></span>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>实验环境：Windows 10， Python 3.8 ，HCL 2.1.2<br><img data-src="https://img-blog.csdnimg.cn/20210202233522873.png" alt="image-20210723205944076"></p>
<h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入处理连接</span></span><br><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler <span class="keyword">as</span> ch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过字典方式定义设备登录信息</span></span><br><span class="line">host = &#123;</span><br><span class="line">    <span class="string">&#x27;device_type&#x27;</span>: <span class="string">&#x27;hp_comware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="string">&#x27;secret&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment"># enable密码，没有可以不写这行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 连接设备，conn 可以理解为一个已经连接到设备上的终端，此时可以直接执行命令</span></span><br><span class="line">conn = ch(**host)</span><br><span class="line"><span class="comment"># 通过 send_command 方法执行命令，查看接口信息，返回值是字符串</span></span><br><span class="line">output = conn.send_command(<span class="string">&#x27;display ip int brief&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
<p>以下为输出信息，可以看到已经从设备上采集到了需要的信息<br><img data-src="https://img-blog.csdnimg.cn/20210202234131399.png"></p>
<h3 id="执行多条命令"><a href="#执行多条命令" class="headerlink" title="执行多条命令"></a>执行多条命令</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler <span class="keyword">as</span> ch</span><br><span class="line"><span class="comment"># 通过字典方式定义设备登录信息</span></span><br><span class="line">host = &#123;</span><br><span class="line">    <span class="string">&#x27;device_type&#x27;</span>: <span class="string">&#x27;hp_comware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;192.168.56.20&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;netdevops&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;port&#x27;</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="string">&#x27;secret&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment"># enable密码，没有可以不写这行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 连接设备</span></span><br><span class="line">conn = ch(**host)</span><br><span class="line"><span class="comment"># 定义一个命令列表，比如为G0/1配置一个IP地址</span></span><br><span class="line">commands = [<span class="string">&#x27;int g0/1&#x27;</span>, <span class="string">&#x27;ip add 1.1.1.1 30&#x27;</span>, <span class="string">&#x27;desc netmiko_config&#x27;</span>]</span><br><span class="line"><span class="comment"># 这个时候可以使用 send_config_set 方法执行多条命令</span></span><br><span class="line">output = conn.send_config_set(commands)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
<p>以下为执行后的结果<br><img data-src="https://img-blog.csdnimg.cn/20210202235648781.png"><br>设备上已经配置完成。<br><img data-src="https://img-blog.csdnimg.cn/20210202235806856.png"></p>
<h2 id="登录设备后发生了什么？"><a href="#登录设备后发生了什么？" class="headerlink" title="登录设备后发生了什么？"></a>登录设备后发生了什么？</h2><p>Netmiko 可以通过 SSH 配置网络设备，那么它登录到设备之后，做了什么动作呢？<br>我们可以从网络设备的 LOG 中看到相关信息，以下为本次实验中的一些 LOG：<br><img data-src="https://img-blog.csdnimg.cn/20210203000320590.png"></p>
<h3 id="def-send-command"><a href="#def-send-command" class="headerlink" title="def send_command():"></a>def send_command():</h3><p>从 LOG 的第二部分可以看到，当执行 <code>send_command</code> 方法时，netmiko 先输入了取消分屏的命令 <code>screen-length disable</code> ，在进行了对应的命令，这样在有大量输出时，可以保证输出内容是完整的。</p>
<p>其实不仅是华三设备，Netmiko 对其他设备如思科、华为等都做了适配，登录设备之后，都会先执行对应的取消分屏的命令。</p>
<p><font color=red>所以，这里可以总结一个注意点，即：<br>设备登录使用的用户名需要有执行取消分屏命令的权限（比如 level 0 用户可能无该命令，则无法收集信息）。</font></p>
<h3 id="def-send-config-set"><a href="#def-send-config-set" class="headerlink" title="def send_config_set():"></a>def send_config_set():</h3><p>从 LOG 的第一部分可以看到，当执行<code>send_config_set</code> 方法时，Netmiko 不但输入了取消分屏的命令，还执行了<code>system-view</code>进入了系统视图下，之后才执行了我们输入的命令。</p>
<p>从这个方法的名字 <code>send_config_set</code> 可以看出，Netmiko 认为此时输入的是一系列配置命令，所以直接帮我们进入了系统视图下。</p>
<p>对比其他设备如 Cisco，Netmiko 则会帮我们执行  <code>config terminal</code> 进入配置模式，此时，对于思科设备的 show 命令，则不能批量执行（思科在配置模式下得用 do show 才可以）。</p>
<p>当命令执行完成，Netmiko 帮我们退出了系统视图，之后中断了 SSH 连接。</p>
<p><font color=red>这里第二个注意点：<br>使用 <code>send_config_set</code> 方法时，需要用户具有配置权限。这个方法通常用来配置刷入。</font></p>
<hr>
<h2 id="支持的设备列表"><a href="#支持的设备列表" class="headerlink" title="支持的设备列表"></a>支持的设备列表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a10</span><br><span class="line">accedian</span><br><span class="line">alcatel_aos</span><br><span class="line">alcatel_sros</span><br><span class="line">apresia_aeos</span><br><span class="line">arista_eos</span><br><span class="line">aruba_os</span><br><span class="line">avaya_ers</span><br><span class="line">avaya_vsp</span><br><span class="line">brocade_fastiron</span><br><span class="line">brocade_netiron</span><br><span class="line">brocade_nos</span><br><span class="line">brocade_vdx</span><br><span class="line">brocade_vyos</span><br><span class="line">calix_b6</span><br><span class="line">checkpoint_gaia</span><br><span class="line">ciena_saos</span><br><span class="line">cisco_asa</span><br><span class="line">cisco_ios</span><br><span class="line">cisco_nxos</span><br><span class="line">cisco_s300</span><br><span class="line">cisco_tp</span><br><span class="line">cisco_wlc</span><br><span class="line">cisco_xe</span><br><span class="line">cisco_xr</span><br><span class="line">cloudgenix_ion</span><br><span class="line">coriant</span><br><span class="line">dell_dnos9</span><br><span class="line">dell_force10</span><br><span class="line">dell_isilon</span><br><span class="line">dell_os10</span><br><span class="line">dell_os6</span><br><span class="line">dell_os9</span><br><span class="line">dell_powerconnect</span><br><span class="line">dlink_ds</span><br><span class="line">eltex</span><br><span class="line">eltex_esr</span><br><span class="line">endace</span><br><span class="line">enterasys</span><br><span class="line">extreme</span><br><span class="line">extreme_ers</span><br><span class="line">extreme_exos</span><br><span class="line">extreme_netiron</span><br><span class="line">extreme_nos</span><br><span class="line">extreme_slx</span><br><span class="line">extreme_vdx</span><br><span class="line">extreme_vsp</span><br><span class="line">extreme_wing</span><br><span class="line">f5_linux</span><br><span class="line">f5_ltm</span><br><span class="line">f5_tmsh</span><br><span class="line">flexvnf</span><br><span class="line">fortinet</span><br><span class="line">generic_termserver</span><br><span class="line">hp_comware</span><br><span class="line">hp_procurve</span><br><span class="line">huawei</span><br><span class="line">huawei_olt</span><br><span class="line">huawei_smartax</span><br><span class="line">huawei_vrpv8</span><br><span class="line">ipinfusion_ocnos</span><br><span class="line">juniper</span><br><span class="line">juniper_junos</span><br><span class="line">juniper_screenos</span><br><span class="line">keymile</span><br><span class="line">keymile_nos</span><br><span class="line">linux</span><br><span class="line">mellanox</span><br><span class="line">mellanox_mlnxos</span><br><span class="line">mikrotik_routeros</span><br><span class="line">mikrotik_switchos</span><br><span class="line">mrv_lx</span><br><span class="line">mrv_optiswitch</span><br><span class="line">netapp_cdot</span><br><span class="line">netscaler</span><br><span class="line">nokia_sros</span><br><span class="line">oneaccess_oneos</span><br><span class="line">ovs_linux</span><br><span class="line">paloalto_panos</span><br><span class="line">pluribus</span><br><span class="line">quanta_mesh</span><br><span class="line">rad_etx</span><br><span class="line">ruckus_fastiron</span><br><span class="line">ruijie_os</span><br><span class="line">sophos_sfos</span><br><span class="line">ubiquiti_edge</span><br><span class="line">ubiquiti_edgeswitch</span><br><span class="line">ubiquiti_unifiswitch</span><br><span class="line">vyatta_vyos</span><br><span class="line">vyos</span><br><span class="line">watchguard_fireware</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>netmiko</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 pysnmp 查询 H3C 网络设备示例</title>
    <url>/posts/1aeac5e3.html</url>
    <content><![CDATA[<p><a href="https://pysnmp.readthedocs.io/en/latest/index.html">pysnmp 文档</a>：官方文档，查看该模块所有的使用方法</p>
<p><a href="http://download.h3c.com.cn/download.do?id=5426101">h3c mib 库</a>：华三官方提供的设备 MIB 值</p>
<p><a href="http://www.ireasoning.com/mibbrowser.shtml">mib 浏览器</a>：可以用来查看 MIB OID 节点</p>
<h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul>
<li>Windows 10</li>
<li>python 3.8</li>
<li>pysnmp 4.4.12</li>
<li>HCL</li>
</ul>
<h3 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h3><p><img data-src="http://oss.xdai.vip/md-note/imgs/202111201620531.png" alt="image-20201227184224939"></p>
<span id="more"></span>

<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><h4 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h4><p>路由器开启了 v2c 和 v3 两个版本来进行实验</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"> snmp-agent</span><br><span class="line"> snmp-agent community write simple private</span><br><span class="line"> snmp-agent community read simple public</span><br><span class="line"> snmp-agent sys-info version v2c v3</span><br><span class="line"> snmp-agent group v3 netdevops authentication</span><br><span class="line"> snmp-agent target-host trap address udp-domain 192.168.56.102 params securityname public</span><br><span class="line"> snmp-agent usm-user v3 admin netdevops simple authentication-mode md5 Admin@h3c privacy-mode aes128 Admin@h3c</span><br><span class="line"> snmp-agent trap enable</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 API</span></span><br><span class="line"><span class="keyword">from</span> pysnmp.hlapi <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化引擎</span></span><br><span class="line">engine = SnmpEngine()</span><br><span class="line"><span class="comment"># 选择 SNMP 协议，v1 和 v2c 只用团体字，使用 CommunityData 类实例化</span></span><br><span class="line"><span class="comment"># SNMPv1</span></span><br><span class="line"><span class="comment"># communityData = CommunityData(&#x27;public&#x27;, mpModel=0)</span></span><br><span class="line"><span class="comment"># SNMPv2c</span></span><br><span class="line">communityData = CommunityData(<span class="string">&#x27;public&#x27;</span>, mpModel=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 如果是 v3，则需要用户凭证，使用 UsmUserData 类实例化，认证和加密算法与上面设备配置相对应</span></span><br><span class="line">userData = UsmUserData(</span><br><span class="line">    userName=<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    authKey=<span class="string">&#x27;Admin@h3c&#x27;</span>,</span><br><span class="line">    privKey=<span class="string">&#x27;Admin@h3c&#x27;</span>,</span><br><span class="line">    authProtocol=usmHMACMD5AuthProtocol,</span><br><span class="line">    privProtocol=usmAesCfb128Protocol,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 配置目标主机</span></span><br><span class="line">target = UdpTransportTarget((<span class="string">&#x27;192.168.56.20&#x27;</span>,<span class="number">161</span>))</span><br><span class="line"><span class="comment"># 实例化上下文对象</span></span><br><span class="line">context = ContextData()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getSysName</span>(<span class="params">target</span>):</span><br><span class="line">    <span class="comment"># ObjectIdentity 类负责 MIB 对象的识别。</span></span><br><span class="line">    <span class="comment"># 指定要查询的 OID 对象或名称</span></span><br><span class="line">    sysname = ObjectIdentity(<span class="string">&quot;1.3.6.1.2.1.1.5.0&quot;</span>)</span><br><span class="line">    sysname1 = ObjectIdentity(<span class="string">&#x27;SNMPv2-MIB&#x27;</span>,<span class="string">&#x27;sysName&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 使用 ObjectType 类初始化查询对象</span></span><br><span class="line">    obj1 = ObjectType(sysname)</span><br><span class="line">    <span class="comment"># 使用 getCMD 方法进行查询，返回结果是一个迭代器，需要使用 next() 来取值</span></span><br><span class="line">    <span class="comment"># 传递的参数均为为上面定义的变量，以 v2c 为例（如果是 v3，communityData 替换为 userData）</span></span><br><span class="line">    g = getCmd(engine, communityData, target, context, obj1)</span><br><span class="line">    <span class="comment"># 取值</span></span><br><span class="line">    _, _, _, result = <span class="built_in">next</span>(g)</span><br><span class="line">    <span class="comment"># 打印输出</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getIfaceList</span>(<span class="params">target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这个函数是查询接口列表，和上面查询 sysName 的区别是使用了 nextCmd 来获取一个 MIB 子树的全部内容</span></span><br><span class="line"><span class="string">    主要是 `lexicographicMode=False` 参数，默认为 `True`，会一直查询到 MIB 树结束。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 接口列表的 OID 值</span></span><br><span class="line">    ifaceListOid = ObjectType(ObjectIdentity(<span class="string">&#x27;1.3.6.1.2.1.2.2.1.2&#x27;</span>))</span><br><span class="line">    g = nextCmd(engine,userData,target,context,ifaceListOid,lexicographicMode=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 手动迭代并输出内容，并进行迭代器终止的判断</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            errorIndication, errorStatus, errorIndex, varBinds = <span class="built_in">next</span>(g)</span><br><span class="line">            <span class="keyword">for</span> iface <span class="keyword">in</span> varBinds:</span><br><span class="line">                <span class="built_in">print</span>(iface)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Get interface list done.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">getSysName(target)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;============================&#x27;</span>)</span><br><span class="line">getIfaceList(target)</span><br></pre></td></tr></table></figure>

<p>上述代码输出内容如下，可以根据实际需求，对函数的返回内容进行处理，为方便实验，都使用了 <code>print</code> 来查看结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">PS C:\python\netdevops&gt; python &quot;c:\python\netdevops\pysnmp_demo.py&quot;</span><br><span class="line">SNMPv2-MIB::sysName.0 = R1</span><br><span class="line">============================</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.1 = GigabitEthernet0/0</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.2 = GigabitEthernet0/1</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.3 = GigabitEthernet0/2</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.4 = Serial1/0</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.5 = Serial2/0</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.6 = Serial3/0</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.7 = Serial4/0</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.8 = GigabitEthernet5/0</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.9 = GigabitEthernet5/1</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.10 = GigabitEthernet6/0</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.11 = GigabitEthernet6/1</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.129 = NULL0</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.130 = InLoopBack0</span><br><span class="line">SNMPv2-SMI::mib-2.2.2.1.2.131 = Register-Tunnel0</span><br><span class="line">Get interface list done.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>paramiko 使用证书免密连接 H3C 设备</title>
    <url>/posts/acfac2f9.html</url>
    <content><![CDATA[<h2 id="设备配置用户"><a href="#设备配置用户" class="headerlink" title="设备配置用户"></a>设备配置用户</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">local-user admin class manage</span><br><span class="line"> password simple admin</span><br><span class="line"> service-type ftp</span><br><span class="line"> service-type ssh</span><br><span class="line"> authorization-attribute user-role network-admin</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>配置登录 vty 登录权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">line vty 0 63</span><br><span class="line"> authentication-mode scheme</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>开启 ssh 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh erver enable</span><br></pre></td></tr></table></figure>

<p>开启 ftp 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ftp server enable</span><br></pre></td></tr></table></figure>



<h2 id="在-windows-上生成-ssh-key"><a href="#在-windows-上生成-ssh-key" class="headerlink" title="在 windows 上生成 ssh key"></a>在 windows 上生成 ssh key</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\xdai&gt; ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (C:\Users\xdai/.ssh/id_rsa):</span><br><span class="line">C:\Users\xdai/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in C:\Users\xdai/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in C:\Users\xdai/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:Dfia7aLwhuSowN7iSsXlqkB0/ZJw2mMoMVi9Y4ez06E xdai@xdai</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|  ..             |</span><br><span class="line">|..  o  .         |</span><br><span class="line">|.+ o *. .        |</span><br><span class="line">|. = # =. o       |</span><br><span class="line">| o * # oS .      |</span><br><span class="line">|o + E ++         |</span><br><span class="line">|o*.o .o .        |</span><br><span class="line">|*.=o. ..         |</span><br><span class="line">|*+.oo. ..        |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line">PS C:\Users\xdai&gt;</span><br></pre></td></tr></table></figure>

<p>在 windows 上将公钥通过 ftp 上传到设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\xdai\.ssh&gt;ftp 192.168.56.20</span><br><span class="line">连接到 192.168.56.20。</span><br><span class="line">220 FTP service ready.</span><br><span class="line">502 Command not implemented.</span><br><span class="line">用户(192.168.56.20:(none)): admin</span><br><span class="line">331 Password required for admin.</span><br><span class="line">密码:</span><br><span class="line">230 User logged in.</span><br><span class="line">ftp&gt; put id_rsa.pub</span><br><span class="line">200 PORT command successful</span><br><span class="line">150 Connecting to port 11865</span><br><span class="line">226 File successfully transferred</span><br><span class="line">ftp: 发送 392 字节，用时 0.00秒 392.00千字节/秒。</span><br><span class="line">ftp&gt; quit</span><br><span class="line">221-Goodbye. You uploaded 1 and downloaded 0 kbytes.</span><br><span class="line">221 Logout.</span><br></pre></td></tr></table></figure>

<p>可以在 R1 上看到已经接收到了公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;R1&gt;%Dec 26 15:05:41:190 2020 R1 FTP/6/AUTH: User N/A@192.168.56.102 for connection.</span><br><span class="line">%Dec 26 15:05:44:437 2020 R1 FTP/6/AUTH: User admin@192.168.56.102 login.</span><br><span class="line">%Dec 26 15:05:53:983 2020 R1 FTP/5/OPER: User admin@192.168.56.102 uploaded flash:/id_rsa.pub.</span><br><span class="line">%Dec 26 15:06:17:204 2020 R1 FTP/6/LOGOUT: User admin@192.168.56.102 logout.</span><br><span class="line">&lt;R1&gt;dir</span><br><span class="line">Directory of flash:</span><br><span class="line">   0 drw-           - Dec 26 2020 14:56:17   diagfile</span><br><span class="line">   1 -rw-         735 Dec 26 2020 14:57:27   hostkey</span><br><span class="line">   2 -rw-         391 Dec 26 2020 15:05:53   id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>在 R1 上导入远端主机公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public-key peer netdevops import sshkey flash:/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>查看已经导入的公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[R1] display public-key peer</span><br><span class="line"></span><br><span class="line">=============================================</span><br><span class="line">Key name: netdevops</span><br><span class="line">Key type: RSA</span><br><span class="line">Key modulus: 2048</span><br><span class="line">Key code:</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置远端主机公钥的方式有两种：</p>
<ul>
<li><p>从公钥文件中导入：用户事先将远端主机的公钥文件保存到本地设备（例如，通过FTP或TFTP，以二进制方式将远端主机的公钥文件保存到本地设备），本地设备从该公钥文件中导入远端主机的公钥。导入公钥时，系统会自动将远端主机的公钥文件转换为PKCS（Public Key Cryptography Standards，公共密钥加密标准）编码形式。</p>
</li>
<li><p>手工配置：用户事先在远端主机上查看其公钥信息，并记录远端主机公钥的内容。在本地设备上采用手工输入的方式将远端主机的公钥配置到本地。手工输入远端主机公钥时，可以逐个字符输入，也可以一次拷贝粘贴多个字符。</p>
</li>
</ul>
<p>因为当前版本设备不支持直接输入 rsa 公钥，所以采用导入文件的方式。</p>
</blockquote>
<p>R1 上为 ssh 用户配置公钥验证方式，指定公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user admin service-type all authentication-type any assign publickey netdevops</span><br></pre></td></tr></table></figure>

<blockquote>
<p>authentication-type 可选项有 any、password、password-publickey、publickey</p>
</blockquote>
<p>设备配置已经完成</p>
<h2 id="在-windows-中编写代码"><a href="#在-windows-中编写代码" class="headerlink" title="在 windows 中编写代码"></a>在 windows 中编写代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh.load_system_host_keys()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.client.AutoAddPolicy())</span><br><span class="line">ssh.connect(</span><br><span class="line">    hostname=<span class="string">&#x27;192.168.56.20&#x27;</span>,</span><br><span class="line">    username=<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">)</span><br><span class="line">stdin, stdout,  stderr = ssh.exec_command(<span class="string">&#x27;dis ip int brief&#x27;</span>)</span><br><span class="line">interface = stdout.read().decode(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(interface)</span><br><span class="line">ssh.close()</span><br></pre></td></tr></table></figure>

<p>运行之后可以看到输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\python\netdevops&gt; &amp; &quot;C:/Program Files (x86)/Python38-32/python.exe&quot; c:/python/netdevops/1.py</span><br><span class="line"></span><br><span class="line">******************************************************************************</span><br><span class="line">* Copyright (c) 2004-2017 New H3C Technologies Co., Ltd. All rights reserved.*</span><br><span class="line">* Without the owner&#x27;s prior written consent,                                 *</span><br><span class="line">* no decompiling or reverse-engineering shall be allowed.                    *</span><br><span class="line">******************************************************************************</span><br><span class="line"></span><br><span class="line">&lt;R1&gt;dis ip int brief</span><br><span class="line">*down: administratively down</span><br><span class="line">(s): spoofing  (l): loopback</span><br><span class="line">Interface                Physical Protocol IP Address      Description</span><br><span class="line">GE0/0                    up       up       192.168.56.20   --</span><br><span class="line">GE0/1                    down     down     --              --</span><br><span class="line">GE0/2                    down     down     --              --</span><br><span class="line">GE5/0                    down     down     --              --</span><br><span class="line">GE5/1                    down     down     --              --</span><br><span class="line">GE6/0                    down     down     --              --</span><br><span class="line">GE6/1                    down     down     --              --</span><br><span class="line">Ser1/0                   down     down     --              --</span><br><span class="line">Ser2/0                   down     down     --              --</span><br><span class="line">Ser3/0                   down     down     --              --</span><br><span class="line">Ser4/0                   down     down     --              --</span><br><span class="line"></span><br><span class="line">PS C:\python\netdevops&gt;</span><br></pre></td></tr></table></figure>

<p>设备上查看 console log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;R1&gt;</span><br><span class="line">&lt;R1&gt;%Dec 26 16:50:50:033 2020 R1 SHELL/5/SHELL_LOGIN: Console logged in from con0.</span><br><span class="line">%Dec 26 16:50:54:285 2020 R1 SSHS/6/SSHS_LOG: Accepted publickey for admin from 192.168.56.102 port 1313.</span><br><span class="line"></span><br><span class="line">%Dec 26 16:50:56:061 2020 R1 SSHS/6/SSHS_LOG: User admin logged out from 192.168.56.102 port 1313.</span><br><span class="line">%Dec 26 16:50:56:061 2020 R1 SSHS/6/SSHS_DISCONNECT: SSH user admin (IP: 192.168.56.102) disconnected from the server.</span><br><span class="line"></span><br><span class="line">&lt;R1&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>paramiko</tag>
      </tags>
  </entry>
  <entry>
    <title>产品迭代</title>
    <url>/posts/8ad6508.html</url>
    <content><![CDATA[<p>迭代思维与 MVP 产品规划方法</p>
<p>MVP： minimum viable product 最小可用产品</p>
<p>OOPD：Online&amp;Offline Product Development，线上线下相结合的产品开发方法</p>
<ul>
<li>内裤原则：MVP包含了产品的轮廓，核心的功能，让业务可以运转</li>
<li>优先线下：能够走线下的，优先走线下流程，让核心的功能先跑起来，快速做用户验证和方案验证</li>
<li>MVP的核心：忽略掉一切的细枝末节，做合适的假设和简化，使用最短的时间开发出来</li>
</ul>
<p>迭代思维是最强大的产品思维逻辑，互联网上唯快不破的秘诀。</p>
<p>在资源受限的情况下（如人力、时间、资金、技术储备），忽略掉一切细枝末节，做合适的假设和简化，使用最短的时间开发出来简单的功能，之后再进行快速迭代，验证用户的需求。</p>
<span id="more"></span>


<p>如何找出产品的 MVP 功能范围？</p>
<ul>
<li>产品的核心目标？核心用户？核心场景？</li>
<li>都需要在产品里面完成或者呈现？</li>
<li>最小 MVP 产品要做哪些事情？能达到哪些业务目标？</li>
<li>做哪些简化和假设，能够在最短的时间交付产品，也业务流程跑起来？</li>
</ul>
<p>数据库设计的十个原则</p>
<p>一般性原则：3 个基础原则，3 个完备性原则；一般情况下都需要遵守</p>
<p>4  个扩展性原则（影响系统的性能和容量）</p>
<p>3 个基础原则：</p>
<ul>
<li>结构清晰：表名、字段命名没有歧义，能一眼看懂</li>
<li>唯一职责：一表一用，领域定义清晰，不存储无关信息，相关数据在一张表中</li>
<li>主键原则：设计不带物理意义的主键；有唯一约束，确保幂等</li>
</ul>
<p>3 个完备性原则：</p>
<ul>
<li>完整性：保证数据的准确性和完整性，重要的内容都有记录</li>
<li>可追溯：可追溯创建时间，修改时间，可以逻辑删除</li>
<li>一致性原则：数据之间保持一致，尽可能避免同样的数据存储在不同表中</li>
</ul>
<p>4 个扩展性原则：</p>
<ul>
<li>长短分离：可以扩展，长文本独立存储；有合适的容量设计</li>
<li>冷热分离：当前数据与历史数据分离</li>
<li>索引完备：有合适索引方便查询</li>
<li>不使用关联查询：不使用一切的 SQL Join 操作，不做 2 个表或者更多表的关联查询</li>
</ul>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>解决 Django 导出 csv 乱码问题</title>
    <url>/posts/61f26ef2.html</url>
    <content><![CDATA[<h2 id="利用-Django-输出-CSV-示例"><a href="#利用-Django-输出-CSV-示例" class="headerlink" title="利用 Django 输出 CSV 示例"></a>利用 Django 输出 CSV 示例</h2><p>环境：Python3 + Django 2.2.24</p>
<p>代码编辑器默认的编码是 UTF-8</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_view</span>(<span class="params">request</span>):</span><br><span class="line">    response = HttpResponse(content_type=<span class="string">&#x27;text/csv&#x27;</span>)</span><br><span class="line">    response[<span class="string">&#x27;Content-Disposition&#x27;</span>] = <span class="string">&#x27;attachment; filename=&quot;somefilename.csv&quot;&#x27;</span></span><br><span class="line">    writer = csv.writer(response)</span><br><span class="line">    writer.writerow([<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>, <span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;地址&#x27;</span>])</span><br><span class="line">    writer.writerow([<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这样导出文件后，即使文件的编码是 UTF-8，用 Excel 打开 CSV 文件还是乱码；但是用文本编辑器（如记事本）打开后是正常的。</p>
<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p>默认情况下，Windows 平台上的 UTF-8 编码是带有 BOM（Byte Order Mark）的，所以使用 Windows 上的Excel 软件打开纯 UTF-8 编码的文档时，会因为没有 BOM 而不识别文件内容，造成乱码。</p>
<blockquote>
<p>UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM。<br>所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯（顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯）。<br>BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。</p>
</blockquote>
<p>使用 Windows 记事本打开导出的文件后，可以看到编码是 UTF-8</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/20210724223341.png" alt="image-20210724223341736"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以在构建 response 对象时设置编码为带有 BOM 的编码格式：<code>utf-8-sig</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_view</span>(<span class="params">request</span>):</span><br><span class="line">    response = HttpResponse(content_type=<span class="string">&#x27;text/csv&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置带 BOM 的编码</span></span><br><span class="line">    response.charset = <span class="string">&#x27;utf-8-sig&#x27;</span></span><br><span class="line">    response[<span class="string">&#x27;Content-Disposition&#x27;</span>] = <span class="string">&#x27;attachment; filename=&quot;somefilename.csv&quot;&#x27;</span></span><br><span class="line">    writer = csv.writer(response)</span><br><span class="line">    writer.writerow([<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>, <span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;地址&#x27;</span>])</span><br><span class="line">    writer.writerow([<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>



<p>这样导出文件后可以直接用 Excel 打开而不会乱码；使用 Windows 记事本打开后，显示编码为 带有 BOM 的 UTF-8。</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/20210724223535.png" alt="image-20210724223535196"></p>
<h2 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h2><p>可以使用 request 中的 User-Agent 进行客户端系统判断，如果用户的系统是 Windows，那么给导出的文件编码设置为带有 BOM 的 UTF-8，否则使用 UTF-8。</p>
<p>实现示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_view</span>(<span class="params">request</span>):</span><br><span class="line">    response = HttpResponse(content_type=<span class="string">&#x27;text/csv&#x27;</span>)</span><br><span class="line">    <span class="comment"># 通过 User-Agent 判断客户端系统，然后设置带 BOM 的编码</span></span><br><span class="line">    response.charset = <span class="string">&#x27;utf-8-sig&#x27;</span> <span class="keyword">if</span> <span class="string">&quot;Windows&quot;</span> <span class="keyword">in</span> request.headers.get(<span class="string">&#x27;User-Agent&#x27;</span>) <span class="keyword">else</span> <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    response[<span class="string">&#x27;Content-Disposition&#x27;</span>] = <span class="string">&#x27;attachment; filename=&quot;somefilename.csv&quot;&#x27;</span></span><br><span class="line">    writer = csv.writer(response)</span><br><span class="line">    writer.writerow([<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>, <span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;地址&#x27;</span>])</span><br><span class="line">    writer.writerow([<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>



<h2 id="修改-UTF-8-编码为带有-BOM-的UTF-8"><a href="#修改-UTF-8-编码为带有-BOM-的UTF-8" class="headerlink" title="修改 UTF-8 编码为带有 BOM 的UTF-8"></a>修改 UTF-8 编码为带有 BOM 的UTF-8</h2><p>如果你已经有 CSV 文件的编码是 UTF-8，那么需要另存为新的文件，并设置编码。</p>
<p>如下，使用 Windows 记事本另存为：</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/20210724224035.png" alt="image-20210724224035330"></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>问题记录</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django admin 的使用</title>
    <url>/posts/8fc9d4ee.html</url>
    <content><![CDATA[<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li><p>创建项目：<code>manage.py startproject project_x</code></p>
</li>
<li><p>创建应用：<code>manage.py startapp app_x</code></p>
</li>
<li><p>创建管理用户：<code>manage.py createsuperuser </code></p>
</li>
<li><p>在 app_x 里面的 models.py 文件中，创建数据库字段（建模），涉及到字段改动时，<strong>为了保证数据安全性，建议只新增字段而不直接修改原来的字段</strong>，防止 migrate 时操作数据库时出现问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用系统自带的鉴权功能</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line">JobTypes = [(<span class="number">0</span>, <span class="string">&quot;技术类&quot;</span>),(<span class="number">1</span>, <span class="string">&quot;产品类&quot;</span>),(<span class="number">2</span>, <span class="string">&quot;运营类&quot;</span>),]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Job</span>(models.Model):</span><br><span class="line">	creator = models.Foreignkey(User,verbose_name=<span class="string">&quot;创建人&quot;</span>)</span><br><span class="line">	<span class="comment"># 使用下拉选项，需要定义一个列表 JobTypes</span></span><br><span class="line">    job_type = models.SmallIntegerField(</span><br><span class="line">        blank=<span class="literal">False</span>, choices=JobTypes, verbose_name=<span class="string">&quot;职位类别&quot;</span>,help_text=<span class="string">&quot;页面上显示的帮助信息。&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="5">
<li><p>之后在 admin.py 中注册新建的模型，使其可以在管理页面中进行维护</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Job</span><br><span class="line">admin.site.register(Job)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 setting.py 的 INSTALLED_APPS 中，注册当前应用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [<span class="string">&#x27;...&#x27;</span>,<span class="string">&#x27;jobmanage&#x27;</span>,]</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行数据库同步（迁移）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">manage.py makemigrations</span><br><span class="line">manage.py migrate</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行。</p>
</li>
</ol>
<h3 id="修改日期为自动填充"><a href="#修改日期为自动填充" class="headerlink" title="修改日期为自动填充"></a>修改日期为自动填充</h3><p>在 models.py 模型里面，修改时间为自动填充，通过引用 datetime 函数来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Job(models.Model):</span><br><span class="line">    created_date = models.DateTimeField(verbose_name=&quot;创建日期&quot;, default=datetime.now)</span><br></pre></td></tr></table></figure>



<h3 id="在-admin-中创建管理类"><a href="#在-admin-中创建管理类" class="headerlink" title="在 admin 中创建管理类"></a>在 admin 中创建管理类</h3><p>通过管理类，来控制前端的信息，如显示信息、过滤信息等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># admin.py</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Job</span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JobAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    <span class="comment"># 前端要隐藏的字段</span></span><br><span class="line">    exclude = (<span class="string">&#x27;creator&#x27;</span>, <span class="string">&#x27;created_date&#x27;</span>, <span class="string">&#x27;modify_date&#x27;</span>)</span><br><span class="line">    <span class="comment"># 显示在前端的信息</span></span><br><span class="line">    list_display = (<span class="string">&#x27;job_name&#x27;</span>, <span class="string">&#x27;job_type&#x27;</span>, <span class="string">&#x27;job_city&#x27;</span>, <span class="string">&#x27;creator&#x27;</span>, <span class="string">&#x27;created_date&#x27;</span>, <span class="string">&#x27;modify_date&#x27;</span>)</span><br><span class="line">    <span class="comment"># 字段过多时，可以进行分组显示,这样在编辑信息页面里就是分成三组信息；</span></span><br><span class="line">    <span class="comment"># 可以更进一步在 fields 的值中，将需要合并到一行显示的内容用括号括起来，避免每行显示的内容很短</span></span><br><span class="line">    fieldsets = (</span><br><span class="line">        (<span class="literal">None</span>, &#123;<span class="string">&#x27;fields&#x27;</span>: ((<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;phone&#x27;</span>),)&#125;),</span><br><span class="line">        (<span class="string">&quot;city&quot;</span>, &#123;<span class="string">&#x27;fields&#x27;</span>: (<span class="string">&#x27;city&#x27;</span>,)&#125;),</span><br><span class="line">        (<span class="string">&quot;address&quot;</span>,&#123;<span class="string">&#x27;fields&#x27;</span>: (<span class="string">&#x27;address&#x27;</span>,)&#125;),</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 查询字段</span></span><br><span class="line">    search_fields = (<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;phone&#x27;</span>,<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line">    <span class="comment"># 筛选字段</span></span><br><span class="line">    list_filter = (<span class="string">&#x27;city&#x27;</span>,<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    <span class="comment"># 默认排序字段</span></span><br><span class="line">    ordering = (<span class="string">&#x27;city&#x27;</span>,)</span><br><span class="line">    <span class="comment"># 每页显示数量</span></span><br><span class="line">    list_per_page = <span class="number">30</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在页面提交时，需要自动保存的信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_model</span>(<span class="params">self, request, obj, form, change</span>):</span><br><span class="line">        <span class="comment"># 时间自动生成了，但是创建人还是需要手动选择，所以这里的作用是在提交的时候填充上创建人</span></span><br><span class="line">        obj.creator = request.user</span><br><span class="line">        <span class="comment"># 提交的时候自动更新修改时间</span></span><br><span class="line">        obj.modify_date = datetime.now()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().save_model(request, obj, form, change)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 手动设置只读字段，这样所有的用户都无法修改</span></span><br><span class="line">    <span class="comment"># readonly_fields = (&#x27;age&#x27;,)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据用户进行判断设置只读字段</span></span><br><span class="line">    <span class="comment"># 先通过 request.user 获取用户组</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_group_names</span>(<span class="params">self,user</span>):</span><br><span class="line">        group_names = []</span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> user.groups.<span class="built_in">all</span>():</span><br><span class="line">            group_names.append(g.name)</span><br><span class="line">        <span class="keyword">return</span> group_names</span><br><span class="line">    <span class="comment"># 通过用户判断所属组信息，如果属于某个组，设置只读字段，这里是重写父类的指定方法</span></span><br><span class="line">    <span class="comment"># 这里的用户组是默认 Django admin 后台里面配置的信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_readonly_fields</span>(<span class="params">self, request, obj</span>):</span><br><span class="line">        group_names = self.get_group_names(request.user)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;some_group&quot;</span> <span class="keyword">in</span> group_names:</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">&quot;age&quot;</span>,<span class="string">&quot;city&quot;</span>) <span class="comment"># 返回只读字段</span></span><br><span class="line">        <span class="keyword">return</span> ()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置在浏览页面上可以直接修改内容</span></span><br><span class="line">    <span class="comment"># list_editable = (&#x27;city&#x27;,)</span></span><br><span class="line">    <span class="comment"># 同样这里也可以使用一个函数进行判断，指定的用户才能在浏览页面修改内容</span></span><br><span class="line">    default_list_editable = (<span class="string">&#x27;city&#x27;</span>,)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_list_editable</span>(<span class="params">self, request</span>):</span><br><span class="line">        group_names = self.get_group_names(request.user)</span><br><span class="line">        <span class="keyword">if</span> request.user.is_superuser <span class="keyword">or</span> <span class="string">&quot;editable&quot;</span> <span class="keyword">in</span> group_names:</span><br><span class="line">            <span class="keyword">return</span> self.default_list_editable</span><br><span class="line">        <span class="keyword">return</span> ()</span><br><span class="line">    <span class="comment"># 这里需要重写父类的 changelist 方法来对 list_editable 赋值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_changelist_instance</span>(<span class="params">self, request</span>):</span><br><span class="line">        self.list_editable = self.get_list_editable(request)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(JobAdmin, self).get_changelist_instance(request)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以根据实际需要对以上的显示内容进行全部定制处理，把各类常用字段抽到单独的文件中来简化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个都需要注册</span></span><br><span class="line">admin.site.register(Job, JobAdmin)</span><br></pre></td></tr></table></figure>



<h3 id="添加自定义页面"><a href="#添加自定义页面" class="headerlink" title="添加自定义页面"></a>添加自定义页面</h3><ol>
<li><p>定义一个 base 页面，作为所有页面的模板，子页面通过 block 来填充内容；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- base.html --&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;h1 style=&quot;margin:auto;width:50%&quot;&gt;这是首页&lt;/h1&gt;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>子页面继承 base 页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">这里是子页面的信息</span><br><span class="line">&#123;% if xxx %&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用管理工具管理命令行脚本"><a href="#使用管理工具管理命令行脚本" class="headerlink" title="使用管理工具管理命令行脚本"></a>使用管理工具管理命令行脚本</h3><p>在 app 目录下创建 management&#x2F;commands 目录，里面放入脚本，之后可以使用 manage.py 进行执行调用。</p>
<p>例如，实现从 csv 导入数据的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> django.core.management <span class="keyword">import</span> BaseCommand</span><br><span class="line"><span class="keyword">from</span> interview.models <span class="keyword">import</span> Candidate</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span>(<span class="title class_ inherited__">BaseCommand</span>):</span><br><span class="line">    <span class="built_in">help</span> = <span class="string">&#x27;从 csv 文件导入信息到数据库中。&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_arguments</span>(<span class="params">self, parser</span>):</span><br><span class="line">        parser.add_argument(<span class="string">&#x27;--path&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        path = kwargs[<span class="string">&#x27;path&#x27;</span>]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            reader = csv.reader(f, delimiter=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">                Candidate.objects.create(</span><br><span class="line">                    username = row[<span class="number">0</span>],</span><br><span class="line">                    city = row[<span class="number">1</span>],</span><br><span class="line">                    phone = row[<span class="number">2</span>],</span><br><span class="line">                    email = row[<span class="number">3</span>],</span><br><span class="line">                )</span><br></pre></td></tr></table></figure>

<p>之后使用命令行来执行命令，就可以成功导入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">manage.py import_candidates --help</span><br><span class="line">manage.py import_candidates --path test.csv</span><br></pre></td></tr></table></figure>



<h3 id="Django-和-LDAP-集成"><a href="#Django-和-LDAP-集成" class="headerlink" title="Django 和 LDAP 集成"></a>Django 和 LDAP 集成</h3><p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django-python3-ldap</span><br></pre></td></tr></table></figure>

<p>在 setting.py 中注册 APP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [&#x27;...&#x27;,&#x27;django_python3_ldap&#x27;,]</span><br></pre></td></tr></table></figure>

<p>在 setting.py 中配置 LDAP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### LDAP </span><br><span class="line">LDAP_AUTH_URL = &quot;ldap://localhost:389&quot;</span><br><span class="line">LDAP_AUTH_USE_TLS = False</span><br><span class="line">LDAP_AUTH_SEARCH_BASE = &quot;dc=ihopeit,dc=com&quot;</span><br><span class="line"># 域系统里面的 objectClass</span><br><span class="line">LDAP_AUTH_OBJECT_CLASS = &quot;inetOrgPerson&quot;</span><br><span class="line"># 名称映射关系</span><br><span class="line">LDAP_AUTH_USER_FIELDS = &#123;</span><br><span class="line">    &quot;username&quot;: &quot;cn&quot;,</span><br><span class="line">    &quot;first_name&quot;: &quot;givenName&quot;,</span><br><span class="line">    &quot;last_name&quot;: &quot;sn&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;mail&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LDAP_AUTH_USER_LOOKUP_FIELDS = (&quot;username&quot;,)</span><br><span class="line">LDAP_AUTH_CLEAN_USER_DATA = &quot;django_python3_ldap.utils.clean_user_data&quot;</span><br><span class="line">LDAP_AUTH_CONNECTION_USERNAME = &quot;域管理员的用户名&quot;</span><br><span class="line">LDAP_AUTH_CONNECTION_PASSWORD = &quot;域管理员的密码&quot;</span><br><span class="line"></span><br><span class="line">AUTHENTICATION_BACKENDS = &#123;&quot;django_python3_ldap.auth.LDAPBackend&quot;,&#x27;django.contrib.auth.backends.ModelBackend&#x27;,&#125;</span><br></pre></td></tr></table></figure>

<p>域用户初次登陆时，Django 会把用户信息在 Django 的表中进行创建，此时用户并没有登录权限，需要设置为 STUFF 才可以正常登录，还需要为用户配置权限，否则登录进去没有任何权限，显示空白。</p>
<p>可以使用命令行来一键从 LDAP 同步账户，然后在 Django 页面中为用户设置登录权限以及不同的查看或者编辑权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">manage.py ldap_sync_users</span><br></pre></td></tr></table></figure>



<h3 id="在-admin-管理类中自定义动作（Action）"><a href="#在-admin-管理类中自定义动作（Action）" class="headerlink" title="在 admin 管理类中自定义动作（Action）"></a>在 admin 管理类中自定义动作（Action）</h3><p>默认情况下，Django 的管理页面只有针对数据的删除操作，可以在 admin.py 中定义函数并进行注册。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义一个功能（函数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_action</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 在管理类中注册 action</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JobAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    actions = [custom_action,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前端默认显示函数名，为 action 设置一个前端显示的名字，admin.py 文件全局下为函数配置属性</span></span><br><span class="line">custom_action.short_description = <span class="string">&#x27;自定义动作&#x27;</span></span><br><span class="line"><span class="comment"># 为动作设置权限</span></span><br><span class="line">custom_action.allowed_permissions()</span><br></pre></td></tr></table></figure>

<p>可以添加各种方法来对数据进行操作，例如发邮件告警等。</p>
<h3 id="添加-LOG"><a href="#添加-LOG" class="headerlink" title="添加 LOG"></a>添加 LOG</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">LOG_FMT = <span class="string">&quot;%(asctime)s - %(levelname)s - %(message)s&quot;</span></span><br><span class="line">DATE_FMT = <span class="string">&quot;%m/%d/%Y %H:%M:%S&quot;</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span>=LOG_FMT, datefmt=DATE_FMT)</span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;Mylogger&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&quot;ERROR&quot;</span>,stack_info=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="多环境配置文件分离"><a href="#多环境配置文件分离" class="headerlink" title="多环境配置文件分离"></a>多环境配置文件分离</h3><p>在项目根目录下新建一个 settings 的包，然后根据不同的开发环境等需求，对配置文件进行分离。</p>
<p>重组目录后，还需要在项目的 manage.py 中进行修改，修改为新目录下的文件。</p>
<p><code>os.environ.setdefault(key, value)</code> 是为当前系统设置一个环境变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># manage.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 原来的配置为根目录下的 settings 文件</span></span><br><span class="line">    <span class="comment"># os.environ.setdefault(&#x27;DJANGO_SETTINGS_MODULE&#x27;, &#x27;django_demo.settings&#x27;)</span></span><br><span class="line">    <span class="comment"># 修改为 settings 目录下的文件</span></span><br><span class="line">    os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;settings.base&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在 settings 目录下，添加生产环境的配置信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># production.py</span></span><br><span class="line"><span class="keyword">from</span> settings.base <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置只允许本机访问，因为一般情况下我们的服务是通过 Nginx 等软件进行代理访问的，为了安</span></span><br><span class="line"><span class="comment"># 全起见，只允许本地访问</span></span><br><span class="line">ALLOWED_HOSTS = [<span class="string">&quot;127.0.0.1&quot;</span>]</span><br><span class="line"><span class="comment"># 关闭 Debug</span></span><br><span class="line">DEBUG = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>在 settings 目录下，添加开发环境的配置信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dev.py</span></span><br><span class="line"><span class="keyword">from</span> settings.base <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 配置一些开发环境中的参数，例如测试中的 APP，环境密钥信息等</span></span><br><span class="line"></span><br><span class="line">LDAP_AUTH_CONNECTION_USERNAME = <span class="string">&quot;admin&quot;</span></span><br><span class="line">LDAP_AUTH_CONNECTION_PASSWORD = <span class="string">&quot;admin&quot;</span></span><br><span class="line">INSTALLED_APPS += (</span><br><span class="line">    <span class="string">&quot;test_app&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>指定环境启动项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">manage.py runserver 0.0.0.0:8000 --settings=settings.dev</span><br></pre></td></tr></table></figure>

<p>原理：在命令行指定 <code>--settings</code> 之后，就会替换 manage.py 中的 <code>DJANGO_SETTING_MODULE</code> 选项。</p>
<h3 id="设置站点标题、多语言"><a href="#设置站点标题、多语言" class="headerlink" title="设置站点标题、多语言"></a>设置站点标题、多语言</h3><p>在默认 APP 的 url.py 中进行配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django_demo/url.py</span></span><br><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> gettext <span class="keyword">as</span> _</span><br><span class="line"><span class="comment"># 当有多语言时，用 gettext 方法来匹配不同的文本</span></span><br><span class="line">admin.site.site_header = _(<span class="string">&quot;测试系统&quot;</span>)</span><br><span class="line">admin.site.site_title = _(<span class="string">&quot;测试系统&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="修改默认的管理界面"><a href="#修改默认的管理界面" class="headerlink" title="修改默认的管理界面"></a>修改默认的管理界面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先安装界面</span><br><span class="line">pip install django-grappelli</span><br></pre></td></tr></table></figure>

<p>安装成功后，在 settings.py 中将主题注册一下，<strong>注意：主题注册要位于 admin 的前面</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (<span class="string">&#x27;grappelli&#x27;</span>, <span class="string">&#x27;django.contrib,admin&#x27;</span>,)</span><br></pre></td></tr></table></figure>

<p>在 url.py 中添加 URL 映射，也要位于 admin 的前面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">urlpaterns = [</span><br><span class="line">    path(&#x27;grappelli/&#x27;, include(&#x27;grapelli.urls&#x27;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><h4 id="数据权限、数据集权限"><a href="#数据权限、数据集权限" class="headerlink" title="数据权限、数据集权限"></a>数据权限、数据集权限</h4><p>admin.py 中，在数据的管理类里面定义各类显示函数，通过判断来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestModelAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    default_fields = (<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>,)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_user_fields</span>(<span class="params">self, user</span>):</span><br><span class="line">        all_fields = []</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> user.fields.<span class="built_in">all</span>()</span><br><span class="line">            all_fields.append(f.name)</span><br><span class="line">        <span class="keyword">return</span> all_fields</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_list_fiedls</span>(<span class="params">self, request</span>):</span><br><span class="line">        all_fields = self.all_fields(request.user)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;some_permission&quot;</span> <span class="keyword">in</span> all_fields:</span><br><span class="line">            <span class="keyword">return</span> self.default_fields</span><br><span class="line">        <span class="keyword">return</span> ()</span><br></pre></td></tr></table></figure>

<h4 id="功能（Action）权限（菜单、按钮等）"><a href="#功能（Action）权限（菜单、按钮等）" class="headerlink" title="功能（Action）权限（菜单、按钮等）"></a>功能（Action）权限（菜单、按钮等）</h4><ol>
<li><p>需要在 models 里面定义 Meta 类，添加权限并迁移数据库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Job</span>(models.Model):</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        <span class="comment"># 定义权限，然后在 admin.py 中为具体的功能添加权限</span></span><br><span class="line">        permissions = [</span><br><span class="line">            (<span class="string">&quot;export&quot;</span>, <span class="string">&quot;Can export db&quot;</span>),</span><br><span class="line">            (<span class="string">&quot;notify&quot;</span>, <span class="string">&quot;Can notify message&quot;</span>),</span><br><span class="line">        ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 admin.py 中为功能添加权限</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># admin.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_actions</span>(<span class="params">modeladmin, request, queryset</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">some_actions.allowed_permissions = (<span class="string">&quot;export&quot;</span>,)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模型管理类中添加权限判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># admin.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestModelAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_export_permission</span>(<span class="params">self, request</span>):</span><br><span class="line">        opts = self.opts</span><br><span class="line">        <span class="keyword">return</span> request.user.has_perm(<span class="string">&#x27;%s.%s&#x27;</span>% (opts.app_label,<span class="string">&quot;export&quot;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 admin web 管理后台中，按需为具体的用户配置权限。</p>
</li>
</ol>
<h3 id="webhook-通知（钉钉为例）"><a href="#webhook-通知（钉钉为例）" class="headerlink" title="webhook 通知（钉钉为例）"></a>webhook 通知（钉钉为例）</h3><ol>
<li><p>安装钉钉机器人</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install DingtalkChatbot</span><br></pre></td></tr></table></figure>
</li>
<li><p>在钉钉中创建群聊机器人，获取 webhook 地址，并在 settings 中配置</p>
</li>
<li><p>在 APP 目录下定义一个发送消息的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># some_app/dingtalk.py</span></span><br><span class="line"><span class="keyword">from</span> dingtalkchatbot.chatbot <span class="keyword">import</span> DingtalkChatbot</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg</span>(<span class="params">message, at_mobiles=[]</span>):</span><br><span class="line">    <span class="comment"># 引用 settings 里面的 webhook 配置地址</span></span><br><span class="line">    webhook = settings.DINGTALK_WEBHOOK</span><br><span class="line">    secret = settings.SECRET</span><br><span class="line">    <span class="comment"># 初始化一个机器人</span></span><br><span class="line">    bot = DingtalkChatbot(webhook)</span><br><span class="line">    <span class="comment"># 示例2：如果机器人勾选了“加签”，需要传入 secret</span></span><br><span class="line">    bot2 = DingtalkChatbot(webhook=webhook,secret=secret)</span><br><span class="line">	<span class="comment"># 发送消息</span></span><br><span class="line">    bot.send_text(msg=<span class="string">&quot;WebHook 机器人测试&quot;</span>, at_mobiles=at_mobiles)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 admin.py 中新增 action</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> messages</span><br><span class="line"><span class="keyword">from</span> some_app <span class="keyword">import</span> dingtalk</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">modeladmin, request, queryset</span>):</span><br><span class="line">    msg = <span class="string">&quot;测试消息：\n&quot;</span></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> queryset:</span><br><span class="line">        msg += <span class="string">&quot;%s 的手机号是 %s\n&quot;</span> %( obj.username, obj.phone)</span><br><span class="line">    dingtalk.send_msg(msg)</span><br><span class="line">    messages.add_message(request, messages.INFO, <span class="string">&quot;发送成功&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 管理类中注册 action</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># admin.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestModelAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    actions = [<span class="string">&quot;notify&quot;</span>,]</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用 django shell 进行消息测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">manage.py shell</span><br><span class="line"><span class="keyword">from</span> some_app <span class="keyword">import</span> dingtalk</span><br><span class="line">dingtalk.send_msg(<span class="string">&quot;测试消息&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="添加一个第三方注册功能的-APP"><a href="#添加一个第三方注册功能的-APP" class="headerlink" title="添加一个第三方注册功能的 APP"></a>添加一个第三方注册功能的 APP</h3><p>先安装第三方包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django-registration-redux</span><br></pre></td></tr></table></figure>

<p>在 settings 中注册</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [&quot;registration&quot;,]</span><br></pre></td></tr></table></figure>

<p>在 url.py 中添加 URL 映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># url.py</span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(r&quot;^accounts/&quot;, include(&quot;registration.backends.simple.urls&quot;)),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>迁移数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">manage.py makemigrations</span><br><span class="line">manage.py migrate</span><br></pre></td></tr></table></figure>

<p>启动服务，访问测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8000/accounts/register</span><br></pre></td></tr></table></figure>

<p>配置注册完成后跳转到登录页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># settings.py</span><br><span class="line"># 登录之后的默认页面</span><br><span class="line">LOGIN_REDIRECT_URL = &#x27;job_list&#x27;</span><br><span class="line"># 注册之后的默认页面</span><br><span class="line">SIMPLE_BACKEND_REDIRECT_URL = &#x27;/accounts/login&#x27;</span><br></pre></td></tr></table></figure>



<h3 id="添加前端页面（view）"><a href="#添加前端页面（view）" class="headerlink" title="添加前端页面（view）"></a>添加前端页面（view）</h3><p>一般情况下，如果写 view 的话，全部字段都是需要自定义的；</p>
<p>可以使用 Django 自带的通用 view，自定义 view 继承通用的 view，常见的有 CreateView（表单）、DetailView（详情页）、ListView（列表），官方教程见：<a href="https://docs.djangoproject.com/zh-hans/3.2/topics/class-based-views/generic-editing/">基于类的表单视图</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.generic.edit <span class="keyword">import</span> CreateView</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.mixins <span class="keyword">import</span> LoginRequiredMixin</span><br><span class="line"><span class="comment"># 使用类定义一个简历视图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResumeCreateView</span>(LoginRequiredMixin, CreateView):</span><br><span class="line">    <span class="comment"># 定义使用哪个模板</span></span><br><span class="line">    template_name = <span class="string">&#x27;resume_form.html&#x27;</span></span><br><span class="line">    <span class="comment"># 定义成功后的重定向页面</span></span><br><span class="line">    success_url = <span class="string">&#x27;/job_list/&#x27;</span></span><br><span class="line">    <span class="comment"># 定义使用的 model</span></span><br><span class="line">    model = Resume</span><br><span class="line">    <span class="comment"># 定义表单页面要显示 model 里面的哪些字段</span></span><br><span class="line">    fields = (<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;applicant&#x27;</span>, <span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;apply_position&#x27;</span>, <span class="string">&#x27;bachelor_school&#x27;</span>, <span class="string">&#x27;master_school&#x27;</span>, <span class="string">&#x27;major&#x27;</span>,)</span><br><span class="line">	<span class="comment"># 定义获取初始值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_initial</span>(<span class="params">self</span>):</span><br><span class="line">        initial = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.request.GET:</span><br><span class="line">            initial[x] = self.request.GET[x]</span><br><span class="line">        <span class="keyword">return</span> initial</span><br><span class="line">	<span class="comment"># 数据验证及保存数据，并进行重定向</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">form_valid</span>(<span class="params">self, form</span>):</span><br><span class="line">        self.<span class="built_in">object</span> = form.save(commit=<span class="literal">False</span>)</span><br><span class="line">        self.<span class="built_in">object</span>.applicant = self.request.user</span><br><span class="line">        self.<span class="built_in">object</span>.save()</span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(self.get_success_url)</span><br></pre></td></tr></table></figure>

<p>然后在 url.py 里面注册路径，格式固定为 <code>类.as_view()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(r&#x27;^resume/add/&#x27;, views.ResumeCreateView.as_view(),name=&#x27;resume_add&#x27;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>最后添加前端模板页面 resume_form.html ，模板名字也是推荐使用固定后缀，表单页是 <code>_form.html</code> ，详情页是 <code>_detail.html</code> ，列表页是 <code>_list.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- resume_form.html --&gt;</span><br><span class="line">&lt;form method=&quot;POST&quot;&gt;</span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;&#123; form.as_p &#125;&#125;  &#123;# 这里的变量是固定的 form ，as_p 是用 &lt;p&gt; 标签包含数据#&#125;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;申请职位&quot; onclick=&quot;location.href=&#x27;/resume/add/?apply_position=&#123;&#123; job.name &#125;&#125;&amp;city=&#123;&#123; job.city &#125;&#125;&#x27;&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>



<h3 id="使用-bootstrap-美化页面"><a href="#使用-bootstrap-美化页面" class="headerlink" title="使用 bootstrap 美化页面"></a>使用 bootstrap 美化页面</h3><p>安装 bootstrap4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django-bootstrap4</span><br></pre></td></tr></table></figure>

<p>在 settings.py 中注册</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [&quot;bootstrap4&quot;,]</span><br></pre></td></tr></table></figure>

<p>在 html 中添加 bootstrap</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 加载 bootstrap 库 #&#125;</span><br><span class="line">&#123;% load bootstrap4 %&#125;</span><br><span class="line">&#123;# 加载 CSS and JavaScript #&#125;</span><br><span class="line">&#123;% bootstrap_css %&#125;</span><br><span class="line">&#123;% bootstrap_javascript jquery=&#x27;full&#x27; %&#125;</span><br></pre></td></tr></table></figure>



<h3 id="为已经有的系统添加管理后台"><a href="#为已经有的系统添加管理后台" class="headerlink" title="为已经有的系统添加管理后台"></a>为已经有的系统添加管理后台</h3><p>首先在 settings.py 中添加已有环境的数据库配置</p>
<p>然后使用 manage.py 命令为现有数据库生成 model</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">manage.py inspectdb &gt; models.py</span><br></pre></td></tr></table></figure>

<h3 id="添加多语言"><a href="#添加多语言" class="headerlink" title="添加多语言"></a>添加多语言</h3><ol>
<li>代码中使用 <code>gettext</code> <code>gettext_lazy</code> 获取多语言资源对应的文本内容</li>
<li>生成多语言资源文件</li>
<li>翻译</li>
<li>生成二进制多语言资源文件</li>
<li>页面配置按钮</li>
</ol>
<h3 id="错误上报到-sentry"><a href="#错误上报到-sentry" class="headerlink" title="错误上报到 sentry"></a>错误上报到 sentry</h3><h3 id="和-Celery-结合，用-Flowers-查看-redis-性能"><a href="#和-Celery-结合，用-Flowers-查看-redis-性能" class="headerlink" title="和 Celery 结合，用 Flowers 查看 redis 性能"></a>和 Celery 结合，用 Flowers 查看 redis 性能</h3><h3 id="多数据库路由，实现读写分离-x2F-整合现有数据库"><a href="#多数据库路由，实现读写分离-x2F-整合现有数据库" class="headerlink" title="多数据库路由，实现读写分离&#x2F;整合现有数据库"></a>多数据库路由，实现读写分离&#x2F;整合现有数据库</h3><h3 id="大量数据的关联外键"><a href="#大量数据的关联外键" class="headerlink" title="大量数据的关联外键"></a>大量数据的关联外键</h3><p>场景：依赖外量数据量过大导致页面卡死；比如添加一个员工，员工的出生地依赖于城市表，全球城市表有上万个，使用下拉框选择时，Django 默认会把外键中的所有数据都加载</p>
<p>数据关系：City 从属于 Province，Province 依赖于 Country</p>
<p>期望：选择依赖的数据时，可输入字符进行查找</p>
<p>解决方案：在 admin.py 中设置字段为自动完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py 中的外键关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Province</span>(models.Model):</span><br><span class="line">    provinceid = models.AutoField(Primary_key=<span class="literal">True</span>)</span><br><span class="line">    countyid = Models.ForignKey(Country, db_column=<span class="string">&quot;countryid&quot;</span>, null=<span class="literal">True</span>, on_delete=models.SET_NULL)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">City</span>(models.Model):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    countyid = Models.ForignKey(Country, db_column=<span class="string">&quot;countryid&quot;</span>, null=<span class="literal">True</span>, on_delete=models.SET_NULL)</span><br><span class="line">    provinceid = Models.ForignKey(Country, db_column=<span class="string">&quot;province&quot;</span>, null=<span class="literal">True</span>, on_delete=models.SET_NULL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Admin 类中设置可以搜索的字段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountryAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    search_fields = (<span class="string">&#x27;chn_name&#x27;</span>, <span class="string">&#x27;eng_name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 admin.py 中设置自动完成的关联外键</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CityAdmin</span>(admin.ModelAdmin):</span><br><span class="line">	autocomplete_fields = [<span class="string">&#x27;provinceid&#x27;</span>, <span class="string">&#x27;countryid&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h3 id="多级数据自动关联"><a href="#多级数据自动关联" class="headerlink" title="多级数据自动关联"></a>多级数据自动关联</h3><p>选择某个数据的时候，其他与它相关的字段内容自动关联发生改变。例如选择一个城市，自动关联出省份和国家。</p>
<p>使用如下插件来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django-smart-selects</span><br></pre></td></tr></table></figure>

<p>将插件注册到 APP 中，然后在 url.py 中添加路径，下拉选择时会调用此路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = patterns(</span><br><span class="line">	url(<span class="string">r&#x27;chaining/&#x27;</span>, include(<span class="string">&#x27;smart_selects.urls&#x27;</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>最后在 Model 中定义 <code>ChainedForeginKey</code> 外键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">City</span>(models.Model):</span><br><span class="line">    provinceid = ChainedForeignKey(</span><br><span class="line">    	Province,</span><br><span class="line">    	chained_field=<span class="string">&quot;countryid&quot;</span>,</span><br><span class="line">    	chained_model_field=<span class="string">&quot;countryid&quot;</span>,</span><br><span class="line">    	show_all=<span class="literal">False</span>,</span><br><span class="line">    	auto_choose=<span class="literal">True</span>,</span><br><span class="line">    	sort=<span class="literal">True</span>,</span><br><span class="line">    	db_column=<span class="string">&quot;provinceid&quot;</span></span><br><span class="line">    	)</span><br></pre></td></tr></table></figure>



<h3 id="定义只读的管理后台（重写-admin-ModelAdmin-方法）"><a href="#定义只读的管理后台（重写-admin-ModelAdmin-方法）" class="headerlink" title="定义只读的管理后台（重写 admin.ModelAdmin 方法）"></a>定义只读的管理后台（重写 admin.ModelAdmin 方法）</h3><p>对集成的原有系统，为了安全起见，提供只读的管理后台，定义一个 ReadOnlyAdmin，然后其他的 model 继承这个只读的 Admin。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadOnlyAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    readonly_fields = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示出所有的字段</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_list_display</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> [field.name <span class="keyword">for</span> field <span class="keyword">in</span> self.model._meta.concrete_fields]</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_readonly_fields</span>(<span class="params">self, request, obj=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(self.readonly_fields) + \</span><br><span class="line">               [field.name <span class="keyword">for</span> field <span class="keyword">in</span> obj._meta.fields] + \</span><br><span class="line">               [field.name <span class="keyword">for</span> field <span class="keyword">in</span> obj._meta.many_to_many]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_add_permission</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_delete_permission</span>(<span class="params">self, request, obj=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_change_permission</span>(<span class="params">self, request, obj=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(<span class="params">Country</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountryAdmin</span>(<span class="title class_ inherited__">ReadOnlyAdmin</span>):</span><br><span class="line">    search_fields = (<span class="string">&#x27;chn_name&#x27;</span>, <span class="string">&#x27;eng_name&#x27;</span>,)</span><br></pre></td></tr></table></figure>



<h3 id="自动注册所有的-Model-到管理后台"><a href="#自动注册所有的-Model-到管理后台" class="headerlink" title="自动注册所有的 Model 到管理后台"></a>自动注册所有的 Model 到管理后台</h3><h4 id="在根下创建-apps-py-里面遍历-models-，注册这个-app"><a href="#在根下创建-apps-py-里面遍历-models-，注册这个-app" class="headerlink" title="在根下创建 apps.py  里面遍历 models ，注册这个 app"></a>在根下创建 apps.py  里面遍历 models ，注册这个 app</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> apps, AppConfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdminClass</span>(admin.ModelAdmin):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model, admin_site</span>):</span><br><span class="line">        <span class="comment"># 列表页自动显示所有的字段：</span></span><br><span class="line">        self.list_display = [field.name <span class="keyword">for</span> field <span class="keyword">in</span> model._meta.fields]</span><br><span class="line">        <span class="built_in">super</span>(AdminClass, self).__init__(model, admin_site)</span><br><span class="line"></span><br><span class="line"><span class="comment"># automatically register all models</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniversalManagerApp</span>(<span class="title class_ inherited__">AppConfig</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    应用配置在 所有应用的 Admin 都加载完之后执行</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># the name of the AppConfig must be the same as current application</span></span><br><span class="line">    name = <span class="string">&#x27;django-demo&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ready</span>(<span class="params">self</span>):</span><br><span class="line">        models = apps.get_app_config(<span class="string">&#x27;running&#x27;</span>).get_models() </span><br><span class="line">        <span class="keyword">for</span> model <span class="keyword">in</span> models:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                admin.site.register(model, AdminClass)</span><br><span class="line">            <span class="keyword">except</span> admin.sites.AlreadyRegistered:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">### 在 settings 里面注册 app</span></span><br><span class="line">INSTALLED_APPS = [<span class="string">&#x27;django-demo.apps.UniversalManagerApp&#x27;</span>,]</span><br></pre></td></tr></table></figure>

<h4 id="使用动态类的方法"><a href="#使用动态类的方法" class="headerlink" title="使用动态类的方法"></a>使用动态类的方法</h4><p>Python 中类也是对象，利用动态特性，使用 type() 函数动态顶一个类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = <span class="built_in">type</span>(name, (models.Model,), attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通的类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 等同于如下的动态类定义</span></span><br><span class="line">Person = <span class="built_in">type</span>(<span class="string">&#x27;Person&#x27;</span>, (models.Modes,), &#123;</span><br><span class="line">    <span class="string">&#x27;first_name&#x27;</span>: models.CharField(max_length=<span class="number">255</span>),</span><br><span class="line">    <span class="string">&#x27;last_name&#x27;</span>: models.CharField(max_length=<span class="number">255</span>),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现成模块：sandman，为已有数据库提供增删改查和 RestAPI</p>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>有信号发生的时候，帮助解耦的应用接收到消息通知，允许特定的信号发送者发送消息到一系列的消息接收者。是同步调用。</p>
<p>例如，当某个数据发生改变时，发送邮件通知消息。</p>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><ul>
<li>Django debug toolbar：提供可以查看 debug 信息的面板，包括 SQL 执行时间，页面耗时等</li>
<li>django-silk：性能瓶颈分析</li>
<li>simple ui ： 基于 Element UI 和 Vue 的主题</li>
<li>Haystack Django：模块化搜索方案，全文搜索，使用不同的搜索系统</li>
<li>Django notifications：发送消息通知</li>
<li>Django markdown editor：编辑器</li>
<li>Django-crispy-forms：Crispy 表单，以一种优雅、干净的方式常见美观的表单</li>
<li>django-simple-captcha：表单验证码，可以防止攻击</li>
<li>django-ratelimit：应用限流</li>
<li>django-user-accounts：密码安全</li>
<li></li>
</ul>
<h3 id="部署到生产环境之前"><a href="#部署到生产环境之前" class="headerlink" title="部署到生产环境之前"></a>部署到生产环境之前</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>TestCase</p>
<p>哪些逻辑需要测试？</p>
<p>自带的代码可以不用测试，对自己写的代码进行测试，如自定义页面、自定义菜单</p>
<p>目录结构，testcase 文件夹下，匹配 test*.py 的文件作为测试用例。</p>
<p>执行测试： manage.py test</p>
<h4 id="配置生产环境"><a href="#配置生产环境" class="headerlink" title="配置生产环境"></a>配置生产环境</h4><ul>
<li>DEBUG 、Secret 、ALLOWED_HOSTS 等相关信息</li>
<li>Django APP 的托管环境选择，云上还是云下</li>
<li>部署前的检查 manage.py check –deploy</li>
<li>静态资源文件的托管环境（JS、CSS、图片、文件等）&amp; 部署静态资源（manage.py collectstatic 工具收集所有静态资源）</li>
<li>部署 Django 应用容器和 Web 服务器（uWSGI、gunicorn、Daphne、Hypercorn、Uvicorn），不提供静态资源的加载，静态资源要放在前端 Nginx 上</li>
</ul>
<p>用户（<a href="http://www.baidu.com)---&gt;/">www.baidu.com）---&gt;</a> Nginx 服务器（proxy_pass localhost;） —&gt; Django Server</p>
<h4 id="应用部署架构"><a href="#应用部署架构" class="headerlink" title="应用部署架构"></a>应用部署架构</h4><p><img data-src="http://oss.xdai.vip/md-note/imgs/20210809214849.png" alt="image-20210809214848841"></p>
<p>密钥管理：文件、环境变量、KeyServer</p>
<p>开源的 KeyServer：vault、keywhiz、knox</p>
<p>免费的 SSL 证书机构：Let’s Encrypt，90 天到期，可以自动续期。</p>
<h3 id="技术方案设计与拆解"><a href="#技术方案设计与拆解" class="headerlink" title="技术方案设计与拆解"></a>技术方案设计与拆解</h3><p>定义用户场景 –&gt; 业务流程 –&gt; 产品范围 –&gt; 梳理核心要解决的问题 –&gt; 调研对比不同的方案 –&gt; 系统的模块界限、协议、数据流转、数据输入输出 –&gt; 形成文档 –&gt; 开发&amp;测试 –&gt; 发布</p>
<p>用到的工具：不用工具是最好的工具，白纸、白板，完成后再到线上。</p>
<p>Visual Paradigm、Lucid Chart、Visio、Draw.io、StarUML、Gliffy</p>
<p>技术方案设计文档要素：</p>
<ul>
<li>产品背景（用户场景、产品目标、业务流程、需求文档）</li>
<li>要解决的问题、不解决的问题、系统的限制</li>
<li>问题的不通解决方案对比</li>
<li>整体的流程图、模块关系图、重要的接口、实体的概念定义</li>
<li>除了核心功能外的其他方面的设计，如安全、性能、可维护、稳定性、监控、扩展性、易用性</li>
</ul>
<p>工作拆解：任何事情只要拆的足够细，都能够完成它</p>
<p>拆解原则：</p>
<ul>
<li>优先级：主流程上，不确定的工作优先完成</li>
<li>核心流程优先：核心工作优先，先把主流程跑通</li>
<li>依赖：人员之间工作依赖</li>
<li>拆解粒度：拆解每项子任务 0.5~1 天的粒度，最长不超过两天</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>kuryr-kubernetes</title>
    <url>/posts/5509f374.html</url>
    <content><![CDATA[<p>Kuryr-kubernetes 是 openstack neutrn 的子项目。</p>
<p>本身没有网络能力，是将 openstack neutron 的网络能力提供给 k8s。</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/1b8e3cabe00541038b5b4500408ab624.png" alt="9c7f7b717d793c6db27eb9ea8ae0ab5a.png"></p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>kuryr-controller<ul>
<li>连接 k8s-api，监测 k8s 数据变化</li>
<li>连接 openstack，根据 k8s 数据，在 openstack neutron 中创建或更新相应资源</li>
<li>将 neutron 中的有关网络的信息通过 annotation 的形式传递给 k8s-api</li>
<li>不需要独立的存储</li>
</ul>
</li>
<li>kuryr-cni<ul>
<li>连接 kubelet 的 CNI networkplugin，是一种 CNI 的实现</li>
<li>监听 k8s-api 中的 annotation 获取 neutron 相关的信息</li>
<li>实际操作（创建、更新） pod 所需要的网卡</li>
</ul>
</li>
</ul>
<h2 id="资源对应关系"><a href="#资源对应关系" class="headerlink" title="资源对应关系"></a>资源对应关系</h2><p>pod 网卡 &lt;—&gt; Neutron port</p>
<p>pod 子网和 service 子网 &lt;—&gt; Neutron Subnet</p>
<p>Service &lt;—&gt; Neutron LoadBalancer</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/e7d665dacb6d40fbaa2d5ca57fd73765.png" alt="98fe4087983cc8f4d3532c3845f185c7.png"></p>
<h2 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h2><p><img data-src="http://oss.xdai.vip/md-note/imgs/a0ed916ce7ac48a8bac476f0f6cfa72a.png" alt="42f6cd5ce8a32fdd6244828ab642c9ad.png"></p>
]]></content>
      <categories>
        <category>网络技术</category>
        <category>OpenStack</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>网络</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>calico 学习笔记</title>
    <url>/posts/5509f374.html</url>
    <content><![CDATA[<p>Calico 是针对容器、虚机、物理服务器的网络解决方案</p>
<ul>
<li>提供 CNI plugin 与 k8s mesos 集成</li>
<li>提供 Libnetwork plugin 与 docker 集成</li>
<li>以 neutron plugin 形式与 openstack 集成</li>
<li>支持 BGP、IPIP 两种方案</li>
</ul>
<p>Flannel 方案中，master node 上的 flanneld 进程需要始终检测 k8s api 哪些资源发生了变化并同步 etcd，规模较大时，会造成压力。<br>calico 与 k8s 集成时，使用 BGP 缓解 k8s api 和 etcd 的压力；并且提供了 network policy，实现多个用户之间的网络隔离等。</p>
<span id="more"></span>

<p>k8s 集成时的基本架构</p>
<ul>
<li>etcd 作为存储，可以共用 k8s，也可以使用独立的 etcd</li>
<li>master node：运行 calico-kube-controller pod 用来同步 k8s 数据和 etcd 数据</li>
<li>worker node：运行 calico-node ，配合 CNI plugin 工作来配置网络，这个容器中运行了四个进程<ul>
<li>runsvdir 作为主进程，会检测并重启以下 4 个进程</li>
<li><strong>Felix</strong>：核心组件<ol>
<li>管理 calico 相关的网卡，处理arp、检测网卡状态等</li>
<li>配置 worker node 上的路由表</li>
<li>配置 network policy</li>
<li>上报节点状态</li>
</ol>
</li>
<li><strong>Brid</strong>：独立的项目，实现了 BGP 协议，运行<strong>两个进程</strong>，分别管理 ipv4 和 ipv6</li>
<li><strong>confd</strong>：独立项目，用来从 etcd 同步配置文件，并重启相应的 bird 进程来时配置生效（自动化了 BGP 的配置）</li>
</ul>
</li>
</ul>
<p>calico 中使用的是 IBGP，部署反射器</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Pure-BGP"><a href="#Pure-BGP" class="headerlink" title="Pure BGP"></a>Pure BGP</h3><p>以 IBGP 的方式传递 pod 的路由，可能会与物理网络地址空间冲突。</p>
<h4 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 参考</span><br><span class="line">https://docs.projectcalico.org/getting-started/kubernetes/self-managed-onprem/onpremises#install-calico-with-kubernetes-api-datastore-50-nodes-or-less</span><br><span class="line"># 下载配置文件</span><br><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -O</span><br><span class="line"># 修改配置文件，将 IPIP 选项改为 off，添加 pods CIDR</span><br><span class="line">- name: CALICO_IPV4POOL_CIDR</span><br><span class="line">  value: &quot;11.0.0.0/16&quot;</span><br><span class="line">- name: CALICO_IPV4POOL_IPIP</span><br><span class="line">  # value: &quot;Always&quot;</span><br><span class="line">  value: &quot;off&quot;</span><br><span class="line"># 部署</span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.projectcalico.org/getting-started/clis/calicoctl/">安装 calicoctl 并配置</a></p>
<ol>
<li><p>下载 calicoctl，curl -x 可以配置代理服务器</p>
<p> <code>curl -O -L  https://github.com/projectcalico/calicoctl/releases/download/v3.15.0/calicoctl</code></p>
</li>
<li><p>添加可执行权限（可以移动到系统变量目录中）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x calicoctl</span><br><span class="line">mv ./calicoctl /usr/local/bin/</span><br></pre></td></tr></table></figure></li>
<li><p>添加配置文件，让 calico 连接 k8s 的 etcd</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># more /etc/calico/calicoctl.cfg </span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: CalicoAPIConfig</span><br><span class="line">metadata:</span><br><span class="line">spec:</span><br><span class="line">  datastoreType: &quot;kubernetes&quot;</span><br><span class="line">  # 修改路径为当前 k8s 的配置路径</span><br><span class="line">  kubeconfig: &quot;/home/x/.kube/config&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>获取当前 calico 节点</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x@x-vm:~$ calicoctl get nodes -o wide</span><br><span class="line">NAME     ASN       IPV4                 IPV6   </span><br><span class="line">worker   (64512)   192.168.121.139/24          </span><br><span class="line">x-vm     (64512)   192.168.121.137/24</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 BGP peer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x@x-vm:~$ sudo calicoctl node status</span><br><span class="line">Calico process is running.</span><br><span class="line">IPv4 BGP status</span><br><span class="line">+-----------------+-------------------+-------+----------+-------------+</span><br><span class="line">|  PEER ADDRESS   |     PEER TYPE     | STATE |  SINCE   |    INFO </span><br><span class="line">|</span><br><span class="line">+-----------------+-------------------+-------+----------+-------------+</span><br><span class="line">| 192.168.121.139 | node-to-node mesh | up    | 03:59:44 | Established |</span><br><span class="line">+-----------------+-------------------+-------+----------+-------------+</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://docs.projectcalico.org/networking/bgp#disable-the-default-bgp-node-to-node-mesh">配置 BGP</a>（默认已经有了，如上显示的 ASN 为 64512）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过 yaml 配置，vim calico_bgp.yml</span><br><span class="line">apiVersion: projectcalico.org/v3</span><br><span class="line">kind: BGPConfiguration</span><br><span class="line">metadata:</span><br><span class="line">  name: default</span><br><span class="line">spec:</span><br><span class="line">  logSeverityScreen: Info</span><br><span class="line">  nodeToNodeMeshEnabled: true</span><br><span class="line">  asNumber: 63400</span><br><span class="line"># 应用配置</span><br><span class="line">calicoctl create -f calico_bgp.yml</span><br><span class="line"># 查看 node，ASN 已经变为配置文件的</span><br><span class="line">x@x-vm:~$ calicoctl get nodes -o wide</span><br><span class="line">NAME     ASN       IPV4                 IPV6   </span><br><span class="line">worker   (63400)   192.168.121.139/24          </span><br><span class="line">x-vm     (63400)   192.168.121.137/24</span><br></pre></td></tr></table></figure>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>veth pair 没有连接任何 Linuxbridge，所有数据转发依靠内核路由表查找；所有 pod 网络数据都直接走三层转发。</p>
</li>
</ol>
<ul>
<li>pod 内的网络<br>  pod 内只有 169.254.1.1 的默认路由，即访问任何数据都三层转发到 veth 设备。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # ip route</span><br><span class="line">default via 169.254.1.1 dev eth0 </span><br><span class="line">169.254.1.1 dev eth0 scope link</span><br><span class="line">/ # arping 169.254.1.1</span><br><span class="line">ARPING 169.254.1.1 from 11.0.82.3 eth0</span><br><span class="line">Unicast reply from 169.254.1.1 [ee:ee:ee:ee:ee:ee] 0.015ms</span><br><span class="line">Unicast reply from 169.254.1.1 [ee:ee:ee:ee:ee:ee] 0.097ms</span><br></pre></td></tr></table></figure>
 如何转发？通过主机 arp proxy 来实现。<br> pod 的 veth pair 一边连接 pod ，另一边挂在主机的网络命名空间，通过配置主机网络命名空间的 proxy 选项，为 pod 提供三层转发的 arp 应答，这样 pod 的数据包转发到了主机命名空间，挂在主机命名空间的网卡收到数据包后，calico 配置开启了这个网卡的 forwarding 选选项，这样就会查找主机的路由表。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x@x-vm:~$ cat /proc/sys/net/ipv4/conf/cali99c376db89a/proxy_arp</span><br><span class="line">1</span><br><span class="line">x@x-vm:~$ cat /proc/sys/net/ipv4/neigh/cali99c376db89a/proxy_delay </span><br><span class="line">0</span><br><span class="line">x@x-vm:~$ cat /proc/sys/net/ipv4/conf/cali99c376db89a/forwarding  </span><br><span class="line">1</span><br></pre></td></tr></table></figure>
  <img data-src="http://oss.xdai.vip/md-note/imgs/c03908d42c4e49bc8a4f246c1d5f6ad6.png" alt="9299b099584c3923aa79801bb2991bb2.png"></li>
</ul>
<h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>分别在两个node上各创建一个临时的 pod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl run -it --rm --restart=Never test1 --image busybox --overrides=&#x27;&#123;&quot;apiVersion&quot;: &quot;v1&quot;,&quot;spec&quot;: &#123;&quot;nodeSelector&quot;: &#123;&quot;kubernetes.io/hostname&quot;: &quot;x-vm&quot;&#125;&#125;&#125;&#x27; sh </span><br><span class="line">kubectl run -it --rm --restart=Never test2 --image busybox --overrides=&#x27;&#123;&quot;apiVersion&quot;: &quot;v1&quot;,&quot;spec&quot;: &#123;&quot;nodeSelector&quot;: &#123;&quot;kubernetes.io/hostname&quot;: &quot;worker&quot;&#125;&#125;&#125;&#x27; sh</span><br></pre></td></tr></table></figure>
<p>在主机上 brctl show ,只有一个 docker0 网桥，未挂载任何网卡<br><img data-src="http://oss.xdai.vip/md-note/imgs/124695c8a56746a1a2b6beb78a1e8e0f.png" alt="81e0d93c767f93cfe28017f53230c565.png"><br>在 pod 内发送 arp 请求，在 node 上抓包<br><img data-src="http://oss.xdai.vip/md-note/imgs/a8b5421a53bb42359b19c36f7a216bdf.png" alt="e1dbf464487e10784a39f0020538cbc8.png"><br><img data-src="http://oss.xdai.vip/md-note/imgs/7f6cf71357f54c349dfb67097d1dedf5.png" alt="b39270e48c3b0f504d1b65d9f6c0f751.png"><br>查看 master node 的路由表<br><img data-src="http://oss.xdai.vip/md-note/imgs/50fcabce0f8944f99b0b1bcd56bd7c74.png" alt="170c6be1d931b2ab64b57a5107bdde6f.png"><br>查看 worker node 的路由表<br><img data-src="http://oss.xdai.vip/md-note/imgs/470af4f404b24f67b7602c3915385866.png" alt="3885e04cc52b51af9d9bcde2688d0dfd.png"><br>在 pod 上 traceroute 查看数据转发路径（跨 node ）<br><img data-src="http://oss.xdai.vip/md-note/imgs/2a87555a8ab240cf8adb2cd42dd5b356.png" alt="8a374dbb35e40ab2eb25d2fa78605c47.png"><br>在 pod 上 traceroute 查看转发路径（同 node）<br><img data-src="http://oss.xdai.vip/md-note/imgs/bedd790a18cb47e7b0a372bd0f1be401.png" alt="d8e1cb9ffea64e07e4bba730f1594fe7.png"></p>
<h3 id="IPIP"><a href="#IPIP" class="headerlink" title="IPIP"></a>IPIP</h3><p>Pure BGP 实现的时候，同一个 node 网卡出来的数据包会有多个源 IP，而且 pod 网络可能会与物理网络冲突。<br>Calico 使用 IP in IP 封装协议来实现，外层 IP Header 协议号是 4，也是一种隧道技术，但是封装简单，无法实现多租户（GRE 可以）。<br>实现方式与 flannel 类似，会新增一个 ipip 类型的 netdev 设备，路由表中将远端 node 的路由指向 ipip 设备，进行封装。<br>同 work node pod 通信，与 pure BGP 一样，直接通过主机明细通信；跨 work node 通信，多了一层 ipip 的封装。<br><img data-src="http://oss.xdai.vip/md-note/imgs/090ec11ace8c4d1f84ac8bab417b62ad.png" alt="ac657457ee5f50ef8d7efad6de5ddc08.png"></p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>修改 calico 配置文件，打开 ipip 选项，可以不用重新部署，直接在之前 pure bgp 的基础之上，导出相关的配置文件进行修改。<br>将当前的 ipPool 配置导出，修改 ipip 选项为 always</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看当前的 ipPool 配置</span><br><span class="line">x@x-vm:~$ calicoctl get ipPool -o wide</span><br><span class="line">NAME                  CIDR          NAT    IPIPMODE   VXLANMODE   DISABLED   SELECTOR   </span><br><span class="line">default-ipv4-ippool   11.0.0.0/16   true   Never      Never       false      all()</span><br><span class="line"># 导出配置</span><br><span class="line">calicoctl get ipPool -o yaml &gt; calico_ipip.yaml</span><br><span class="line"># 修改 ipip 选项</span><br><span class="line"># vim calico_ipip.yaml</span><br><span class="line">    cidr: 11.0.0.0/16</span><br><span class="line">    ipipMode: Always</span><br><span class="line">    natOutgoing: true</span><br><span class="line"># 应用配置</span><br><span class="line">x@x-vm:~$ calicoctl apply -f calico_ipip.yaml </span><br><span class="line">Successfully applied 1 &#x27;IPPool&#x27; resource(s)</span><br><span class="line"># 再次查看 ipPool 选项，看到 ipip 已经打开</span><br><span class="line">x@x-vm:~$ calicoctl get ipPool -o wide</span><br><span class="line">NAME                  CIDR          NAT    IPIPMODE   VXLANMODE   DISABLED   SELECTOR   </span><br><span class="line">default-ipv4-ippool   11.0.0.0/16   true   Always     Never       false      all()     </span><br></pre></td></tr></table></figure>
<p>查看网卡详细信息，新增了 tunnel 0，占用了一个 pod 地址，类型为 ipip，remote 为 any，即可以向任意远端发送数据包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip -d addr</span><br><span class="line">...</span><br><span class="line">10: tunl0@NONE: &lt;NOARP,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0 promiscuity 0 </span><br><span class="line">    ipip any remote any local any ttl inherit nopmtudisc numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 </span><br><span class="line">    inet 11.0.82.5/32 brd 11.0.82.5 scope global tunl0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><p>分别在两个node上各创建一个临时的 pod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl run -it --rm --restart=Never test1 --image busybox --overrides=&#x27;&#123;&quot;apiVersion&quot;: &quot;v1&quot;,&quot;spec&quot;: &#123;&quot;nodeSelector&quot;: &#123;&quot;kubernetes.io/hostname&quot;: &quot;x-vm&quot;&#125;&#125;&#125;&#x27; sh </span><br><span class="line">kubectl run -it --rm --restart=Never test2 --image busybox --overrides=&#x27;&#123;&quot;apiVersion&quot;: &quot;v1&quot;,&quot;spec&quot;: &#123;&quot;nodeSelector&quot;: &#123;&quot;kubernetes.io/hostname&quot;: &quot;worker&quot;&#125;&#125;&#125;&#x27; sh</span><br></pre></td></tr></table></figure>
<p>查看 pod 信息，分布在不同的 node 上<br><img data-src="http://oss.xdai.vip/md-note/imgs/c8a0646038b34dc89030a7e107b17bd1.png" alt="706bfc0afa48e5d3a053084326dd28b7.png"><br>pod test1 去 ping test2，在物理网卡上抓包，指定 ip proto 4，可以看到封装的报文<br><img data-src="http://oss.xdai.vip/md-note/imgs/a3d1d03ef1af4d7e910ea9c1cd307b4d.png" alt="34f2405eb443b6ed28c855034802c719.png"><br>在 tunl0 上抓包，可以看到两个 pod 的原始数据包<br><img data-src="http://oss.xdai.vip/md-note/imgs/ff8b8fb1a8a94670bda0cb1c2a91930e.png" alt="093350cd412cb02140b7528b7ff30d93.png"><br>pod test1 上 traceroute test2，可以看到路径，第一跳到了当前 node ，第二跳到了远端 node 的 tunl0，最终到达 test2<br><img data-src="http://oss.xdai.vip/md-note/imgs/a611f3361b984476b7b928345da9feac.png" alt="60c7f601cf9f8eef1e183f2cf8ee24aa.png"></p>
]]></content>
      <categories>
        <category>网络技术</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>flannel 学习笔记</title>
    <url>/posts/1f32c30b.html</url>
    <content><![CDATA[<p>Flannel 是一种 CNI 解决方案，也可以为 Dokcer 提供服务，对 k8s 而言，是一个网络插件。</p>
<ul>
<li>实现了 CNI 的网络控制平面软件</li>
<li>属于 coreOS 的子项目</li>
<li>通过配置主机路由或者 overlay，避免对物理路由器进行配置<ul>
<li>VxLAN</li>
<li>UDP</li>
<li>Host-GW</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>和 k8s 集成时，运行在 work node 上面，监听 k8s master 的状态，共用 k8s 的控制节点的 etcd 作为自己的数据库。<br><img data-src="http://oss.xdai.vip/md-note/imgs/cb1fdf9361814352acf0dde7b610d3b7.png" alt="205826f29a20b12c84a5940a76d121f0.png"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>节点分布<br><img data-src="http://oss.xdai.vip/md-note/imgs/c212e02daa004bea9274384d818f7a0c.png" alt="37ae6a952c139971c3cdbac8588173f6.png"></p>
<ol>
<li><p>master node</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化 master 节点</span><br><span class="line">sudo kubeadm reset</span><br><span class="line">sudo kubeadm init --config kubadm.yaml </span><br><span class="line"># 下载 flannel 配置文件</span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"># 修改配置文件，net-json 改为 k8s 安装的 podSubnet，type 默认为 vxlan </span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;,</span><br><span class="line">   &quot;Directrouting&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"># 部署</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line"># 查看</span><br><span class="line">kubectl get pods --all-namespaces</span><br><span class="line">---</span><br><span class="line">NAMESPACE     NAME                           READY   STATUS              RESTARTS   AGE</span><br><span class="line">kube-system   coredns-66bff467f8-m7ghl       0/1     ContainerCreating   0          11m</span><br><span class="line">kube-system   coredns-66bff467f8-mgnj7       0/1     ContainerCreating   0          11m</span><br><span class="line">kube-system   etcd-x-vm                      1/1     Running             0          11m</span><br><span class="line">kube-system   kube-apiserver-x-vm            1/1     Running             1          11m</span><br><span class="line">kube-system   kube-controller-manager-x-vm   1/1     Running             0          11m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-g7hl9    1/1     Running             0          35s</span><br><span class="line">kube-system   kube-proxy-5x7l5               1/1     Running             0          11m</span><br><span class="line">kube-system   kube-scheduler-x-vm            1/1     Running             0          11m</span><br><span class="line"># 多次查看，可以看到 coredns Pending -&gt; ContainerCreating -&gt; Running，因为 flannel 初始化初始化完成之后，k8s 认为当前节点可用，就创建了 coredns</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>worker node</p>
<p>安装 docker、kubeadm，关闭 swap，加入到集群中,hostname 不能重复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在 master node 上初始化完成之后，会输出如下 token</span><br><span class="line">kubeadm join 192.168.121.137:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:719b052641c7681b770f9609e82d6a8001ef9aa1125db6cea7b1a452d555c34a</span><br><span class="line"># 加入完成后，在 master node 上查看</span><br><span class="line">kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES    AGE   VERSION</span><br><span class="line">worker   Ready    &lt;none&gt;   52s   v1.18.4</span><br><span class="line">x-vm     Ready    master   23m   v1.18.4</span><br></pre></td></tr></table></figure>

<p>在 worker node 上查看容器,确认 flannel、kube-proxy 已经运行<br><img data-src="http://oss.xdai.vip/md-note/imgs/9a28346a36c34ec48625faf2cb798116.png" alt="4378c8c0098fd036be47a1d0177623c3.png"></p>
</li>
<li><p>调整 coredns，使其分布到 worker node 上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -n 指定 namespace，先删除</span><br><span class="line">kubectl scale -n kube-system  deployment.v1.apps/coredns --replicas=0</span><br><span class="line"># 再将数量调整为 2，期望结果是两个 codedns 的 pod 分布到两个节点上</span><br><span class="line">kubectl scale -n kube-system  deployment.v1.apps/coredns --replicas=2</span><br></pre></td></tr></table></figure>

<p>查看 pod 分布情况 <code>kubectl get pods --all-namespaces -o wide</code>,已经分布到两个节点上<br><img data-src="http://oss.xdai.vip/md-note/imgs/1894bebf5e304dcd8567521f76e427bf.png" alt="216db286ae71b105eb3bd7b2a136de02.png"></p>
<p>查看 worker node 网卡信息，可以看到 doredns 容器对应的 veth 已经存在，而且也有了 cni 网卡<br><img data-src="http://oss.xdai.vip/md-note/imgs/41e04f84473b429c8681e52ef56aea40.png" alt="f027622b6f15a60cb387bb86f214d02e.png"></p>
</li>
</ol>
<h2 id="host-gw-实现"><a href="#host-gw-实现" class="headerlink" title="host-gw 实现"></a>host-gw 实现</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>在 kube-net 网络实现中：</p>
<ul>
<li>同 node 中的 pod 互相通信是通过 cbr0 网桥二层互通</li>
<li>跨 node 通信是通过主机的默认路由，路由到物理网络中进行数据转发，此时需要在物理路由器上进行路由相关的配置</li>
</ul>
<p>部署 flannel 时，将配置文件中 <code>net-json</code> 字段的 <code>Type</code> 修改为 <code>host-gw</code> 。<br>Flannel host-gw 实现方案中，由于 linux 具有路由转发功能，所以可以将物理路由器相关的配置下沉到 work node (主机)上，由主机进行路由，类似于DVR，也避免了单点故障。<br>Flannel 连接 k8s 的数据库，每个 node 上的 flanned 进程知道所有 podSubnet 对应的 node，进而在主机的网络空间中配置 podSubnet 的路由指向对应的 node。<br>Flannel 环境中连接 pod 的 Linuxbridge 为 cni0（kube-net 是 cbr0），<strong>所有的 work node 必须在同一个二层网络中（添加路由时必须是二层可达才会生效）</strong></p>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>Flannel 安装完成后，查看路由信息：<br><img data-src="http://oss.xdai.vip/md-note/imgs/de11dfd3c1b547eab756b7674f6b7f3f.png" alt="查看路由信息.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在 master node 上创建一个临时的 pod，使用 nodeSelector 指定运行的 node</span><br><span class="line">kubectl run -it --rm --restart=Never test1 --image busybox --overrides=&#x27;&#123;&quot;apiVersion&quot;: &quot;v1&quot;,&quot;spec&quot;: &#123;&quot;nodeSelector&quot;: &#123;&quot;kubernetes.io/hostname&quot;: &quot;x-vm&quot;&#125;&#125;&#125;&#x27; sh</span><br><span class="line"># 新开一个窗口，在 work node 上创建一个临时的 pod</span><br><span class="line">kubectl run -it --rm --restart=Never test2 --image busybox --overrides=&#x27;&#123;&quot;apiVersion&quot;: &quot;v1&quot;,&quot;spec&quot;: &#123;&quot;nodeSelector&quot;: &#123;&quot;kubernetes.io/hostname&quot;: &quot;worker&quot;&#125;&#125;&#125;&#x27; sh</span><br></pre></td></tr></table></figure>

<p>新开一个窗口，检查一个 pod 运行情况，可以看到分布在两个 node 上,IP 分别是 11.0.0.5 和 11.0.1.3<br><img data-src="http://oss.xdai.vip/md-note/imgs/48011100fe07463887b9271e161a70bd.png" alt="7de41a1c0421d0999013099aa1f28edd.png"><br>用 pod test1 去 ping test2，在 work node 上抓包<br><img data-src="http://oss.xdai.vip/md-note/imgs/65cb77b580e14a44bf68480fa25b0f83.png" alt="5ef90a49d64b4faa06f19d3273a2e4aa.png"><br>可以从物理网卡抓到两个 pod 之间的通信流量<br>在 pod test1 上 traceroute test2，可以看到路径经过了 work node 到达 test2<br><img data-src="http://oss.xdai.vip/md-note/imgs/8bb165ba7ae74e7fa9648e13c660b42d.png" alt="460c4781a35299373800e1bd52c187f0.png"></p>
<h2 id="VxLAN-实现"><a href="#VxLAN-实现" class="headerlink" title="VxLAN 实现"></a>VxLAN 实现</h2><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><ul>
<li>Ethernet Frame 封装到 UDP 中</li>
<li>不考虑物理网络冲突问题</li>
<li>封装需要额外的 50 字节（网卡默认 MTU 为 1450）</li>
<li>允许 woker node 分布到三层网络中</li>
</ul>
<p>VxLAN 数据包封装：<br><img data-src="http://oss.xdai.vip/md-note/imgs/ce7d008af56c44b2862fa2705aeb0fa7.png" alt="24d7e3e98a34313a7f7b2a54047828aa.png"></p>
<p>Flannel VxLAN 基于 Linux 原生的方式实现 VxLAN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Linux 通过 VxLAN 字节口实现 VxLAN 的封装解封装</span><br><span class="line">ip link add vxlan0 type vxlan id 1 \</span><br><span class="line">remote 192.168.121.137 \</span><br><span class="line">local 192.168.121.138 \</span><br><span class="line">dstport 8472 \</span><br><span class="line">dev eth0</span><br><span class="line"># 通过监听端口来拦截数据进行封装解封装</span><br></pre></td></tr></table></figure>

<h3 id="Flannel-的-VxLAN-实现"><a href="#Flannel-的-VxLAN-实现" class="headerlink" title="Flannel 的 VxLAN 实现"></a>Flannel 的 VxLAN 实现</h3><p>Flannel 会在 node 上额外创建 <code>flannel.&lt;vni&gt;</code> 设备，挂载的 ip 为当前 node podSubnet 的第 0 个地址作为 VTEP 地址。</p>
<p>当有多个 node 时，如果按照 Linux 原生方式实现 VxLAN 时，每个 node 都要和其他 node 建立 VxLAN 隧道，也就是每个 node 上都要创建多个类型为 vxlan 的 netdev 设备，这样子接口的数量就是 n^2。</p>
<p>为了避免这种情况，flannel 添加 flannel.vni 子接口的时候，并没有指定 remote ip，而是添加了对端 flannel.vni 的静态 arp 表项，并添加二层转规则（bridge fdb 查看），如果是发往对端的 flannel.vni 的 MAC 地址的话，从本端子接口发出，且指定了远端的 VTEP 地址。</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/e80aa803a47f47278272b7f5daa254d3.png" alt="83b6071b31e417bfa2ed3d00c4fae740.png"></p>
<h4 id="Direct-routing-实现"><a href="#Direct-routing-实现" class="headerlink" title="Direct routing 实现"></a>Direct routing 实现</h4><p>传统的 VXLAN 使用隧道的通信方式会导致报文开销及流量增大，对于节点之间二层网络的通信，可以直接使用路由的方式而不用隧道，仅在跨三层通信时使用隧道封装，这样可以大大节省开销，二层通信性能也接近物理网络。</p>
<p>仅使用 VXLAN，未启用 direct routing 时，路由表中同一二层网络的节点，路由表显示下一跳为 flannel.vni；启用 direct routing 后，路由表中下一跳变为物理网卡。</p>
<p>启用方式，修改配置文件中 <code>Directrouting</code> 字段为 true</p>
<h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><ol>
<li><p>清理 host-gw 环境，修改配置文件，重新部署 flannel</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除 flannel</span><br><span class="line">kubectl delete -f kube-flannel.yml</span><br><span class="line"># 删除 coredns</span><br><span class="line">kubectl scale -n kube-system  deployment.v1.apps/coredns --replicas=0</span><br><span class="line"># 修改 kube-flannel.yml 中 net-json type 为 vxlan</span><br><span class="line"># 重新部署</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line"># 添加 coredns</span><br><span class="line">kubectl scale -n kube-system  deployment.v1.apps/coredns --replicas=2</span><br></pre></td></tr></table></figure></li>
<li><p>查看网卡信息</p>
<p>ip addr，可以看到 vni 接口<br><img data-src="http://oss.xdai.vip/md-note/imgs/8189732dfa6d406b802d5e7f0edb1b0d.png" alt="d90f30a8130cb9d4ac028ee94ea35d0d.png"><br>查看 arp 表<br><img data-src="http://oss.xdai.vip/md-note/imgs/8ad51f8196b449959361ac3028095525.png" alt="a6869b22d10a7855cafd6f35fd084946.png"><br>查看转发数据库，bridge fdb<br><img data-src="http://oss.xdai.vip/md-note/imgs/1b4f1e1199ce46cc968252a5a607befb.png" alt="849787945a8e0d6b0f3e35c36ff1121f.png"><br>在 work node 上查看接口，MAC 地址和 master node 上的转发表一致<br><img data-src="http://oss.xdai.vip/md-note/imgs/9a63b0df93454d8f857dd421baf25f09.png" alt="88fe04fcaf7986867947389112ac51f2.png"></p>
</li>
<li><p>创建 pod ，抓包验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在 master node 上创建一个临时的 pod，使用 nodeSelector 指定运行的 node</span><br><span class="line">kubectl run -it --rm --restart=Never test1 --image busybox --overrides=&#x27;&#123;&quot;apiVersion&quot;: &quot;v1&quot;,&quot;spec&quot;: &#123;&quot;nodeSelector&quot;: &#123;&quot;kubernetes.io/hostname&quot;: &quot;x-vm&quot;&#125;&#125;&#125;&#x27; sh</span><br><span class="line"># 新开一个窗口，在 work node 上创建一个临时的 pod</span><br><span class="line">kubectl run -it --rm --restart=Never test2 --image busybox --overrides=&#x27;&#123;&quot;apiVersion&quot;: &quot;v1&quot;,&quot;spec&quot;: &#123;&quot;nodeSelector&quot;: &#123;&quot;kubernetes.io/hostname&quot;: &quot;worker&quot;&#125;&#125;&#125;&#x27; sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 pods 分布情况：<br><img data-src="http://oss.xdai.vip/md-note/imgs/c090d6db08f5463daee24f827f9fbc41.png" alt="b4b779f57a9c73b69244c34a23134b32.png"></p>
<p>用 test1 ping test2 ，在 worker 物理接口上抓包，可以看到封装数据包的内容<br><img data-src="http://oss.xdai.vip/md-note/imgs/d491e1966cd3432485407baf659b9920.png" alt="2ba4920d026f368064eefa2c74f118e8.png"></p>
</li>
</ol>
<h2 id="UDP-实现"><a href="#UDP-实现" class="headerlink" title="UDP 实现"></a>UDP 实现</h2><p>非 VxLAN 的 UDP 数据封装，不推荐使用<br>数据经过用户态转发，性能低</p>
]]></content>
      <categories>
        <category>网络技术</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>bash history 的几个常用选项</title>
    <url>/posts/79fcabfa.html</url>
    <content><![CDATA[<h2 id="删除无意义命令"><a href="#删除无意义命令" class="headerlink" title="删除无意义命令"></a>删除无意义命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HISTIGNORE=&#x27;pwd:exit:fg:bg:top:clear:history:ls:uptime:df&#x27;</span><br></pre></td></tr></table></figure>

<p>使用该选项后，在历史记录中就不会记录选项后包含的命令。</p>
<h2 id="忽略敏感命令"><a href="#忽略敏感命令" class="headerlink" title="忽略敏感命令"></a>忽略敏感命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HISTCONTROL=ignorespace</span><br></pre></td></tr></table></figure>

<p>例如：你不想在历史记录中出现带有密码的命令，可以在输入密码的命令前添加空格，这样就不会保存在历史记录中。</p>
<span id="more"></span>

<h2 id="删除重复命令"><a href="#删除重复命令" class="headerlink" title="删除重复命令"></a>删除重复命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HISTCONTROL=ignoredups</span><br></pre></td></tr></table></figure>

<p>使用改选项后，历史记录中不会记录<strong>连续重复执行</strong>的命令，例如：连续输入了 3 次 ls，只会记录一次。</p>
<p>如果你想更为激进，那么可以使用以下选项，删除整个历史记录里面的重复项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HISTCONTROL=erasedups</span><br></pre></td></tr></table></figure>

<h2 id="不丢失重要命令"><a href="#不丢失重要命令" class="headerlink" title="不丢失重要命令"></a>不丢失重要命令</h2><p>   Bash 的 history 文件默认是覆盖，如果并发打开了多个 Shell 会话，只会记录最后一个退出的 Shell 的命令历史（历史命令保存在内存中，且在退出时写入历史文件）。</p>
<p>   使用以下选项，将历史记录修改为追加模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shopt -s histappend</span><br></pre></td></tr></table></figure>

<p>与此同时，在共享 Shell 的情况下，可能会由于历史文件太小而丢失重要的记录，因此，可以把历史记录的上限调大，避免丢失有用的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HISTSIZE=10000</span><br><span class="line">HISTFILESIZE=10000</span><br></pre></td></tr></table></figure>

<p><code>HISTFILESIZE</code> 定义了在 <code>.bash_history</code> 中保存命令的记录总数.<br><code>HISTSIZE</code> 定义了 <code>history</code> 命令输出的记录数</p>
<h2 id="记录命令执行时间"><a href="#记录命令执行时间" class="headerlink" title="记录命令执行时间"></a>记录命令执行时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HISTTIMEFORMAT=&quot;%F %T &quot; </span><br></pre></td></tr></table></figure>

<p><code>HISTTIMEFORMAT</code> 的格式是 <code>strftime</code> 函数的格式：%F : Y-M-D ，%T:  H-M-S，需要在后面再加个空格，不然时间会和命令连到一起。</p>
<h2 id="修改历史记录文件名称"><a href="#修改历史记录文件名称" class="headerlink" title="修改历史记录文件名称"></a>修改历史记录文件名称</h2><p>默认情况下，历史记录都保存在 <code>~/.bash_history</code> 文件中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HISTFILE=/var/history/$USER-$UID.log</span><br></pre></td></tr></table></figure>

<p>使用<code>HISTFILE</code>将历史记录保存到指定的文件中。</p>
<h2 id="实时追加历史命令"><a href="#实时追加历史命令" class="headerlink" title="实时追加历史命令"></a>实时追加历史命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PROMPT_COMMAND=&quot;history -a&quot;</span><br></pre></td></tr></table></figure>

<p><code>PROMPT_COMMAND</code> 添加的是每个命令后执行的命令，添加上 <code>history -a</code> 命令，可以直接将当前缓冲区的命令写入到文件中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">history</span> 命令一些常用选项：</span></span><br><span class="line">-N: 显示历史记录中最近的N个记录；</span><br><span class="line">-c：清空当前历史命令；</span><br><span class="line">-a：将历史命令缓冲区中命令写入历史命令文件中；</span><br><span class="line">-r：将历史命令文件中的命令读入当前历史命令缓冲区；</span><br><span class="line">-w：将当前历史命令缓冲区命令写入历史命令文件中;</span><br><span class="line">-d&lt;offset&gt;：删除历史记录中第offset个命令</span><br><span class="line">-n&lt;filename&gt;：读取指定文件</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IPv6 操作： ping telnet ssh curl wget</title>
    <url>/posts/799dfd19.html</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">ping -6 -I &lt;interface&gt; &lt;ipv6 address&gt;</span></span><br><span class="line">ping -6 -I eth0 fe80::3016:9242:18fb:5a07</span><br><span class="line">ping6 -I eth0 fe80::3016:9242:18fb:5a07</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">SSH</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ssh &lt;username&gt;@&lt;ipv6 address&gt;%&lt;interface&gt;</span></span><br><span class="line">ssh root@fe80::3016:9242:18fb:5a07%eth0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">telnet</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">telnet -6 &lt;username&gt;@&lt;ipv6 address&gt;%&lt;interface&gt; [port]</span></span><br><span class="line">telnet -6 fe80::3016:9242:18fb:5a07%eth0 22</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">IPv6 中的 url 地址要用 [] 括起来，端口在 ] 后</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">curl 不支持链路本地地址，即 fe80 开头的地址，内网测试需要修改其他地址~报错：curl: (7) Failed to connect to fe80::6d7d:7c73:5851:e712: Invalid argument</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"> -g, --globoff  Disable URL sequences and ranges using &#123;&#125; and []（禁用 url 中使用 &#123;&#125; 和 [] 来表示序列和范围）</span></span><br><span class="line">curl -6 -g &#x27;http://[20a0::6d7d:7c73:5851:e712]:8888&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">wget</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">wget -6 &lt;ipv6 url&gt; ,也不支持链路本地地址：报错Connecting to [fe80::6d7d:7c73:5851:e712]:8888... failed: Invalid argument.</span></span><br><span class="line">wget -6  &#x27;http://[20a0::6d7d:7c73:5851:e712]:8888&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-g 参数引用：<a href="https://www.cnblogs.com/duhuo/p/5695256.html">Linux curl命令详解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ipv6</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 selenium 连接已经打开的 chrome 浏览器</title>
    <url>/posts/94ba5535.html</url>
    <content><![CDATA[<p>最近做在一些 web 自动化（其实是用 web 端来配置网络设备）<br>编写脚本时经常用到 debug 去提取网页中的一些元素并做测试，但是每次需要 debug 时都要打开新的浏览器，比较麻烦，所以如果能直接连接到已经打开的浏览器，会非常方便。</p>
<p>操作步骤：</p>
<ol>
<li><p>使用参数启动浏览器<br>cmd 定位到 chrome 所在目录，使用以下参数启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Google\Chrome\Application&gt; .\chrome.exe --remote-debugging-port=9999 --user-data-dir=&quot;C:\test&quot;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/20200423151746470.png" alt="截图"><br>参数：<br>port 可以是任意端口，只要不和本地已开放的端口冲突即可；用户目录最好是一个空文件夹，浏览器启动时会以空配置启动，然后将初始化配置放到这个目录里面。</p>
<p>另一种简单的方法：可以在桌面新建一个 chrome 的快捷方式，然后再目标里面写上参数（方便，推荐）。<br><img data-src="https://img-blog.csdnimg.cn/20200423151824270.png" alt="截图"></p>
</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p>在 python 中连接已打开的浏览器</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_experimental_option(<span class="string">&quot;debuggerAddress&quot;</span>, <span class="string">&quot;127.0.0.1:9999&quot;</span>)</span><br><span class="line"><span class="comment"># selenium 运行时会从系统的环境变量中查找 webdriver.exe</span></span><br><span class="line"><span class="comment"># 一般把 webdriver.exe 放到 python 目录中，这样就不用在代码中指定。</span></span><br><span class="line">chrome_driver = <span class="string">&quot;C:\chromedriver.exe&quot;</span></span><br><span class="line">driver = webdriver.Chrome(chrome_driver, chrome_options=chrome_options)</span><br><span class="line">driver.get(https://www.baidu.com/<span class="string">&quot;)</span></span><br><span class="line"><span class="string">print(driver.title)</span></span><br><span class="line"><span class="string">driver.quit()</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样就可以直接操作 步骤1 中打开的浏览器了，其他浏览器同理。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>NetDevOps</category>
      </categories>
  </entry>
  <entry>
    <title>Python 下载加速：pip pypi 使用国内源及永久配置 pip 源</title>
    <url>/posts/8a28e619.html</url>
    <content><![CDATA[<h2 id="国内常见的-pip-源"><a href="#国内常见的-pip-源" class="headerlink" title="国内常见的 pip 源"></a>国内常见的 pip 源</h2><table>
<thead>
<tr>
<th>来源</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>阿里云</td>
<td><code>http://mirrors.aliyun.com/pypi/simple/</code></td>
</tr>
<tr>
<td>中国科技大学</td>
<td><code>https://pypi.mirrors.ustc.edu.cn/simple/</code></td>
</tr>
<tr>
<td>豆瓣</td>
<td><code>http://pypi.douban.com/simple/</code></td>
</tr>
<tr>
<td>清华大学</td>
<td><code>https://pypi.tuna.tsinghua.edu.cn/simple/</code></td>
</tr>
</tbody></table>
<h2 id="临时使用方法"><a href="#临时使用方法" class="headerlink" title="临时使用方法"></a>临时使用方法</h2><p>-i 加 url，举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install selenium -i http://pypi.douban.com/simple</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>如果使用的是 http 的源，会报如下错误（https 源不会有问题）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">WARNING: The repository located at pypi.douban.com is not a trusted or secure host and is being ignored. If this repository is available via HTTPS we recommend you use HTTPS instead, otherwise you may silence this warning and allow it anyway with &#x27;--trusted-host pypi.douban.com&#x27;.</span><br></pre></td></tr></table></figure>
<p>此时需要信任主机，使用 <code>--trusted-host</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install selenium -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure>
<p>如果有报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: Cannot unpack file C:\Users\issusers\AppData\Local\Temp\pip-unpack-6x9ra6uh\simple.html (downloaded from C:\Users\issusers\AppData\Local\Temp\pip-req-build-zoljdd4t, content-type: text/html); cannot detect archive format</span><br><span class="line">ERROR: Cannot determine archive format of C:\Users\issusers\AppData\Local\Temp\pip-req-build-zoljdd4t</span><br></pre></td></tr></table></figure>
<p>说明该源下可能没有同步到你需要的包，可以尝试更换源进行下载。</p>
<h2 id="永久配置-pip-源"><a href="#永久配置-pip-源" class="headerlink" title="永久配置 pip 源"></a>永久配置 pip 源</h2><h3 id="通过编辑配置文件"><a href="#通过编辑配置文件" class="headerlink" title="通过编辑配置文件"></a>通过编辑配置文件</h3><p>在当前用户根目录下，创建 <code>.pip</code> 目录，编辑配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.pip</span><br><span class="line"><span class="built_in">tee</span> ~/.pip/pip.conf &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[global]</span><br><span class="line"><span class="built_in">timeout</span>=600</span><br><span class="line">index-url=https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>如果是 http 的源，配置文件最后还需要加上 <code>trusted-host=mirrors.aliyun.com</code></p>
<p>如果使用的是 windows 系统，同样在用户的家目录下创建 <code>.pip</code> 文件夹，并写入 <code>pip.conf</code> 配置文件。</p>
<p>具体路径为 <code>C:\Users\&#123;你的系统用户名&#125;\.pip\pip.conf</code></p>
<h3 id="通过命令行配置-pip-源-lt-—-推荐，效率高"><a href="#通过命令行配置-pip-源-lt-—-推荐，效率高" class="headerlink" title="通过命令行配置 pip 源 &lt;— 推荐，效率高"></a>通过命令行配置 pip 源 &lt;— 推荐，效率高</h3><p> 如果你不想编写配置文件，可以使用一条命令配置 pip 源，会自动生成以上目录及文件<br>升级 pip 到最新的版本 (&gt;&#x3D;10.0.0) 后进行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升级 pip</span></span><br><span class="line">pip install -i https://mirrors.aliyun.com/pypi/simple/ pip -U</span><br><span class="line"><span class="comment"># 生成 pip 配置文件</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>在Netmiko中使用TextFSM</title>
    <url>/posts/59f6b218.html</url>
    <content><![CDATA[<h3 id="在-netmiko-中使用-TextFSM"><a href="#在-netmiko-中使用-TextFSM" class="headerlink" title="在 netmiko 中使用 TextFSM"></a>在 netmiko 中使用 TextFSM</h3><h4 id="安装模板"><a href="#安装模板" class="headerlink" title="安装模板"></a>安装模板</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/networktocode/ntc-templates.git</span><br></pre></td></tr></table></figure>
<h4 id="查看安装完成"><a href="#查看安装完成" class="headerlink" title="查看安装完成"></a>查看安装完成</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ <span class="built_in">ls</span> ~/ntc-templates/templates/index</span><br></pre></td></tr></table></figure>
<p>Netmiko已配置为自动在〜&#x2F;ntc-template&#x2F;templates&#x2F;index中查找ntc-templates索引文件。另外，可以通过设置以下环境变量来明确告诉Netmiko在哪里寻找TextFSM模板目录（请注意，此目录中必须有一个索引文件）：<br><code>export NET_TEXTFSM=/path/to/ntc-templates/templates/</code></p>
<span id="more"></span>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>查看<code>ntc-templates\index</code>文件，确保其中有正确的命令且目录下存在模板文件。之后在 netmiko 中将<code>use_textfsm = True</code>参数添加到<code>send_command()</code>方法或<code>send_command_timing()</code>方法，即可获得结构化的数据；如果不存在模板，则正常返回字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">net_connect.send_command(<span class="string">&quot;show ip int brief&quot;</span>, use_textfsm=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>OUTPUT：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[&#123;&#x27;intf&#x27;: &#x27;FastEthernet0&#x27;,</span><br><span class="line">  &#x27;ipaddr&#x27;: &#x27;unassigned&#x27;,</span><br><span class="line">  &#x27;status&#x27;: &#x27;down&#x27;,</span><br><span class="line">  &#x27;proto&#x27;: &#x27;down&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;intf&#x27;: &#x27;FastEthernet1&#x27;,</span><br><span class="line">  &#x27;ipaddr&#x27;: &#x27;unassigned&#x27;,</span><br><span class="line">  &#x27;status&#x27;: &#x27;down&#x27;,</span><br><span class="line">  &#x27;proto&#x27;: &#x27;down&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;intf&#x27;: &#x27;FastEthernet2&#x27;,</span><br><span class="line">  &#x27;ipaddr&#x27;: &#x27;unassigned&#x27;,</span><br><span class="line">  &#x27;status&#x27;: &#x27;down&#x27;,</span><br><span class="line">  &#x27;proto&#x27;: &#x27;down&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;intf&#x27;: &#x27;FastEthernet3&#x27;,</span><br><span class="line">  &#x27;ipaddr&#x27;: &#x27;unassigned&#x27;,</span><br><span class="line">  &#x27;status&#x27;: &#x27;down&#x27;,</span><br><span class="line">  &#x27;proto&#x27;: &#x27;down&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;intf&#x27;: &#x27;FastEthernet4&#x27;,</span><br><span class="line">  &#x27;ipaddr&#x27;: &#x27;10.220.88.20&#x27;,</span><br><span class="line">  &#x27;status&#x27;: &#x27;up&#x27;,</span><br><span class="line">  &#x27;proto&#x27;: &#x27;up&#x27;&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="如何编写自定义TextFSM模板"><a href="#如何编写自定义TextFSM模板" class="headerlink" title="如何编写自定义TextFSM模板"></a><a href="https://github.com/google/textfsm/wiki/Code-Lab">如何编写自定义TextFSM模板</a></h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>使用一系列正则表达式来定义要从纯文本输出中提取的数据。下面是一个处理思科接口的模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cisco_asa_show_interface.template</span><br><span class="line">Value Required INTERFACE (\S+)</span><br><span class="line">Value INTERFACE_ZONE (.+?)</span><br><span class="line">Value LINK_STATUS (\w+)</span><br><span class="line">Value PROTOCOL_STATUS (.*)</span><br><span class="line">Value HARDWARE_TYPE ([\w ]+)</span><br><span class="line">Value BANDWIDTH (\d+\s+\w+)</span><br><span class="line">Value DELAY (\d+\s+\w+)</span><br><span class="line">Value DUPLEX (\w+\-\w+)</span><br><span class="line">Value SPEED (\d+\w+\s\w+)</span><br><span class="line">Value DESCRIPTION (.*)</span><br><span class="line">Value ADDRESS ([a-zA-Z0-9]+.[a-zA-Z0-9]+.[a-zA-Z0-9]+)</span><br><span class="line">Value MTU (\d+)</span><br><span class="line">Value IP_ADDRESS (\d+\.\d+\.\d+\.\d+)</span><br><span class="line">Value NET_MASK (\d+\.\d+\.\d+\.\d+)</span><br><span class="line">Value ONEMIN_IN_PPS (\d+)</span><br><span class="line">Value ONEMIN_IN_RATE (\d+)</span><br><span class="line">Value ONEMIN_OUT_PPS (\d+)</span><br><span class="line">Value ONEMIN_OUT_RATE (\d+)</span><br><span class="line">Value ONEMIN_DROP_RATE (\d+)</span><br><span class="line">Value FIVEMIN_IN_PPS (\d+)</span><br><span class="line">Value FIVEMIN_IN_RATE (\d+)</span><br><span class="line">Value FIVEMIN_OUT_PPS (\d+)</span><br><span class="line">Value FIVEMIN_OUT_RATE (\d+)</span><br><span class="line">Value FIVEMIN_DROP_RATE (\d+)</span><br><span class="line"></span><br><span class="line">Start</span><br><span class="line">  ^.*Interface $&#123;INTERFACE&#125; &quot;$&#123;INTERFACE_ZONE&#125;&quot;, is $&#123;LINK_STATUS&#125;.*protocol is $&#123;PROTOCOL_STATUS&#125;</span><br><span class="line">  ^\s+Hardware is $&#123;HARDWARE_TYPE&#125; -&gt; Continue</span><br><span class="line">  ^.*BW $&#123;BANDWIDTH&#125;.*DLY $&#123;DELAY&#125;</span><br><span class="line">  ^.*\($&#123;DUPLEX&#125;.*Auto-Speed\($&#123;SPEED&#125;\)</span><br><span class="line">  ^.*Description: $&#123;DESCRIPTION&#125;</span><br><span class="line">  ^.*MAC address $&#123;ADDRESS&#125;.*MTU $&#123;MTU&#125;</span><br><span class="line">  ^.*IP address $&#123;IP_ADDRESS&#125;, .*subnet mask $&#123;NET_MASK&#125;</span><br><span class="line">  ^.*1 minute input rate $&#123;ONEMIN_IN_PPS&#125; pkts/sec,\s+$&#123;ONEMIN_IN_RATE&#125; bytes/sec</span><br><span class="line">  ^.*1 minute output rate $&#123;ONEMIN_OUT_PPS&#125; pkts/sec,\s+$&#123;ONEMIN_OUT_RATE&#125; bytes/sec</span><br><span class="line">  ^.*1 minute drop rate, $&#123;ONEMIN_DROP_RATE&#125;</span><br><span class="line">  ^.*5 minute input rate $&#123;FIVEMIN_IN_PPS&#125; pkts/sec,\s+$&#123;FIVEMIN_IN_RATE&#125; bytes/sec</span><br><span class="line">  ^.*5 minute output rate $&#123;FIVEMIN_OUT_PPS&#125; pkts/sec,\s+$&#123;FIVEMIN_OUT_RATE&#125; bytes/sec</span><br><span class="line">  ^.*5 minute drop rate, $&#123;FIVEMIN_DROP_RATE&#125; -&gt; Record</span><br></pre></td></tr></table></figure>
<p>通过<code>show interface</code>获取到的原始文本字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># output of show interface</span><br><span class="line">interfaces = &#x27;&#x27;&#x27;</span><br><span class="line">Interface GigabitEthernet0/0 &quot;inside&quot;, is up, line protocol is up</span><br><span class="line">  Hardware is i82540EM rev02, BW 1000 Mbps, DLY 10 usec</span><br><span class="line">    Auto-Duplex(Full-duplex), Auto-Speed(1000 Mbps)</span><br><span class="line">    Input flow control is unsupported, output flow control is off</span><br><span class="line">    MAC address 0800.2735.03c6, MTU 1500</span><br><span class="line">    IP address 169.254.1.11, subnet mask 255.255.255.0</span><br><span class="line">    0 packets input, 0 bytes, 0 no buffer</span><br><span class="line">    Received 0 broadcasts, 0 runts, 0 giants</span><br><span class="line">    0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored, 0 abort</span><br><span class="line">    0 pause input, 0 resume input</span><br><span class="line">    0 L2 decode drops</span><br><span class="line">    1 packets output, 60 bytes, 0 underruns</span><br><span class="line">    0 pause output, 0 resume output</span><br><span class="line">    0 output errors, 0 collisions, 1 interface resets</span><br><span class="line">    0 late collisions, 0 deferred</span><br><span class="line">    0 input reset drops, 0 output reset drops</span><br><span class="line">    input queue (blocks free curr/low): hardware (511/511)</span><br><span class="line">    output queue (blocks free curr/low): hardware (511/510)</span><br><span class="line">  Traffic Statistics for &quot;inside&quot;:</span><br><span class="line">    0 packets input, 0 bytes</span><br><span class="line">    1 packets output, 28 bytes</span><br><span class="line">    0 packets dropped</span><br><span class="line">      1 minute input rate 0 pkts/sec,  0 bytes/sec</span><br><span class="line">      1 minute output rate 0 pkts/sec,  0 bytes/sec</span><br><span class="line">      1 minute drop rate, 0 pkts/sec</span><br><span class="line">      5 minute input rate 0 pkts/sec,  0 bytes/sec</span><br><span class="line">      5 minute output rate 0 pkts/sec,  0 bytes/sec</span><br><span class="line">      5 minute drop rate, 0 pkts/sec</span><br></pre></td></tr></table></figure>
<p>通过 TextFsm 进行处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import library</span></span><br><span class="line"><span class="keyword">import</span> textfsm</span><br><span class="line"></span><br><span class="line"><span class="comment"># open the template file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;cisco_asa_show_interface.template&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    template = textfsm.TextFSM(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># run the interface data through the template parser</span></span><br><span class="line">template.ParseText(interfaces)</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="string">&#x27;GigabitEthernet0/0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;inside&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;up&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;up&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;i82540EM rev02&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;1000 Mbps&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;10 usec&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Full-duplex&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;1000 Mbps&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0800.2735.03c6&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;1500&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;169.254.1.11&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;255.255.255.0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p>一些已经写好的华三设备的模板：<a href="https://github.com/xdai555/textfsm_hpe_cmw7">https://github.com/xdai555/textfsm_hpe_cmw7</a></p>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>netmiko</tag>
      </tags>
  </entry>
  <entry>
    <title>Jinja2 入门教程、基本概念、简单使用及使用 Jinja2 生成交换机配置</title>
    <url>/posts/68254dc6.html</url>
    <content><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><a href="https://jinja.palletsprojects.com/en/2.11.x/templates/">官方文档</a></p>
<p>Jinja 模板只是一个文本文件，可以 基于模板生成任何基于文本的格式（HTML、XML、CSV、LaTeX 等），一般用在前端的项目中，渲染 HTML 文件。</p>
<p>作为网络工程师，可以将其用来批量生成网络设备的配置。</p>
<p>或者其他需要批量生成文本的场景中。</p>
<p>模板包含<strong>变量</strong>或<strong>表达式</strong>，这两者在模板求值的时候会被替换为值。模板中还有<strong>标签</strong>，控制模板的逻辑。模板语法的大量灵感来自于 Django 和 Python。</p>
<span id="more"></span>

<p>基本语法：</p>
<ul>
<li>语句 <code>&#123;% ... %&#125;</code></li>
<li>变量 <code>&#123;&#123; ... &#125;&#125;</code></li>
<li>注释 <code>&#123;# ... #&#125; </code></li>
</ul>
<p>常用的语句包括：for、if、set、include、block、filter 等</p>
<p>变量通过传递字典来进行使用，当使用 for 语句的时候，变量可以是列表。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>创建和渲染模板的最基本方法是通过 <code>Template</code>，通过创建一个 <code>Template</code> 的实例，<br>会得到一个新的模板对象，模板对象有一个 <code>render()</code> 的方法，该方法在调用 <em>dict</em> 或 <em>keywords</em> 参数时填充模板。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line">tmpl = Template(<span class="string">&#x27;hello &#123;&#123; name&#125;&#125;&#x27;</span>)</span><br><span class="line">result = tmpl.render(name = <span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">hello <span class="number">111</span></span><br></pre></td></tr></table></figure>

<h2 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h2><p>一般情况下，我们使用 <code>*.j2</code> 文件作为模板文件，用法如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template, FileSystemLoader, Environment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先告诉Jinja2模块，jinja模板文件路径在哪？(如当前目录)</span></span><br><span class="line">j2_loader = FileSystemLoader(<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后定义一个环境，告诉jinja2，从哪里调用模板</span></span><br><span class="line">env = Environment(loader=j2_loader)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后通过 get_template 获取并载入模板</span></span><br><span class="line">j2_tmpl = env.get_template(<span class="string">&#x27;./jinja2.j2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后传入参数，渲染模板</span></span><br><span class="line">result = j2_tmpl.render(name=<span class="string">&quot;xdai&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>模板 <code>jinja2.j2</code> 的内容如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat jinja2.j2</span></span><br><span class="line">This <span class="keyword">is</span> a Jinja2 template file created by &#123;&#123; name &#125;&#125;.</span><br></pre></td></tr></table></figure>
<p>最终打印结果如下，传入的 name 被赋值给了模板文件，并输出了最终结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a Jinja2 template file created by xdai.</span><br></pre></td></tr></table></figure>


<h2 id="for-语句的使用"><a href="#for-语句的使用" class="headerlink" title="for 语句的使用"></a>for 语句的使用</h2><p>现在有如模板文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat jinja2_for.j2</span><br><span class="line">&#123;% for name in names %&#125;</span><br><span class="line">Hello &#123;&#123; name &#125;&#125;.</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>通过传入一个列表来批量生成最终的结果。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template, FileSystemLoader, Environment</span><br><span class="line">j2_loader = FileSystemLoader(<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line">env = Environment(loader=j2_loader)</span><br><span class="line">j2_tmpl = env.get_template(<span class="string">&#x27;./jinja2_for.j2&#x27;</span>)</span><br><span class="line"><span class="comment"># 传入一个列表，对列表里面的人打招呼</span></span><br><span class="line">names = [<span class="string">&#x27;Zhang San&#x27;</span>, <span class="string">&#x27;Li Si&#x27;</span>, <span class="string">&#x27;Wang Wu&#x27;</span>]</span><br><span class="line">result = j2_tmpl.render(names=names)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Hello Zhang San.</span><br><span class="line"></span><br><span class="line">Hello Li Si.</span><br><span class="line"></span><br><span class="line">Hello Wang Wu.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 for 循环，批量生成了 Hello。</p>
<p>还可以传入列表，列表的值是一个字典，然后通过 for 和字典的 <code>.</code> 或者 <code>[]</code> 进行取值（和 Python 语法一致），将上面的模板文件改动如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat jinja2_for_with_dict.j2</span><br><span class="line">&#123;% for person in people %&#125;</span><br><span class="line">My name is &#123;&#123; person.name &#125;&#125;, and I am &#123;&#123; person[&#x27;age&#x27;] &#125;&#125; years old.</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>然后，编写代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template, FileSystemLoader, Environment</span><br><span class="line">j2_loader = FileSystemLoader(<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line">env = Environment(loader=j2_loader)</span><br><span class="line">j2_tmpl = env.get_template(<span class="string">&#x27;./jinja2_for_with_dict.j2&#x27;</span>)</span><br><span class="line"><span class="comment"># 传入一个列表，列表里面的人进行自我介绍</span></span><br><span class="line">people = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Zhang San&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Li Si&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Wang Wu&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;,</span><br><span class="line">]</span><br><span class="line">result = j2_tmpl.render(names=names)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">My name is Zhang San, and I am 18 years old.</span><br><span class="line"></span><br><span class="line">My name is Li Si, and I am 20 years old.</span><br><span class="line"></span><br><span class="line">My name is Wang Wu, and I am 22 years old.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="if-语句的使用"><a href="#if-语句的使用" class="headerlink" title="if 语句的使用"></a>if 语句的使用</h2><p>if 语句用来判断，当条件成立时，对语句块文件的内容进行渲染，条件判定失败后则跳过该语句块。</p>
<p>将上文中的 for 循环模板进行修改如下，年龄大于 18 的进行自我介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat jinja2_if.j2</span><br><span class="line">&#123;% for person in people %&#125;</span><br><span class="line">&#123;% if person.age &gt; 18 %&#125;</span><br><span class="line">My name is &#123;&#123; person.name &#125;&#125;, and I am &#123;&#123; person[&#x27;age&#x27;] &#125;&#125; years old.</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>代码与上面 for 语句的例子中相同，仅修改了加载模板的名字，打印结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">My name is Li Si, and I am 20 years old.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">My name is Wang Wu, and I am 22 years old.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，age 小于 18 的，没有输出相应的文字。</p>
<h2 id="Template-Inheritance-in-Jinja（继承）"><a href="#Template-Inheritance-in-Jinja（继承）" class="headerlink" title="Template Inheritance in Jinja（继承）"></a>Template Inheritance in Jinja（继承）</h2><p>在为网络设备配置创建更大、功能更多的模板文件时，可以使用模板继承，将模板分解开来。<br>比如，创建 VLAN、interface 、OSPF 等各自独立的模板，这样灵活性更高，模板继承可以将这些独立的模板文件连接在一起。</p>
<p>使用 <code>include</code>语句可以将一个模板完全插入到另一个模板中：</p>
<figure class="highlight jinja"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> &#x27;vlans.j2&#x27; %&#125;</span></span><br></pre></td></tr></table></figure>
<p>另一种继承的方法是使用 <code>bolck</code> 语句，子模板引用父模板后，可以指定其中的某些部分，如果子模板中不存在，则使用父模板中的值。父模板也可以将 <code>bolck</code> 留空，子模板直接填充内容。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父模板，cat father.j2</span></span><br><span class="line">This <span class="keyword">is</span> father template.</span><br><span class="line">&#123;% block test %&#125;</span><br><span class="line"> This <span class="keyword">is</span> line can be replaced.</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">This <span class="keyword">is</span> father template.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子模板，cat children.j2</span></span><br><span class="line">&#123;% extends <span class="string">&#x27;father.j2&#x27;</span> %&#125;</span><br><span class="line">&#123;% block test %&#125;</span><br><span class="line">This <span class="keyword">is</span> children template.</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 渲染结果，block 被替代，其他内容不变。</span></span><br><span class="line">This <span class="keyword">is</span> father template.</span><br><span class="line">This <span class="keyword">is</span> children template.</span><br><span class="line">This <span class="keyword">is</span> father template.</span><br></pre></td></tr></table></figure>

<h2 id="filter-语句的使用"><a href="#filter-语句的使用" class="headerlink" title="filter 语句的使用"></a>filter 语句的使用</h2><p>filter 语句的作用就是对模板数据块的内容进行格式化修改。<br>例如：大小写转换、统计长度、计算绝对值等等，内置支持的过滤器可参见<a href="https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters">官网</a></p>
<p>来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat jinja2_filter.j2</span><br><span class="line">&#123;% for person in people %&#125;</span><br><span class="line">My name is &#123;&#123; person.name | upper() &#125;&#125;, and I am &#123;&#123; person[&#x27;age&#x27;] &#125;&#125; years old.</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码不再赘述，打印结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">My name is ZHANG SAN, and I am 18 years old.</span><br><span class="line"></span><br><span class="line">My name is LI SI, and I am 20 years old.</span><br><span class="line"></span><br><span class="line">My name is WANG WU, and I am 22 years old.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Jinja2-Custom-Filters"><a href="#Jinja2-Custom-Filters" class="headerlink" title="Jinja2 Custom Filters"></a>Jinja2 Custom Filters</h2><p>内置的 filter 可能会不满足自己的需要，这时就需要进行自定义了。<br>自定义筛选器只是常规 Python 函数，将筛选器的左侧作为第一个参数，并将参数作为额外的参数或关键字参数传递给筛选器。</p>
<p>可以将自己写的函数、导入的模块等更新到环境中，进而在 Jinja2 中使用。</p>
<p>Jinja2 的默认 filter 是一个字典，查看方式：<code>Environment.filters</code></p>
<p>使用方法：通过更新 <strong>environment</strong> 中的 <strong>filters</strong> 字典，在模板环境中注册。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">env = Environment(loader=FileSystemLoader(<span class="string">&#x27;./templates/&#x27;</span>))</span><br><span class="line">env.filters[<span class="string">&#x27;datetimeformat&#x27;</span>] = datetimeformat</span><br></pre></td></tr></table></figure>
<p>在模板中使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; article.pub_date|datetimeformat &#125;&#125;</span><br><span class="line"><span class="comment"># 传参方法</span></span><br><span class="line"><span class="comment"># &#123;&#123; 42| myfilter(23) &#125;&#125; ==  myfilter(42, 23)</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义过滤器示例"><a href="#自定义过滤器示例" class="headerlink" title="自定义过滤器示例"></a>自定义过滤器示例</h3><p>将 <code>ipaddress.IPv4Interface</code> 作为过滤器，来实现将传入的 IP 地址变量进行分析。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照jinja2自定义过滤器传参方法定义一个函数，获取其他模块的属性 **getattr**</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_ipaddr</span>(<span class="params">ipaddress,operation</span>):</span><br><span class="line">    <span class="keyword">from</span> ipaddress <span class="keyword">import</span> IPv4Interface</span><br><span class="line">    ipadd = IPv4Interface(ipaddress)</span><br><span class="line">    attr = <span class="built_in">getattr</span>(ipadd,operation)</span><br><span class="line">    <span class="keyword">return</span> attr</span><br><span class="line"><span class="comment"># 添加到环境中</span></span><br><span class="line">env = Environment(loader=FileSystemLoader(<span class="string">&#x27;./roles/cmw7/templates/&#x27;</span>))</span><br><span class="line">env.filters[<span class="string">&#x27;custom_ipaddr&#x27;</span>] = custom_ipaddr</span><br><span class="line"><span class="comment"># 在模板中使用</span></span><br><span class="line"><span class="comment"># cat filter_test.j2</span></span><br><span class="line">&#123;&#123; <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">24</span> | custom_ipaddr(<span class="string">&#x27;netmask&#x27;</span>) &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Macro（宏：相当于函数）"><a href="#Macro（宏：相当于函数）" class="headerlink" title="Macro（宏：相当于函数）"></a>Macro（宏：相当于函数）</h2><p>可以自己编写一个函数，然后在模板中调用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat test.j2</span></span><br><span class="line">&#123;% macro testfunc() %&#125;</span><br><span class="line">  test string</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空白行的处理"><a href="#空白行的处理" class="headerlink" title="空白行的处理"></a>空白行的处理</h2><p>通过上面的实践，你可能会发现，生成的结果中，有很多空行，默认情况下，jinja2 会给渲染后的结果加上空行。</p>
<p>如果需要去除模板中的空白，如 For 语句前后、变量表达式的开头或结尾添加减号 (-)，就会删除这个语句块之前或之后的空格。</p>
<p>以上文中的 for 循环为例，修改模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat jinja2.j2</span><br><span class="line">&#123;% for name in names -%&#125;</span><br><span class="line">Hello &#123;&#123; name &#125;&#125;.</span><br><span class="line">&#123;%- endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的 <code>-</code> 符号，放在 for 的结尾，是删除语句块之前的空行，放在 endfor 之前，是删除语句块之后的空行，如果前后的空行都删除了，则内容会在同一行，所以，上面模板渲染之后的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello Zhang San.Hello Li Si.Hello Wang Wu.</span><br></pre></td></tr></table></figure>
<p>具体请根据自己的需求来进行空白行的控制。</p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>实际应用过程中，由于 jinja2 的模板需要传入字典、列表等，为了方便维护，我们可以使用单独的变量文件来存储这些东西，例如 YAML、JSON 等，一般使用 YAML ，因为简洁易读。</p>
<p>下面通过一个生成交换机配置的文件，来对 jinja2 模板语法进行综合使用。<br>模板文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat l2_interface.j2</span><br><span class="line">&#123;% for iface in l2_interface -%&#125;</span><br><span class="line">#</span><br><span class="line">interface &#123;&#123; iface.iface_name &#125;&#125;</span><br><span class="line"> &#123;% if iface.desc != None -%&#125;</span><br><span class="line"> description &#123;&#123; iface.desc &#125;&#125;</span><br><span class="line"> &#123;% endif -%&#125;</span><br><span class="line">&#123;% if iface.link_type == &#x27;trunk&#x27; -%&#125;</span><br><span class="line"> port link-type trunk</span><br><span class="line"> undo port trunk permit vlan 1</span><br><span class="line"> port trunk permit vlan &#123;&#123; iface.allow_vlan &#125;&#125;</span><br><span class="line">&#123;% else -%&#125;</span><br><span class="line"> port link-type access</span><br><span class="line"> port access vlan &#123;&#123; iface.allow_vlan &#125;&#125;</span><br><span class="line">&#123;% endif -%&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>变量文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># l2_interface.yaml</span></span><br><span class="line"><span class="attr">l2_interface:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">iface_name:</span> <span class="string">g1/0/1</span></span><br><span class="line">    <span class="attr">desc:</span> <span class="string">jinja2_render_config</span></span><br><span class="line">    <span class="attr">link_type:</span> <span class="string">access</span></span><br><span class="line">    <span class="attr">allow_vlan:</span> <span class="number">10</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">iface_name:</span> <span class="string">g1/0/2</span></span><br><span class="line">    <span class="attr">desc:</span> </span><br><span class="line">    <span class="attr">link_type:</span> <span class="string">trunk</span></span><br><span class="line">    <span class="attr">allow_vlan:</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template, FileSystemLoader, Environment</span><br><span class="line"></span><br><span class="line">j2_loader = FileSystemLoader(<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line">env = Environment(loader=j2_loader)</span><br><span class="line">j2_tmpl = env.get_template(<span class="string">&#x27;./l2_interfaces.j2&#x27;</span>)</span><br><span class="line"><span class="comment"># 加载变量文件，解析成列表/字典</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;l2_interfaces.yaml&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">vars</span> = yaml.safe_load(f.read())</span><br><span class="line">result = j2_tmpl.render(<span class="built_in">vars</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>最终生成了以下配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">interface g1/0/1</span><br><span class="line"> description jinja2_render_config</span><br><span class="line"> port link-type access</span><br><span class="line"> port access vlan 10</span><br><span class="line">#</span><br><span class="line">interface g1/0/2</span><br><span class="line"> port link-type trunk</span><br><span class="line"> undo port trunk permit vlan 1</span><br><span class="line"> port trunk permit vlan 10 20 30</span><br></pre></td></tr></table></figure>

<p>下面是一个我自己写的案例，供参考。<br><a href="https://github.com/xdai555/ansible_creat_config"> Ansible Role：根据 Jinja2 生成 H3C Comware V7 配置</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际场景中，可以将固化配置做成模板文件，生成配置时，只要传入指定的参数，就可生成对应的配置，降低配置编写复杂度的同时，也降低了出错的概率。</p>
]]></content>
      <categories>
        <category>NetDevOps</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jinja</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark-notes</title>
    <url>/posts/f77b58f5.html</url>
    <content><![CDATA[<h2 id="捕获过滤器"><a href="#捕获过滤器" class="headerlink" title="捕获过滤器"></a>捕获过滤器</h2><p>Wireshark 中，捕获过滤器使用了伯克利包过滤（Berkeley Packet Filter，BPF），它采用了一种与自然语言很接近的语法，利用这种语法构成的字符串可以确定保留哪些数据包以及忽略掉哪些数据包，限定符有 3 种：</p>
<ul>
<li>type：host（默认）、net、port</li>
<li>dir：src、dst</li>
<li>proto：ether、ip、tcp、arp 等</li>
</ul>
<p>举例：</p>
<ul>
<li><code>src host 192.168.1.100 and dst net 192.168.1.0/24</code></li>
<li><code>ether dst 11:22:33:44:55:66</code></li>
<li><code>tcp port 8080</code></li>
</ul>
<span id="more"></span>

<p><strong>高级用法</strong>：可以进行精确到位的操作，针对数据报文中的每个字段进行过滤控制，语法为 <code>proto[expr:size]</code> ，其中 <code>expr</code> 为偏移量，<code>size</code> 为要操作的字节数，默认为 1。</p>
<p>例如：一个 IP 数据包头部长度为 20 字节，其中 12~15 这四个字节表示的是源地址，如果要过滤源地址为 192.168.1.1 的数据包（需要把 IP 地址转换为 16 进制），表达式可以写为：<code>ip[12:4] = 0xC0A80101</code>。</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/202112132329896.png"></p>
<h2 id="显示过滤器"><a href="#显示过滤器" class="headerlink" title="显示过滤器"></a>显示过滤器</h2><p>显示过滤器是在捕获数据之后再使用，语法与捕获过滤器不同。</p>
<p>一般由三部分组成：字段名称、关系、值，例如 <code>ip.src == 192.168.1.1</code>，Wireshark 过滤器输入框具有联想功能，可以显示出协议的可选字段（如下图），方便进行过滤器的编写。</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/202112132329898.png" alt="过滤器"></p>
<p>一个过滤表达式编写完成且格式正确时，输入框会显示为绿色；反之，则为红色，需要表达式进行修改。</p>
<p>Wireshark 还可以使用数据包中的指定字段来创建过滤表达式。首先在数据包列表处选中一个数据包，然后在数据包详细信息栏处查看这个数据包的详细内容，这里会以行的形式展示数据包的信息，当选中其中一行时（见下图），例如 IP 地址，那么在状态栏处就会显示出该数据包该行对应的过滤器表达式。</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/202112132329900.png" alt="状态栏显示过滤器"></p>
<p>还有更简单的办法，就是在选中的字段单击右键，在弹出菜单中选择“作为过滤器应用”，并根据二级菜单进行选择“选中”，就可以在输入栏中看到生成的表达式了。</p>
<h2 id="远程捕获数据包"><a href="#远程捕获数据包" class="headerlink" title="远程捕获数据包"></a>远程捕获数据包</h2><p>在实际工作中，经常会碰到捕捉其他设备通信数据包的情况，例如在机房的服务器，可以登录但却不能直接触碰。多数情况下，会采用在远程设备上安装 Wireshark，再通过远程桌面的方式进行操作，这样不但会加大工作量，也产生了不必要的数据包。</p>
<p>Wireshark 提供了远程捕获数据包的功能，可以很方便的监控远程服务器上的流量，只需要在服务器上安装 <code>rpcap</code> 即可，Windows 操作系统安装了 WinPcap 后，就自带了该工具。</p>
<p>Linux 下需要编译安装，参见 <a href="https://github.com/rpcapd-linux/rpcapd-linux">rpcapd</a>。</p>
<p>使用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">rpcapd -h</span></span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line"> rpcapd [-b &lt;address&gt;] [-p &lt;port&gt;] [-6] [-l &lt;host_list&gt;] [-a &lt;host,port&gt;]</span><br><span class="line">        [-n] [-v] [-d] [-s &lt;file&gt;] [-f &lt;file&gt;]</span><br><span class="line">  -b &lt;address&gt;: the address to bind to (either numeric or literal).</span><br><span class="line">      Default: it binds to all local IPv4 addresses</span><br><span class="line">  -p &lt;port&gt;: the port to bind to. Default: it binds to port 2002</span><br><span class="line">  -4: use only IPv4 (default both IPv4 and IPv6 waiting sockets are used)</span><br><span class="line">  -l &lt;host_list&gt;: a file that keeps the list of the hosts which are allowed</span><br><span class="line">      to connect to this server (if more than one, list them one per line).</span><br><span class="line">      We suggest to use literal names (instead of numeric ones) in order to</span><br><span class="line">      avoid problems with different address families</span><br><span class="line">  -n: permit NULL authentication (usually used with &#x27;-l&#x27;)</span><br><span class="line">  -a &lt;host,port&gt;: run in active mode when connecting to &#x27;host&#x27; on port &#x27;port&#x27;</span><br><span class="line">      In case &#x27;port&#x27; is omitted, the default port (2003) is used</span><br><span class="line">  -v: run in active mode only (default: if &#x27;-a&#x27; is specified, it accepts</span><br><span class="line">      passive connections as well</span><br><span class="line">  -d: run in daemon mode (UNIX only) or as a service (Win32 only)</span><br><span class="line">      Warning (Win32): this switch is provided automatically when the service</span><br><span class="line">      is started from the control panel</span><br><span class="line">  -s &lt;file&gt;: save the current configuration to file</span><br><span class="line">  -f &lt;file&gt;: load the current configuration from file; all the switches</span><br><span class="line">      specified from the command line are ignored</span><br><span class="line">  -h: print this help screen</span><br></pre></td></tr></table></figure>

<p>例如：在 远程服务器中运行了 <code>rpcapd -4 -n -p 8888</code>，那么可以在本地 Wireshark 中，添加远程抓包，如下图：</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/202112132329901.png" alt="开启远程抓包"></p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/202112132329902.png" alt="wireshark 配置连接远程抓包"></p>
<p>之后，就可以在本地的 Wireshark 抓到远程服务器上的数据包了。</p>
<h2 id="解密数据包"><a href="#解密数据包" class="headerlink" title="解密数据包"></a>解密数据包</h2><p>Chrome 浏览器添加运行参数 ：<code>--ssl-key-log-file=&quot;C:\Users\xdai\Desktop\sslkeylog.log&quot;</code>，可以将访问网站的 SSL Key 信息保存下来，或者为系统添加环境变量 <code>SSHKEYLOGFILE = &quot;/Path/to/log&quot;</code> 来保存 log 文件，对于 Windows 系统，环境变量重启系统会才会生效&#x2F;取消生效，Linux 系统使用 <code>export</code> 立即生效。</p>
<p>然后打开 Wireshark 开启抓包，打开 Chrome 访问百度；抓取到数据包后，导入已经出现的 SSL Key 信息：“编辑”→“首选项”，然后在打开的“首选项”窗口中选中“Protocols”，找到 TLS 并导入文件。</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/202112132329903.png" alt="ssl key 设置"></p>
<p>可以看到之前为加密的数据包，导入 Key 之后，以明文的方式显示出来了（例如，403 和 408）。</p>
<p>解密前：</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/202112132329904.png" alt="解密前报文"></p>
<p>解密后：</p>
<p><img data-src="http://oss.xdai.vip/md-note/imgs/202112132329905.png" alt="解密后报文"></p>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 设置代理集合 apt yum wget curl git pip 设置代理 使用代理服务器</title>
    <url>/posts/2121acf.html</url>
    <content><![CDATA[<h2 id="apt-get-使用代理"><a href="#apt-get-使用代理" class="headerlink" title="apt-get 使用代理"></a>apt-get 使用代理</h2><p>仅为apt-get设置代理服务器<br>添加<code>/etc/apt/</code>文件夹下的<code>apt.conf</code>文件，默认不存在<br><code>sudo gedit /etc/apt/apt.conf</code>在的<code>apt.conf</code>文件中加入下面这行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Acquire::http::Proxy &quot;http://proxyusr:password@yourproxyaddress:proxyport&quot;;</span></span><br><span class="line">Acquire::http::Proxy <span class="string">&quot;http://10.1.249.61:3128&quot;</span>;</span><br><span class="line">Acquire::ftp::proxy <span class="string">&quot;ftp://10.1.249.61:3128&quot;</span>;</span><br><span class="line">Acquire::https::proxy <span class="string">&quot;https://10.1.249.61:3128&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>根据实际情况替换 用户名:密码@地址和端口号。<br>&#x3D;&#x3D;注意符号不要少写（不要丢了最后的一个分号）。&#x3D;&#x3D;</p>
<span id="more"></span>

<h2 id="YUM-使用代理"><a href="#YUM-使用代理" class="headerlink" title="YUM 使用代理"></a>YUM 使用代理</h2><p>编辑<code>/etc/yum.conf</code>，在最后加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Proxy</span></span><br><span class="line">proxy=http://username:password@proxy_ip:port/</span><br></pre></td></tr></table></figure>
<p>YUM update不更新内核<br>修改yum的配置文件 <code>vim /etc/yum.conf</code>，在 <code>[main]</code> 的最后添加 <code>exclude=kernel*</code></p>
<h2 id="wget-使用代理"><a href="#wget-使用代理" class="headerlink" title="wget 使用代理"></a>wget 使用代理</h2><p>编辑<code>/etc/wgetrc</code>，在最后加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Proxy</span></span><br><span class="line">http_proxy=http://username:password@proxy_ip:port/</span><br><span class="line">ftp_proxy=http://username:password@proxy_ip:port/</span><br></pre></td></tr></table></figure>
<p>当前用户永久生效：<br>创建<code>$HOME/.wgetrc</code>文件，加入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_proxy=IP:Port</span><br></pre></td></tr></table></figure>

<p>临时使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$wget</span> -e <span class="string">&quot;http_proxy=http://[IP:Port]&quot;</span> www.google.com</span><br></pre></td></tr></table></figure>

<h2 id="bash-x2F-shell-使用代理"><a href="#bash-x2F-shell-使用代理" class="headerlink" title="bash&#x2F;shell 使用代理"></a>bash&#x2F;shell 使用代理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> proxy=<span class="string">&quot;http://10.20.56.32:8000&quot;</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="variable">$proxy</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$proxy</span></span><br><span class="line"><span class="built_in">export</span> ftp_proxy=<span class="variable">$proxy</span></span><br></pre></td></tr></table></figure>
<p>取消代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">&quot;localhost, 127.0.0.1, ::1&quot;</span></span><br><span class="line"><span class="built_in">export</span> all_proxy=<span class="string">&quot;http://10.20.56.32:8000&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="Git-使用代理"><a href="#Git-使用代理" class="headerlink" title="Git 使用代理"></a>Git 使用代理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy 10.167.32.133:8080</span><br><span class="line">git config --global https.proxy 10.167.32.133:8080</span><br></pre></td></tr></table></figure>
<p>取消代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<h2 id="pip-使用代理"><a href="#pip-使用代理" class="headerlink" title="pip 使用代理"></a>pip 使用代理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt --proxy=[IP:Port]</span><br></pre></td></tr></table></figure>

<h2 id="curl-使用代理"><a href="#curl-使用代理" class="headerlink" title="curl  使用代理"></a>curl  使用代理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定http代理IP和端口</span></span><br><span class="line">curl -x 113.185.19.192:80 http://baidu.com</span><br><span class="line">curl --proxy 113.185.19.192:80 http://baidu.com</span><br><span class="line">curl -x http_proxy://113.185.19.192:80 http://baidu.com</span><br><span class="line">curl -x https_proxy://113.185.19.192:80 http://baidu.com</span><br><span class="line">curl -x 113.185.19.192:80 --proxy-user aiezu:123456 http://baidu.com</span><br></pre></td></tr></table></figure>




<h2 id="Windows-cmd-使用代理"><a href="#Windows-cmd-使用代理" class="headerlink" title="Windows cmd 使用代理"></a>Windows cmd 使用代理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 http 类型代理</span></span><br><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:8484</span><br><span class="line"><span class="built_in">set</span> https_proxy=http://127.0.0.1:8484</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 socks 类型代理</span></span><br><span class="line">netsh winhttp <span class="built_in">set</span> proxy proxy-server=<span class="string">&quot;socks=127.0.0.1:8484&quot;</span> bypass-list=<span class="string">&quot;localhost&quot;</span></span><br><span class="line">netsh winhttp show proxy</span><br><span class="line">netsh winhttp reset proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 socks 类型代理</span></span><br><span class="line"><span class="built_in">set</span> http_proxy=socks5://127.0.0.1:8484</span><br><span class="line"><span class="built_in">set</span> https_proxy=socks5://127.0.0.1:8484</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>代理</tag>
      </tags>
  </entry>
</search>
